From f5bf472a35d4475d26691346976cd646de04ea3a Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Mon, 5 Feb 2024 17:17:00 -0800
Subject: [PATCH 01/14] oralndo - for updates of settings

---
 .gitmodules                                   |    3 +-
 BUILD.bazel                                   |    1 +
 CMakeLists.txt                                |    9 +-
 aten/src/ATen/ATen.h                          |    5 +-
 aten/src/ATen/CMakeLists.txt                  |   15 +-
 aten/src/ATen/EmptyTensor.h                   |    4 +-
 aten/src/ATen/cpu/vec/vec256/vec256_int.h     |    8 +
 aten/src/ATen/cpu/vec/vec_base.h              |    7 +
 aten/src/ATen/cuda/ApplyGridUtils.cuh         |    4 +-
 aten/src/ATen/cuda/Atomic.cuh                 |    5 +-
 aten/src/ATen/cuda/CUDAApplyUtils.cuh         |    4 +-
 aten/src/ATen/cuda/CUDABlas.cpp               |   97 +-
 aten/src/ATen/cuda/CUDAContextLight.h         |    4 +-
 aten/src/ATen/cuda/CUDADataType.h             |    8 +-
 aten/src/ATen/cuda/CUDASparseDescriptors.cpp  |    4 +-
 aten/src/ATen/cuda/CUDASparseDescriptors.h    |    8 +-
 aten/src/ATen/cuda/CublasHandlePool.cpp       |    4 +-
 aten/src/ATen/cuda/EmptyTensor.h              |    4 +-
 aten/src/ATen/cuda/Exceptions.h               |    8 +-
 aten/src/ATen/cuda/Sleep.cu                   |    4 +-
 aten/src/ATen/cuda/Sleep.h                    |    4 +-
 aten/src/ATen/cuda/cub-RadixSortPairs.cu      |    4 +-
 aten/src/ATen/cuda/cub.cu                     |    4 +-
 aten/src/ATen/cuda/cub.cuh                    |    8 +-
 aten/src/ATen/cuda/cub.h                      |    4 +-
 aten/src/ATen/cuda/detail/IndexUtils.cuh      |    4 +-
 aten/src/ATen/cuda/detail/IntegerDivider.cuh  |    4 +-
 aten/src/ATen/cuda/detail/TensorInfo.cuh      |    4 +-
 aten/src/ATen/functorch/Interpreter.h         |    9 +
 aten/src/ATen/native/AdaptiveMaxPooling3d.cpp |   26 +-
 aten/src/ATen/native/CanUse32BitIndexMath.h   |    4 +-
 aten/src/ATen/native/DispatchStub.h           |    4 +-
 aten/src/ATen/native/LinearAlgebra.cpp        |   20 +
 aten/src/ATen/native/ReduceOps.cpp            |   11 +
 .../native/TensorIteratorDynamicCasting.h     |    4 +-
 .../ATen/native/cpu/AdaptiveMaxPoolKernel.cpp |   19 +-
 aten/src/ATen/native/cpu/MaxPoolKernel.cpp    |   10 +
 aten/src/ATen/native/cpu/MaxPooling.cpp       |   17 +
 aten/src/ATen/native/cuda/EmbeddingBag.cu     |    3 +-
 .../native/sparse/cuda/SparseBlasImpl.cpp     |    5 +-
 .../sparse/cuda/SparseCUDATensorMath.cu       |   10 +-
 aten/src/ATen/record_function.cpp             |   54 +
 aten/src/ATen/record_function.h               |    8 +
 aten/src/ATen/test/vec_test_all_types.h       |    9 +
 c10/CMakeLists.txt                            |    2 +-
 c10/core/ConstantSymNodeImpl.h                |    8 +
 c10/core/SymbolicShapeMeta.cpp                |   33 +
 c10/core/impl/cow/COW.h                       |    8 +
 c10/core/impl/cow/COWDeleter.cpp              |    8 +
 c10/core/impl/cow/COWDeleter.h                |   22 +-
 c10/cuda/CUDACachingAllocator.cpp             |    5 +
 c10/test/core/impl/cow_test.cpp               |   14 +-
 c10/test/util/TypeIndex_test.cpp              |   28 +-
 c10/test/util/intrusive_ptr_test.cpp          |    5 +-
 c10/test/util/ssize_test.cpp                  |   12 +-
 c10/test/util/string_view_test.cpp            |    4 +
 c10/test/util/typeid_test.cpp                 |    4 +
 c10/util/BFloat16-inl.h                       |    4 +-
 c10/util/BFloat16.h                           |    4 +-
 c10/util/C++17.h                              |    4 +-
 c10/util/Exception.h                          |   13 +-
 c10/util/Float8_e4m3fnuz.cpp                  |    8 +
 c10/util/Float8_e5m2fnuz.cpp                  |    8 +
 c10/util/MaybeOwned.h                         |   16 +-
 c10/util/Optional.h                           | 1239 +++++++
 c10/util/SmallVector.h                        |   33 +-
 c10/util/floating_point_utils.h               |    4 +-
 c10/util/in_place.h                           |   19 +
 c10/util/safe_numerics.h                      |   10 +
 c10/util/tempfile.cpp                         |    4 +-
 c10/util/tempfile.h                           |    9 +
 c10/util/variant.h                            | 3025 +++++++++++++++++
 caffe2/CMakeLists.txt                         |   15 +-
 caffe2/core/macros.h.in                       |    2 +
 caffe2/mpi/mpi_ops_gpu.cc                     |   18 +-
 cmake/Dependencies.cmake                      |   41 +-
 .../FindCUDA/select_compute_arch.cmake        |   76 +-
 cmake/Summary.cmake                           |    1 +
 cmake/public/cuda.cmake                       |   10 +-
 functorch/CMakeLists.txt                      |    2 +-
 migration_note.md                             |   69 +
 test/cpp/api/CMakeLists.txt                   |    6 +-
 third_party/tensorpipe                        |    2 +-
 torch/csrc/api/include/torch/enum.h           |   13 +
 .../api/include/torch/nn/functional/conv.h    |   33 +
 .../include/torch/nn/functional/embedding.h   |    9 +
 .../include/torch/nn/functional/upsampling.h  |   11 +
 torch/csrc/api/include/torch/nn/init.h        |   29 +
 .../csrc/api/include/torch/nn/modules/conv.h  |   57 +
 .../csrc/api/include/torch/nn/options/conv.h  |   15 +
 .../api/include/torch/nn/options/embedding.h  |   11 +
 .../csrc/api/include/torch/nn/options/loss.h  |  110 +
 .../api/include/torch/nn/options/padding.h    |   15 +
 torch/csrc/api/include/torch/nn/options/rnn.h |   24 +
 .../torch/nn/options/transformerlayer.h       |   16 +
 .../api/include/torch/nn/options/upsampling.h |   28 +
 .../api/include/torch/nn/options/vision.h     |   13 +
 torch/csrc/api/src/nn/modules/conv.cpp        |   11 +
 .../autograd_not_implemented_fallback.cpp     |    8 +
 torch/csrc/autograd/function.h                |    4 +
 torch/csrc/autograd/input_metadata.cpp        |   22 +
 torch/csrc/autograd/profiler_kineto.cpp       |   50 +
 torch/csrc/distributed/c10d/GroupRegistry.cpp |    9 +
 .../csrc/distributed/c10d/ProcessGroupMPI.cpp |   17 +-
 torch/csrc/distributed/c10d/RankLocal.hpp     |   32 +
 torch/csrc/jit/api/module.h                   |    2 +
 .../jit/frontend/function_schema_parser.cpp   |   10 +
 .../jit/frontend/function_schema_parser.h     |    8 +
 .../jit/passes/symbolic_shape_analysis.cpp    |    9 +
 .../csrc/jit/passes/symbolic_shape_analysis.h |    7 +
 .../csrc/jit/passes/symbolic_shape_cache.cpp  |    9 +
 torch/csrc/jit/runtime/operator.h             |   89 +
 torch/csrc/jit/tensorexpr/kernel.h            |    9 +
 torch/csrc/jit/tensorexpr/lowerings.h         |    9 +
 .../csrc/jit/tensorexpr/operators/conv2d.cpp  |    9 +
 torch/csrc/profiler/collection.cpp            |   10 +
 torch/csrc/profiler/collection.h              |   16 +
 torch/csrc/profiler/data_flow.cpp             |   10 +
 torch/csrc/profiler/util.cpp                  |    9 +
 torch/csrc/profiler/util.h                    |   16 +
 torch/library.h                               |    8 +
 torch/utils/cpp_extension.py                  |   16 +-
 122 files changed, 5855 insertions(+), 178 deletions(-)
 create mode 100644 c10/util/variant.h
 create mode 100644 migration_note.md

diff --git a/.gitmodules b/.gitmodules
index 7e1b09e591..e982ec28ea 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -121,7 +121,8 @@
 [submodule "third_party/tensorpipe"]
     ignore = dirty
     path = third_party/tensorpipe
-    url = https://github.com/pytorch/tensorpipe.git
+    branch = torch-2.2.0
+    url = https://github.com/llv22/tensorpipe-macos-cuda.git
 [submodule "third_party/cudnn_frontend"]
 	path = third_party/cudnn_frontend
 	url = https://github.com/NVIDIA/cudnn-frontend.git
diff --git a/BUILD.bazel b/BUILD.bazel
index f5739a9875..eaab9fcafb 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -306,6 +306,7 @@ cc_library(
             "aten/src/ATen/cuda/**/*.cuh",
             "aten/src/ATen/native/**/*.cuh",
             "aten/src/THC/*.cuh",
+            "/usr/local/cuda/*.h",
         ],
     ) + [
         ":aten_src_ATen_config",
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9194e520bb..f6eed33502 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -35,9 +35,9 @@ string(FIND "${CMAKE_CXX_FLAGS}" "-std=c++" env_cxx_standard)
 if(env_cxx_standard GREATER -1)
   message(
       WARNING "C++ standard version definition detected in environment variable."
-      "PyTorch requires -std=c++17. Please remove -std=c++ settings in your environment.")
+      "PyTorch requires -std=c++14. Please remove -std=c++ settings in your environment.")
 endif()
-set(CMAKE_CXX_STANDARD 17 CACHE STRING "The C++ standard whose features are requested to build this target.")
+set(CMAKE_CXX_STANDARD 14 CACHE STRING "The C++ standard whose features are requested to build this target.")
 set(CMAKE_C_STANDARD   11 CACHE STRING "The C standard whose features are requested to build this target.")
 
 # ---[ Utils
@@ -50,6 +50,8 @@ endif()
 
 if(LINUX)
   include(cmake/CheckAbi.cmake)
+  # see: to support shared_timed_mutex
+  string(APPEND CMAKE_CXX_FLAGS " -D_LIBCPP_DISABLE_AVAILABILITY")
   string(APPEND CMAKE_CXX_FLAGS " -D_GLIBCXX_USE_CXX11_ABI=${GLIBCXX_USE_CXX11_ABI}")
   string(APPEND CMAKE_CUDA_FLAGS " -D_GLIBCXX_USE_CXX11_ABI=${GLIBCXX_USE_CXX11_ABI}")
   if(${GLIBCXX_USE_CXX11_ABI} EQUAL 1)
@@ -310,6 +312,9 @@ option(USE_DISTRIBUTED "Use distributed" ON)
 cmake_dependent_option(
     USE_MPI "Use MPI for Caffe2. Only available if USE_DISTRIBUTED is on." ON
     "USE_DISTRIBUTED" OFF)
+cmake_dependent_option(
+    USE_CUDA_MPI "Force CUDA-Aware MPI for Caffe2. Only available if USE_DISTRIBUTED and USE_MPI is on." OFF
+    "USE_DISTRIBUTED AND USE_MPI" OFF)
 cmake_dependent_option(
     USE_UCC "Use UCC. Only available if USE_DISTRIBUTED is on." OFF
     "USE_DISTRIBUTED" OFF)
diff --git a/aten/src/ATen/ATen.h b/aten/src/ATen/ATen.h
index effdd469d1..52bcdfd340 100644
--- a/aten/src/ATen/ATen.h
+++ b/aten/src/ATen/ATen.h
@@ -1,7 +1,8 @@
 #pragma once
 
-#if !defined(_MSC_VER) && __cplusplus < 201703L
-#error C++17 or later compatible compiler is required to use ATen.
+// see: refer to https://stackoverflow.com/questions/26089319/is-there-a-standard-definition-for-cplusplus-in-c14
+#if !defined(_MSC_VER) && __cplusplus < 201402L
+#error C++14 or later compatible compiler is required to use ATen.
 #endif
 
 #include <ATen/Context.h>
diff --git a/aten/src/ATen/CMakeLists.txt b/aten/src/ATen/CMakeLists.txt
index 2c2b96745c..ebbb0e4f95 100644
--- a/aten/src/ATen/CMakeLists.txt
+++ b/aten/src/ATen/CMakeLists.txt
@@ -60,7 +60,7 @@ endif()
 
 file(GLOB base_h "*.h" "detail/*.h" "cpu/*.h" "cpu/vec/vec512/*.h" "cpu/vec/vec256/*.h" "cpu/vec/vec256/vsx/*.h" "cpu/vec/vec256/zarch/*.h" "cpu/vec/*.h" "quantized/*.h" "functorch/*.h")
 file(GLOB base_cpp "*.cpp" "detail/*.cpp" "cpu/*.cpp" "functorch/*.cpp")
-file(GLOB cuda_h "cuda/*.h" "cuda/detail/*.h" "cuda/*.cuh" "cuda/detail/*.cuh")
+file(GLOB cuda_h "cuda/*.h" "cuda/detail/*.h" "cuda/*.cuh" "cuda/detail/*.cuh" "/usr/local/cuda/include/*.h")
 file(GLOB cuda_cpp "cuda/*.cpp" "cuda/detail/*.cpp")
 file(GLOB cuda_nvrtc_stub_h "cuda/nvrtc_stub/*.h")
 file(GLOB cuda_nvrtc_stub_cpp "cuda/nvrtc_stub/*.cpp")
@@ -242,7 +242,9 @@ if(USE_CUDA AND USE_ROCM)
 endif()
 
 if(USE_CUDA)
-  list(APPEND ATen_CUDA_INCLUDE ${CMAKE_CURRENT_SOURCE_DIR}/cuda)
+  list(APPEND ATen_CUDA_INCLUDE
+  ${CMAKE_CURRENT_SOURCE_DIR}/cuda
+  )
   list(APPEND ATen_CUDA_CU_SRCS
     ${cuda_cu}
     ${native_cuda_cu}
@@ -302,6 +304,11 @@ if(USE_TBB)
   list(APPEND ATen_CPU_DEPENDENCY_LIBS TBB::tbb)
 endif()
 
+if(USE_OPENMP)
+  message("ATen is compiled with OPEN_MP (/Users/llv23/opt/miniconda3/lib/libomp.dylib)")
+  list(APPEND ATen_CPU_DEPENDENCY_LIBS /Users/llv23/opt/miniconda3/lib/libomp.dylib)
+endif()
+
 if(BLAS_FOUND)
   if($ENV{TH_BINARY_BUILD})
     message(STATUS "TH_BINARY_BUILD detected. Enabling special linkage.")
@@ -447,17 +454,20 @@ endif()
 
 if(USE_CUDA AND NOT USE_ROCM)
   list(APPEND ATen_CUDA_INCLUDE ${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/cutlass/include)
+  list(APPEND ATen_CUDA_INCLUDE /usr/local/cuda/include)
   if($ENV{ATEN_STATIC_CUDA})
     list(APPEND ATen_CUDA_DEPENDENCY_LIBS
       ${CUDA_LIBRARIES}
       CUDA::cusparse_static
       CUDA::cufft_static_nocallback
+      /Users/llv23/opt/miniconda3/lib/libomp.dylib # test parallel for symbol _omp_in_parallel
     )
    if(NOT BUILD_LAZY_CUDA_LINALG)
      if(CUDA_VERSION_MAJOR LESS_EQUAL 11)
        list(APPEND ATen_CUDA_DEPENDENCY_LIBS
          CUDA::cusolver_static
          ${CUDAToolkit_LIBRARY_DIR}/liblapack_static.a     # needed for libcusolver_static
+         /Users/llv23/opt/miniconda3/lib/libomp.dylib # test parallel for symbol _omp_in_parallel
        )
      elseif(CUDA_VERSION_MAJOR GREATER_EQUAL 12)
        list(APPEND ATen_CUDA_DEPENDENCY_LIBS
@@ -509,6 +519,7 @@ endif()
   endif(USE_MAGMA)
 
 # Include CPU paths for CUDA/HIP as well
+list(APPEND ATen_CUDA_INCLUDE /usr/local/cuda/include)
 list(APPEND ATen_CUDA_INCLUDE ${ATen_CPU_INCLUDE})
 list(APPEND ATen_HIP_INCLUDE ${ATen_CPU_INCLUDE})
 list(APPEND ATen_VULKAN_INCLUDE ${ATen_CPU_INCLUDE})
diff --git a/aten/src/ATen/EmptyTensor.h b/aten/src/ATen/EmptyTensor.h
index 5f8681ce37..4ffcacb08a 100644
--- a/aten/src/ATen/EmptyTensor.h
+++ b/aten/src/ATen/EmptyTensor.h
@@ -1,7 +1,7 @@
 #pragma once
 #include <ATen/core/TensorBase.h>
 
-namespace at::detail {
+namespace at{ namespace detail {
 
 inline void check_size_nonnegative(ArrayRef<int64_t> size) {
   for (const auto& x : size) {
@@ -157,4 +157,4 @@ TORCH_API TensorBase empty_strided_symint_meta(
     SymIntArrayRef stride,
     const TensorOptions& options);
 
-} // namespace at::detail
+}} // namespace at::detail
diff --git a/aten/src/ATen/cpu/vec/vec256/vec256_int.h b/aten/src/ATen/cpu/vec/vec256/vec256_int.h
index 8be98c211d..b45da34456 100644
--- a/aten/src/ATen/cpu/vec/vec256/vec256_int.h
+++ b/aten/src/ATen/cpu/vec/vec256/vec256_int.h
@@ -8,6 +8,14 @@
 #include <c10/macros/Macros.h>
 #include <c10/util/irange.h>
 
+#if defined(__APPLE__) and defined(__MACH__)
+#include <type_traits>
+// namespace std{
+//   template <class T, class U>
+//   inline constexpr bool is_same_v = is_same<T, U>::value;
+// }
+#endif
+
 namespace at::vec {
 inline namespace CPU_CAPABILITY {
 
diff --git a/aten/src/ATen/cpu/vec/vec_base.h b/aten/src/ATen/cpu/vec/vec_base.h
index f0a6d62424..7a1280f60b 100644
--- a/aten/src/ATen/cpu/vec/vec_base.h
+++ b/aten/src/ATen/cpu/vec/vec_base.h
@@ -38,6 +38,13 @@
 #include <c10/util/irange.h>
 #include <c10/util/Load.h>
 
+// #if defined(__APPLE__) and defined(__MACH__)
+// namespace std{
+//   template< class T >
+//   inline constexpr bool is_signed_v = is_signed<T>::value;
+// }
+// #endif
+
 // These macros helped us unify vec_base.h
 #ifdef CPU_CAPABILITY_AVX512
 #if defined(__GNUC__)
diff --git a/aten/src/ATen/cuda/ApplyGridUtils.cuh b/aten/src/ATen/cuda/ApplyGridUtils.cuh
index 18ce3ba34e..ef0cc1bd9b 100644
--- a/aten/src/ATen/cuda/ApplyGridUtils.cuh
+++ b/aten/src/ATen/cuda/ApplyGridUtils.cuh
@@ -2,7 +2,7 @@
 
 #include <cuda_runtime.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 /**
    Computes ceil(a / b)
@@ -44,4 +44,4 @@ inline dim3 getApplyBlock(int max_threads_per_block=AT_APPLY_THREADS_PER_BLOCK)
 }
 
 } // anonymous namespace
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/Atomic.cuh b/aten/src/ATen/cuda/Atomic.cuh
index 56ee8f87e2..8f259521ee 100644
--- a/aten/src/ATen/cuda/Atomic.cuh
+++ b/aten/src/ATen/cuda/Atomic.cuh
@@ -6,7 +6,8 @@
 
 #include <ATen/NumericUtils.h>
 
-#if !(defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800))))
+// #if !(defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800)))) && CUDA_VERSION >= 11000
+#if CUDA_VERSION >= 11000
 #include <cuda_bf16.h>
 #endif
 
@@ -220,7 +221,7 @@ static inline  __device__ at::Half gpuAtomicAdd(at::Half *address, at::Half val)
 }
 
 static inline __device__ at::BFloat16 gpuAtomicAdd(at::BFloat16 *address, at::BFloat16 val) {
-#if defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800)))
+#if defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800))) || CUDA_VERSION < 11000
 return AtomicFPOp<at::BFloat16>()(address, val,
                                   [](at::BFloat16 bsum, at::BFloat16 val) {
                                     return bsum + val;
diff --git a/aten/src/ATen/cuda/CUDAApplyUtils.cuh b/aten/src/ATen/cuda/CUDAApplyUtils.cuh
index cd857c0098..807470a4bc 100644
--- a/aten/src/ATen/cuda/CUDAApplyUtils.cuh
+++ b/aten/src/ATen/cuda/CUDAApplyUtils.cuh
@@ -89,7 +89,7 @@
   );
 */
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 // TODO: combine with TensorArg?  So far that's been for debugging, and this is functional...
 enum class TensorArgType { ReadWrite, ReadOnly };
@@ -534,4 +534,4 @@ inline bool CUDA_tensor_apply2(const at::TensorBase &a,
                             max_threads_per_block, min_blocks_per_sm>(a, b, op, aType, bType);
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDABlas.cpp b/aten/src/ATen/cuda/CUDABlas.cpp
index c1a842653f..5cabfce927 100644
--- a/aten/src/ATen/cuda/CUDABlas.cpp
+++ b/aten/src/ATen/cuda/CUDABlas.cpp
@@ -17,6 +17,10 @@
 #include <cublasLt.h>
 #endif
 
+// refer to http://www.jcuda.org/jcuda/jcublas/doc/constant-values.html#jcuda.jcublas.cublasMath.CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION
+// for more details
+static int CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION = 16;
+
 #ifdef USE_ROCM
 // until hipblas has an API to accept flags, we must use rocblas here
 #include <rocblas/rocblas.h>
@@ -331,6 +335,7 @@ void bgemm<at::Half>(CUDABLAS_BGEMM_ARGTYPES(at::Half)) {
 
 template <>
 void bgemm<at::BFloat16>(CUDABLAS_BGEMM_ARGTYPES(at::BFloat16)) {
+#if defined(USE_ROCM) || defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   // See Note [Writing Nondeterministic Operations]
   globalContext().alertCuBLASConfigNotDeterministic();
   BGEMM_CHECK_ARGVALUES(at::BFloat16);
@@ -340,13 +345,16 @@ void bgemm<at::BFloat16>(CUDABLAS_BGEMM_ARGTYPES(at::BFloat16)) {
   const float falpha = alpha;
   const float fbeta = beta;
   _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
+#endif
 
+#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
   TORCH_CUDABLAS_CHECK(cublasGemmStridedBatchedEx(handle,
                                   opa, opb, (int)m, (int)n, (int)k,
                                   (void*)&falpha, a, CUDA_R_16BF, (int)lda, stridea,
                                   b, CUDA_R_16BF, (int)ldb, strideb,
                                   (void*)&fbeta, c, CUDA_R_16BF, (int)ldc, stridec,
                                   (int)num_batches, CUDA_R_32F, CUBLAS_GEMM_DEFAULT_TENSOR_OP));
+#endif
 }
 
 template <>
@@ -455,8 +463,18 @@ void gemm<at::Half>(CUDABLAS_GEMM_ARGTYPES(at::Half)) {
       cublas_flags = static_cast<cublasMath_t>(cublas_flags | CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION);
     }
 #endif
+#if defined(CUDA_VERSION) && CUDA_VERSION < 11000
+    // On CUDA versions prior to 11, users are required to set the math mode to CUBLAS_TENSOR_OP_MATH
+    // manually to be able to use tensor cores for FP16. On CUDA 11, this is no longer required.
+    TORCH_CUDABLAS_CHECK(cublasSetMathMode(handle, CUBLAS_TENSOR_OP_MATH));
+#else
+    cublasMath_t cublas_flags = CUBLAS_DEFAULT_MATH;
+    if (!at::globalContext().allowFP16ReductionCuBLAS()) {
+      cublas_flags = static_cast<cublasMath_t>(cublas_flags | CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION);
+    }
     // Disallow fp16 reductions that could lead to unexpected overflow issues.
     TORCH_CUDABLAS_CHECK(cublasSetMathMode(handle, cublas_flags));
+#endif  // defined(CUDA_VERSION) && CUDA_VERSION < 11000
     TORCH_CUDABLAS_CHECK(cublasGemmEx(
         handle,
         opa,
@@ -501,6 +519,46 @@ void gemm<at::Half>(CUDABLAS_GEMM_ARGTYPES(at::Half)) {
 #endif
 }
 
+#ifdef USE_ROCM
+template <>
+void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
+  cublasHandle_t handle = at::cuda::getCurrentCUDABlasHandle();
+  cublasOperation_t opa = _cublasOpFromChar(transa);
+  cublasOperation_t opb = _cublasOpFromChar(transb);
+  float falpha = alpha;
+  float fbeta = beta;
+  _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
+  GEMM_CHECK_ARGVALUES(at::BFloat16);
+  TORCH_CUDABLAS_CHECK(rocblas_gemm_ex(
+      handle,
+      opa,
+      opb,
+      m,
+      n,
+      k,
+      &falpha,
+      a,
+      rocblas_datatype_bf16_r,
+      lda,
+      b,
+      rocblas_datatype_bf16_r,
+      ldb,
+      &fbeta,
+      c,
+      rocblas_datatype_bf16_r,
+      ldc,
+      c,
+      rocblas_datatype_bf16_r,
+      ldc,
+      rocblas_datatype_f32_r,
+      rocblas_gemm_algo_standard,
+      0,
+      0));
+}
+#endif
+
+#if !defined(USE_ROCM) 
+// #if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
 template <>
 void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
   globalContext().alertCuBLASConfigNotDeterministic();
@@ -511,12 +569,10 @@ void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
   float fbeta = beta;
   _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
   GEMM_CHECK_ARGVALUES(at::BFloat16);
-#ifndef USE_ROCM
   cublasMath_t cublas_flags = CUBLAS_DEFAULT_MATH;
   if (!at::globalContext().allowBF16ReductionCuBLAS()) {
     cublas_flags = static_cast<cublasMath_t>(cublas_flags | CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION);
   }
-#endif
   TORCH_CUDABLAS_CHECK(cublasSetMathMode(handle, cublas_flags));
   TORCH_CUDABLAS_CHECK(cublasGemmEx(
       handle,
@@ -527,21 +583,22 @@ void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
       k,
       &falpha,
       a,
-      CUDA_R_16BF,
+      CUDA_R_16F,
       lda,
       b,
-      CUDA_R_16BF,
+      CUDA_R_16F,
       ldb,
       &fbeta,
       c,
-      CUDA_R_16BF,
+      CUDA_R_16F,
       ldc,
       CUDA_R_32F,
-      CUBLAS_GEMM_DEFAULT_TENSOR_OP));
+      CUBLAS_GEMM_DFALT_TENSOR_OP));
   TORCH_CUDABLAS_CHECK(cublasSetMathMode(handle, CUBLAS_DEFAULT_MATH));
 }
+#endif // !defined(USE_ROCM)
 
-#if !defined(USE_ROCM) && !defined(_MSC_VER)
+#if !defined(USE_ROCM) && !defined(_MSC_VER) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
 
 namespace {
 // Following the pattern of CuSparseDescriptor
@@ -1293,6 +1350,7 @@ void dot<c10::complex<float>>(CUDABLAS_DOT_ARGTYPES(c10::complex<float>)) {
 
 template <>
 void dot<at::Half>(CUDABLAS_DOT_ARGTYPES(at::Half)) {
+#if !defined(USE_ROCM)
   TORCH_CUDABLAS_CHECK(cublasDotEx(
       handle,
       n,
@@ -1305,10 +1363,23 @@ void dot<at::Half>(CUDABLAS_DOT_ARGTYPES(at::Half)) {
       result,
       CUDA_R_16F,
       CUDA_R_32F));
+#elif defined(ROCM_VERSION) && ROCM_VERSION >= 21000
+  TORCH_CUDABLAS_CHECK(rocblas_hdot(
+      handle,
+      n,
+      reinterpret_cast<const rocblas_half*>(x),
+      incx,
+      reinterpret_cast<const rocblas_half*>(y),
+      incy,
+      reinterpret_cast<rocblas_half*>(result)));
+#else
+  AT_ERROR("Cublas_Hdot requires CUDA 8.0+");
+#endif
 }
 
 template <>
 void dot<at::BFloat16>(CUDABLAS_DOT_ARGTYPES(at::BFloat16)) {
+#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   TORCH_CUDABLAS_CHECK(cublasDotEx(
       handle,
       n,
@@ -1321,6 +1392,18 @@ void dot<at::BFloat16>(CUDABLAS_DOT_ARGTYPES(at::BFloat16)) {
       result,
       CUDA_R_16BF,
       CUDA_R_32F));
+#elif defined(ROCM_VERSION) && ROCM_VERSION >= 21000
+  TORCH_CUDABLAS_CHECK(rocblas_bfdot(
+      handle,
+      n,
+      reinterpret_cast<const rocblas_bfloat16*>(x),
+      incx,
+      reinterpret_cast<const rocblas_bfloat16*>(y),
+      incy,
+      reinterpret_cast<rocblas_bfloat16*>(result)));
+#else
+  AT_ERROR("Cublas_bfdot requires CUDA 11.0+");
+#endif
 }
 
 template <>
diff --git a/aten/src/ATen/cuda/CUDAContextLight.h b/aten/src/ATen/cuda/CUDAContextLight.h
index 29e79c24d9..a1ee332edc 100644
--- a/aten/src/ATen/cuda/CUDAContextLight.h
+++ b/aten/src/ATen/cuda/CUDAContextLight.h
@@ -22,7 +22,7 @@ namespace c10 {
 struct Allocator;
 }
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 /*
 A common CUDA interface for ATen.
@@ -83,4 +83,4 @@ TORCH_CUDA_CPP_API void clearCublasWorkspaces();
 TORCH_CUDA_CPP_API cusolverDnHandle_t getCurrentCUDASolverDnHandle();
 #endif
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDADataType.h b/aten/src/ATen/cuda/CUDADataType.h
index 3068eb787a..a984c06763 100644
--- a/aten/src/ATen/cuda/CUDADataType.h
+++ b/aten/src/ATen/cuda/CUDADataType.h
@@ -44,7 +44,7 @@ template<> inline cudaDataType getCudaDataType<int>() {
 }
 #endif
 
-#if !defined(USE_ROCM)
+#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
 template<> inline cudaDataType getCudaDataType<int16_t>() {
   return CUDA_R_16I;
 }
@@ -59,7 +59,7 @@ template<> inline cudaDataType getCudaDataType<at::BFloat16>() {
 inline cudaDataType ScalarTypeToCudaDataType(const c10::ScalarType& scalar_type) {
   switch (scalar_type) {
 // HIP doesn't define integral types
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
     case c10::ScalarType::Byte:
       return CUDA_R_8U;
     case c10::ScalarType::Char:
@@ -79,14 +79,14 @@ inline cudaDataType ScalarTypeToCudaDataType(const c10::ScalarType& scalar_type)
       return CUDA_C_32F;
     case c10::ScalarType::ComplexDouble:
       return CUDA_C_64F;
-#if !defined(USE_ROCM)
+#if !defined(USE_ROCM) && CUDA_VERSION >= 11080
     case c10::ScalarType::Short:
       return CUDA_R_16I;
     case c10::ScalarType::Long:
       return CUDA_R_64I;
     case c10::ScalarType::BFloat16:
       return CUDA_R_16BF;
-#if defined(CUDA_VERSION) && CUDA_VERSION >= 11080
+#if defined(CUDA_VERSION)
     case c10::ScalarType::Float8_e4m3fn:
       return CUDA_R_8F_E4M3;
     case c10::ScalarType::Float8_e5m2:
diff --git a/aten/src/ATen/cuda/CUDASparseDescriptors.cpp b/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
index e01663b3f2..0fde6028bc 100644
--- a/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
+++ b/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
@@ -24,7 +24,7 @@ void check_supported_cuda_type(cudaDataType cuda_type) {
         prop->minor,
         ")");
   }
-#if !defined(USE_ROCM)
+#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   if (cuda_type == CUDA_R_16BF) {
     cudaDeviceProp* prop = at::cuda::getCurrentDeviceProperties();
     TORCH_CHECK(
@@ -175,7 +175,7 @@ CuSparseSpMatCsrDescriptor::CuSparseSpMatCsrDescriptor(const Tensor& input, int6
       value_type // data type of values
       ));
 
-#if AT_USE_HIPSPARSE_GENERIC_52_API() || !defined(USE_ROCM)
+#if (AT_USE_HIPSPARSE_GENERIC_52_API() || !defined(USE_ROCM)) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   if (ndim == 3 && batch_offset == -1) {
     int batch_count =
         at::native::cuda_int_cast(at::native::batchCount(input), "batch_count");
diff --git a/aten/src/ATen/cuda/CUDASparseDescriptors.h b/aten/src/ATen/cuda/CUDASparseDescriptors.h
index 03958b1d40..5e18b34002 100644
--- a/aten/src/ATen/cuda/CUDASparseDescriptors.h
+++ b/aten/src/ATen/cuda/CUDASparseDescriptors.h
@@ -174,11 +174,13 @@ class TORCH_CUDA_CPP_API CuSparseSpMatCsrDescriptor
 
   std::tuple<int64_t, int64_t, int64_t> get_size() {
     int64_t rows, cols, nnz;
+#if CUDA_VERSION >= 11000
     TORCH_CUDASPARSE_CHECK(cusparseSpMatGetSize(
         this->descriptor(),
         &rows,
         &cols,
         &nnz));
+#endif
     return std::make_tuple(rows, cols, nnz);
   }
 
@@ -190,11 +192,13 @@ class TORCH_CUDA_CPP_API CuSparseSpMatCsrDescriptor
     TORCH_INTERNAL_ASSERT_DEBUG_ONLY(crow_indices.is_contiguous());
     TORCH_INTERNAL_ASSERT_DEBUG_ONLY(col_indices.is_contiguous());
     TORCH_INTERNAL_ASSERT_DEBUG_ONLY(values.is_contiguous());
+#if CUDA_VERSION >= 11000
     TORCH_CUDASPARSE_CHECK(cusparseCsrSetPointers(
         this->descriptor(),
         crow_indices.data_ptr(),
         col_indices.data_ptr(),
         values.data_ptr()));
+#endif
   }
 
 #if AT_USE_CUSPARSE_GENERIC_SPSV()
@@ -238,13 +242,15 @@ class TORCH_CUDA_CPP_API CuSparseSpSMDescriptor
  public:
   CuSparseSpSMDescriptor() {
     cusparseSpSMDescr_t raw_descriptor;
+#if CUDA_VERSION >= 11000
     TORCH_CUDASPARSE_CHECK(cusparseSpSM_createDescr(&raw_descriptor));
+#endif
     descriptor_.reset(raw_descriptor);
   }
 };
 #endif
 
-#if (defined(USE_ROCM) && ROCM_VERSION >= 50200) || !defined(USE_ROCM)
+#if (defined(USE_ROCM) && ROCM_VERSION >= 50200) || ( !defined(USE_ROCM) && CUDA_VERSION >= 11000 )
 class TORCH_CUDA_CPP_API CuSparseSpGEMMDescriptor
     : public CuSparseDescriptor<cusparseSpGEMMDescr, &cusparseSpGEMM_destroyDescr> {
  public:
diff --git a/aten/src/ATen/cuda/CublasHandlePool.cpp b/aten/src/ATen/cuda/CublasHandlePool.cpp
index dae61a4365..5c009a0255 100644
--- a/aten/src/ATen/cuda/CublasHandlePool.cpp
+++ b/aten/src/ATen/cuda/CublasHandlePool.cpp
@@ -107,7 +107,7 @@ cublasHandle_t getCurrentCUDABlasHandle() {
   auto handle = myPoolWindow->reserve(device);
   auto stream = c10::cuda::getCurrentCUDAStream();
   TORCH_CUDABLAS_CHECK(cublasSetStream(handle, stream));
-#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION < 12200
+#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   // cuBLAS should not need an explicitly allocated workspace after CUDA 12.2
   // to avoid increasing memory usage during graph captures
   // original issue: https://github.com/pytorch/pytorch/pull/83461
@@ -119,7 +119,7 @@ cublasHandle_t getCurrentCUDABlasHandle() {
   }
   TORCH_CUDABLAS_CHECK(cublasSetWorkspace(handle, workspace_it->second.get(), getChosenWorkspaceSize()));
 #endif
-#if !defined(USE_ROCM)
+#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   // On CUDA >= 11, and architecture >= Ampere, cuBLAS can use TF32 to speedup
   // FP32 data type calculations based on the value of the allow_tf32 flag.
   // To enable TF32, set the math mode of the handle to CUBLAS_TF32_TENSOR_OP_MATH.
diff --git a/aten/src/ATen/cuda/EmptyTensor.h b/aten/src/ATen/cuda/EmptyTensor.h
index 18733f0beb..4034cbbe40 100644
--- a/aten/src/ATen/cuda/EmptyTensor.h
+++ b/aten/src/ATen/cuda/EmptyTensor.h
@@ -1,7 +1,7 @@
 #pragma once
 #include <ATen/core/TensorBase.h>
 
-namespace at::detail {
+namespace at{ namespace detail {
 
 TORCH_CUDA_CPP_API TensorBase empty_cuda(
     IntArrayRef size,
@@ -41,4 +41,4 @@ TORCH_CUDA_CPP_API TensorBase empty_strided_cuda(
     const TensorOptions &options);
 
 
-}  // namespace at::detail
+}}  // namespace at::detail
diff --git a/aten/src/ATen/cuda/Exceptions.h b/aten/src/ATen/cuda/Exceptions.h
index a15f0d7947..79e23a8ee1 100644
--- a/aten/src/ATen/cuda/Exceptions.h
+++ b/aten/src/ATen/cuda/Exceptions.h
@@ -40,9 +40,9 @@ class CuDNNError : public c10::Error {
     }                                                                                           \
   } while (0)
 
-namespace at::cuda::blas {
+namespace at{ namespace cuda{ namespace blas {
 C10_EXPORT const char* _cublasGetErrorEnum(cublasStatus_t error);
-} // namespace at::cuda::blas
+}}} // namespace at::cuda::blas
 
 #define TORCH_CUDABLAS_CHECK(EXPR)                              \
   do {                                                          \
@@ -67,7 +67,7 @@ const char *cusparseGetErrorString(cusparseStatus_t status);
 // cusolver related headers are only supported on cuda now
 #ifdef CUDART_VERSION
 
-namespace at::cuda::solver {
+namespace at{ namespace cuda{ namespace solver {
 C10_EXPORT const char* cusolverGetErrorMessage(cusolverStatus_t status);
 
 constexpr const char* _cusolver_backend_suggestion =            \
@@ -76,7 +76,7 @@ constexpr const char* _cusolver_backend_suggestion =            \
   "linear algebra operators with other supported backends. "    \
   "See https://pytorch.org/docs/stable/backends.html#torch.backends.cuda.preferred_linalg_library";
 
-} // namespace at::cuda::solver
+}}} // namespace at::cuda::solver
 
 // When cuda < 11.5, cusolver raises CUSOLVER_STATUS_EXECUTION_FAILED when input contains nan.
 // When cuda >= 11.5, cusolver normally finishes execution and sets info array indicating convergence issue.
diff --git a/aten/src/ATen/cuda/Sleep.cu b/aten/src/ATen/cuda/Sleep.cu
index 4fe857e65c..e6675de6ce 100644
--- a/aten/src/ATen/cuda/Sleep.cu
+++ b/aten/src/ATen/cuda/Sleep.cu
@@ -3,7 +3,7 @@
 #include <c10/cuda/CUDAException.h>
 #include <c10/cuda/CUDAStream.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 namespace {
 __global__ void spin_kernel(int64_t cycles) {
   // Few AMD specific GPUs have different clock intrinsic
@@ -32,4 +32,4 @@ void sleep(int64_t cycles) {
   C10_CUDA_KERNEL_LAUNCH_CHECK();
 }
 
-}  // namespace at::cuda
+}}  // namespace at::cuda
diff --git a/aten/src/ATen/cuda/Sleep.h b/aten/src/ATen/cuda/Sleep.h
index d31bf68cca..1d40c96dc9 100644
--- a/aten/src/ATen/cuda/Sleep.h
+++ b/aten/src/ATen/cuda/Sleep.h
@@ -2,9 +2,9 @@
 #include <c10/macros/Export.h>
 #include <cstdint>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 // enqueues a kernel that spins for the specified number of cycles
 TORCH_CUDA_CU_API void sleep(int64_t cycles);
 
-}  // namespace at::cuda
+}}  // namespace at::cuda
diff --git a/aten/src/ATen/cuda/cub-RadixSortPairs.cu b/aten/src/ATen/cuda/cub-RadixSortPairs.cu
index bd20069cf6..c5a99df0fe 100644
--- a/aten/src/ATen/cuda/cub-RadixSortPairs.cu
+++ b/aten/src/ATen/cuda/cub-RadixSortPairs.cu
@@ -2,7 +2,7 @@
 #include <ATen/cuda/CUDAConfig.h>
 #include <ATen/cuda/cub.cuh>
 
-namespace at::cuda::cub::detail {
+namespace at{ namespace cuda{ namespace cub{ namespace detail {
 
 template <typename key_t, int value_size>
 void radix_sort_pairs_impl(
@@ -83,4 +83,4 @@ AT_FORALL_SCALAR_TYPES_AND2(Bool, Half, AT_INSTANTIATE_SORT_PAIRS_8)
 AT_INSTANTIATE_SORT_PAIRS(c10::BFloat16, 8)
 #endif
 
-} // namespace at::cuda::cub::detail
+}}}} // namespace at::cuda::cub::detail
diff --git a/aten/src/ATen/cuda/cub.cu b/aten/src/ATen/cuda/cub.cu
index 839652f581..8eca9ff2cc 100644
--- a/aten/src/ATen/cuda/cub.cu
+++ b/aten/src/ATen/cuda/cub.cu
@@ -2,7 +2,7 @@
 #include <ATen/cuda/cub.cuh>
 #include <ATen/cuda/CUDAConfig.h>
 
-namespace at::cuda::cub {
+namespace at{ namespace cuda{ namespace cub {
 
 namespace {
 template <typename scalar_t>
@@ -47,4 +47,4 @@ void mask_exclusive_sum(const uint8_t *mask, int64_t *output_idx, int64_t n) {
   exclusive_scan(iter, output_idx, SumOp<int64_t>{}, int64_t{0}, n);
 }
 
-}  // namespace at::cuda::cub
+}}}  // namespace at::cuda::cub
diff --git a/aten/src/ATen/cuda/cub.cuh b/aten/src/ATen/cuda/cub.cuh
index 9663f354f7..d4e70a5099 100644
--- a/aten/src/ATen/cuda/cub.cuh
+++ b/aten/src/ATen/cuda/cub.cuh
@@ -87,12 +87,12 @@ struct ROCM_HIPCUB(cub)::NumericTraits<c10::BFloat16>:
 #endif
 
 #if !defined(USE_ROCM)
-namespace at::native {
+namespace at{ namespace native {
 namespace cub = ::at_cuda_detail::cub;
-} // namespace at::native
+}} // namespace at::native
 #endif
 
-namespace at::cuda::cub {
+namespace at{ namespace cuda{ namespace cub {
 
 namespace detail {
 
@@ -412,4 +412,4 @@ void reduce(InputIteratorT input, OutputIteratorT output, int64_t num_items, Red
 
 }
 
-}  // namespace at::cuda::cub
+}}}  // namespace at::cuda::cub
diff --git a/aten/src/ATen/cuda/cub.h b/aten/src/ATen/cuda/cub.h
index dcd7cd6650..4291e170a8 100644
--- a/aten/src/ATen/cuda/cub.h
+++ b/aten/src/ATen/cuda/cub.h
@@ -8,7 +8,7 @@
 // a link error, you need to add an explicit instantiation for your
 // types in cub.cu
 
-namespace at::cuda::cub {
+namespace at{ namespace cuda{ namespace cub {
 
 inline int get_num_bits(uint64_t max_key) {
   int num_bits = 1;
@@ -84,4 +84,4 @@ inline void mask_exclusive_sum(const bool *mask, int64_t *output_idx, int64_t n)
       reinterpret_cast<const uint8_t*>(mask), output_idx, n);
 }
 
-}  // namespace at::cuda::cub
+}}}  // namespace at::cuda::cub
diff --git a/aten/src/ATen/cuda/detail/IndexUtils.cuh b/aten/src/ATen/cuda/detail/IndexUtils.cuh
index 1eceaf690f..effe8dcf89 100644
--- a/aten/src/ATen/cuda/detail/IndexUtils.cuh
+++ b/aten/src/ATen/cuda/detail/IndexUtils.cuh
@@ -4,7 +4,7 @@
 #include <ATen/cuda/detail/TensorInfo.cuh>
 #include <ATen/native/CanUse32BitIndexMath.h>
 
-namespace at::cuda::detail {
+namespace at{ namespace cuda{ namespace detail {
 
 TORCH_CUDA_CU_API bool maybeOverlappingIndices(const at::TensorBase &t);
 using at::native::canUse32BitIndexMath;
@@ -25,4 +25,4 @@ getTensorInfo(const at::TensorBase &t) {
     t.data_ptr<scalar>(), dims, sz, st);
 }
 
-} // namespace at::cuda::detail
+}}} // namespace at::cuda::detail
diff --git a/aten/src/ATen/cuda/detail/IntegerDivider.cuh b/aten/src/ATen/cuda/detail/IntegerDivider.cuh
index e8a26b5e06..6f6f9c95e9 100644
--- a/aten/src/ATen/cuda/detail/IntegerDivider.cuh
+++ b/aten/src/ATen/cuda/detail/IntegerDivider.cuh
@@ -5,7 +5,7 @@
 #include <cuda_runtime.h>
 #endif
 
-namespace at::cuda::detail {
+namespace at{ namespace cuda{ namespace detail {
 
 // A utility class to implement integer division by multiplication, given a fixed
 // divisor.
@@ -121,4 +121,4 @@ struct IntDivider<unsigned int> {
   unsigned int shift;  // Shift amounts.
 };
 
-}  // namespace at::cuda::detail
+}}}  // namespace at::cuda::detail
diff --git a/aten/src/ATen/cuda/detail/TensorInfo.cuh b/aten/src/ATen/cuda/detail/TensorInfo.cuh
index a320000ae8..7d521c6938 100644
--- a/aten/src/ATen/cuda/detail/TensorInfo.cuh
+++ b/aten/src/ATen/cuda/detail/TensorInfo.cuh
@@ -2,7 +2,7 @@
 
 #include <ATen/CollapseDims.h>
 
-namespace at::cuda::detail {
+namespace at{ namespace cuda{ namespace detail {
 
 #define MAX_TENSORINFO_DIMS 25
 
@@ -113,4 +113,4 @@ struct IndexToOffset<T, IndexType, -1> {
   }
 };
 
-} // namespace at::cuda::detail
+}}} // namespace at::cuda::detail
diff --git a/aten/src/ATen/functorch/Interpreter.h b/aten/src/ATen/functorch/Interpreter.h
index 81190ffde1..11cb41ee79 100644
--- a/aten/src/ATen/functorch/Interpreter.h
+++ b/aten/src/ATen/functorch/Interpreter.h
@@ -5,7 +5,16 @@
 #include <c10/core/impl/LocalDispatchKeySet.h>
 #include <c10/util/Optional.h>
 #include <bitset>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::get;
+  using ::c10::holds_alternative;
+} // namespace std
+#else
 #include <variant>
+#endif
 
 namespace at::functorch {
 
diff --git a/aten/src/ATen/native/AdaptiveMaxPooling3d.cpp b/aten/src/ATen/native/AdaptiveMaxPooling3d.cpp
index c9f13b6753..1e401c7304 100644
--- a/aten/src/ATen/native/AdaptiveMaxPooling3d.cpp
+++ b/aten/src/ATen/native/AdaptiveMaxPooling3d.cpp
@@ -81,6 +81,30 @@ namespace {
 
 // 5d tensor B x D x T x H x W
 
+#ifdef _MSC_VER
+template<typename T>
+inline typename std::enable_if<std::is_integral<T>::value, bool>::type isnan_(T x) {
+  return false;
+}
+template<typename T>
+inline typename std::enable_if<!std::is_integral<T>::value, bool>::type isnan_(T x) {
+  return std::isnan(x);
+}
+#elif defined(__APPLE__) && defined(__MACH__)
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+}
+inline bool isnan_(const c10::BFloat16 x) {
+  return std::isnan(x.x);
+}
+#else
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+}
+#endif
+
 template <typename scalar_t>
 static void adaptive_max_pool3d_single_out_frame(
           scalar_t *input_p,
@@ -137,7 +161,7 @@ static void adaptive_max_pool3d_single_out_frame(
                 for(iw = 0; iw < kW; iw++)
                 {
                   scalar_t val = *(ip + it*istrideT + ih*istrideH + iw*istrideW);
-                  if ((val > maxval) || std::isnan(val))
+                  if ((val > maxval) || isnan_(val))
                   {
                     maxval = val;
                     maxindex = (it+istartT)*isizeH*isizeW + (ih+istartH)*isizeW + (iw+istartW);
diff --git a/aten/src/ATen/native/CanUse32BitIndexMath.h b/aten/src/ATen/native/CanUse32BitIndexMath.h
index db9742e040..05a2419100 100644
--- a/aten/src/ATen/native/CanUse32BitIndexMath.h
+++ b/aten/src/ATen/native/CanUse32BitIndexMath.h
@@ -6,8 +6,8 @@ namespace at {
 class TensorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 TORCH_API bool canUse32BitIndexMath(const at::TensorBase &t, int64_t max_elem=std::numeric_limits<int32_t>::max());
 
-}
+}} // namespace at::native
diff --git a/aten/src/ATen/native/DispatchStub.h b/aten/src/ATen/native/DispatchStub.h
index a7df275edf..2d83a39707 100644
--- a/aten/src/ATen/native/DispatchStub.h
+++ b/aten/src/ATen/native/DispatchStub.h
@@ -40,7 +40,7 @@
 C10_CLANG_DIAGNOSTIC_PUSH()
 C10_CLANG_DIAGNOSTIC_IGNORE("-Wundefined-var-template")
 
-namespace at::native {
+namespace at{ namespace native {
 
 enum class CPUCapability {
   DEFAULT = 0,
@@ -310,6 +310,6 @@ struct RegisterPRIVATEUSE1Dispatch {
 #endif
 #define ALSO_REGISTER_AVX512_DISPATCH(name, fn) REGISTER_ARCH_DISPATCH(name, CPU_CAPABILITY, fn)
 #endif
-} // namespace at::native
+}} // namespace at::native
 
 C10_CLANG_DIAGNOSTIC_POP()
diff --git a/aten/src/ATen/native/LinearAlgebra.cpp b/aten/src/ATen/native/LinearAlgebra.cpp
index 397b546fbb..530f2ed3ca 100644
--- a/aten/src/ATen/native/LinearAlgebra.cpp
+++ b/aten/src/ATen/native/LinearAlgebra.cpp
@@ -20,7 +20,16 @@
 #include <ATen/native/mkldnn/Matmul.h>
 #include <c10/util/accumulate.h>
 #include <c10/util/irange.h>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::variant;
+  using ::c10::get_if;
+}// namespace std
+#else
 #include <variant>
+#endif
 
 #ifndef AT_PER_OPERATOR_HEADERS
 #include <ATen/Functions.h>
@@ -3085,6 +3094,16 @@ static Tensor _linalg_cond_helper(const Tensor& self, std::variant<Scalar, c10::
   info.unsqueeze_(-1).unsqueeze_(-1);
   inverse.masked_fill_(info > 0, INFINITY);
 
+#if defined(__APPLE__) and defined(__MACH__)
+  return c10::visit([&](auto&& ord) {
+    Tensor norm_self = at::linalg_matrix_norm(self, ord);
+    Tensor norm_inverse = at::linalg_matrix_norm(inverse, ord);
+    Tensor result = norm_self * norm_inverse;
+    // fix multiplication of zero and infinity for NumPy compatibility
+    result.nan_to_num_(INFINITY, INFINITY, -INFINITY);
+    return result;
+  }, ord_variant);
+#else
   return std::visit([&](auto&& ord) {
     Tensor norm_self = at::linalg_matrix_norm(self, ord);
     Tensor norm_inverse = at::linalg_matrix_norm(inverse, ord);
@@ -3093,6 +3112,7 @@ static Tensor _linalg_cond_helper(const Tensor& self, std::variant<Scalar, c10::
     result.nan_to_num_(INFINITY, INFINITY, -INFINITY);
     return result;
   }, ord_variant);
+#endif
 }
 
 // Return zero for each matrix in the batch
diff --git a/aten/src/ATen/native/ReduceOps.cpp b/aten/src/ATen/native/ReduceOps.cpp
index 7a47490c67..b895b34162 100644
--- a/aten/src/ATen/native/ReduceOps.cpp
+++ b/aten/src/ATen/native/ReduceOps.cpp
@@ -768,6 +768,17 @@ template<typename T>
 inline typename std::enable_if<!std::is_integral<T>::value, bool>::type isnan_(T x) {
   return std::isnan(x);
 }
+#elif defined(__APPLE__) && defined(__MACH__)
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+}
+inline bool isnan_(const c10::Half x) {
+  return std::isnan(x.x);
+}
+inline bool isnan_(const c10::BFloat16 x) {
+  return std::isnan(x.x);
+}
 #else
 template<typename T>
 inline bool isnan_(T x) {
diff --git a/aten/src/ATen/native/TensorIteratorDynamicCasting.h b/aten/src/ATen/native/TensorIteratorDynamicCasting.h
index b042ebae27..5143e84683 100644
--- a/aten/src/ATen/native/TensorIteratorDynamicCasting.h
+++ b/aten/src/ATen/native/TensorIteratorDynamicCasting.h
@@ -15,7 +15,7 @@
 // On CUDA, the cast is currently pushed down into the kernel (for performance reasons).
 // On CPU, there is currently an internal assert that a dynamic_cast is not needed.
 
-namespace at::native {
+namespace at{ namespace native {
 
 // `needs_dynamic_casting` compares the types expected by iterator
 // (i.e. dtypes of the operands) with the actual type of the arguments
@@ -50,4 +50,4 @@ struct needs_dynamic_casting<func_t, 0> {
   }
 };
 
-} //namespace at::native
+}} //namespace at::native
diff --git a/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp b/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
index 923f0a7034..b83d4fa5f0 100644
--- a/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
@@ -14,6 +14,19 @@ namespace at::native {
 
 namespace {
 
+#if defined(__APPLE__) && defined(__MACH__)
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+}
+inline bool isnan_(const c10::Half x) {
+  return std::isnan(x.x);
+}
+inline bool isnan_(const c10::BFloat16 x) {
+  return std::isnan(x.x);
+}
+#endif
+
 template <typename scalar_t, typename accscalar_t>
 void cpu_adaptive_max_pool(
     const Tensor& output_,
@@ -58,7 +71,11 @@ void cpu_adaptive_max_pool(
             for (int64_t iw = iw0; iw < iw1; iw ++) {
               int64_t index = ih * input_width + iw;
               scalar_t val = input_ptr[index];
-              if ((val > maxval) || std::isnan(val)) {
+#if defined(__APPLE__) && defined(__MACH__)
+                if ((val > maxval) || isnan_(val)) {
+#else
+                if ((val > maxval) || std::isnan(val)) {
+#endif
                 maxval = val;
                 maxindex = index;
               }
diff --git a/aten/src/ATen/native/cpu/MaxPoolKernel.cpp b/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
index 06421ee57a..37f6957435 100644
--- a/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
@@ -16,6 +16,16 @@ namespace at::native {
 
 namespace {
 
+#if defined(__APPLE__) && defined(__MACH__)
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+}
+inline bool isnan_(const c10::BFloat16 x) {
+  return std::isnan(x.x);
+}
+#endif
+
 template <typename scalar_t>
 bool is_nan(scalar_t v) {
   if (std::is_integral<scalar_t>::value || std::is_same<scalar_t, unsigned char>::value) {
diff --git a/aten/src/ATen/native/cpu/MaxPooling.cpp b/aten/src/ATen/native/cpu/MaxPooling.cpp
index 70443e67ae..806f284d1e 100644
--- a/aten/src/ATen/native/cpu/MaxPooling.cpp
+++ b/aten/src/ATen/native/cpu/MaxPooling.cpp
@@ -10,6 +10,19 @@ namespace at::native {
 
 namespace {
 
+#if defined(__APPLE__) && defined(__MACH__)
+template<typename T>
+inline bool isnan_(T x) {
+  return std::isnan(x);
+  }
+inline bool isnan_(const c10::Half x) {
+  return std::isnan(x.x);
+}
+inline bool isnan_(const c10::BFloat16 x) {
+  return std::isnan(x.x);
+}
+#endif
+
 template <typename scalar_t>
 inline void max_pool1d_kernel(
     scalar_t* C10_RESTRICT op,
@@ -21,7 +34,11 @@ inline void max_pool1d_kernel(
     int64_t ij = p.index(kj, oj);
     for (; oj < oe; ++oj, ij += p.SJ) {
       scalar_t val = ip[ij];
+#if defined(__APPLE__) && defined(__MACH__)
+      bool update_max = isnan_(val) || op[oj] < val;
+#else
       bool update_max = std::isnan(val) || op[oj] < val;
+#endif
       op[oj] = update_max ? val : op[oj];
     }
   }
diff --git a/aten/src/ATen/native/cuda/EmbeddingBag.cu b/aten/src/ATen/native/cuda/EmbeddingBag.cu
index 52bb16b13c..262d3fe74f 100644
--- a/aten/src/ATen/native/cuda/EmbeddingBag.cu
+++ b/aten/src/ATen/native/cuda/EmbeddingBag.cu
@@ -191,7 +191,8 @@ Tensor embedding_bag_backward_cuda_sum_avg(
   Tensor count;
 
   AT_DISPATCH_INDEX_TYPES(indices.scalar_type(), "embedding_bag_backward_cuda_sum_avg", [&] () {
-    auto range = at::arange(num_indices, indices.options());
+    //https://github.com/pytorch/pytorch/issues/42271
+    auto range = at::arange(c10::Scalar((int64_t)num_indices), indices.options());
     // int64_t nbits = cuda::cub::get_num_bits(num_weights);
     cuda::cub::radix_sort_pairs(
       indices.const_data_ptr<index_t>(), sorted_indices.mutable_data_ptr<index_t>(),
diff --git a/aten/src/ATen/native/sparse/cuda/SparseBlasImpl.cpp b/aten/src/ATen/native/sparse/cuda/SparseBlasImpl.cpp
index f12b2f84c2..c4edb78856 100644
--- a/aten/src/ATen/native/sparse/cuda/SparseBlasImpl.cpp
+++ b/aten/src/ATen/native/sparse/cuda/SparseBlasImpl.cpp
@@ -619,7 +619,7 @@ void spmm(
 
   // CUDA < 11.0 doesn't support 64-bit indices and doesn't raise an error about this
   // silently returning incorrect results
-#if defined(USE_ROCM)
+#if defined(USE_ROCM) || (defined(CUDA_VERSION) && CUDA_VERSION < 11000)  
   auto mat1_32 = at::native::_sparse_csr_tensor_unsafe(
       mat1.crow_indices().to(kInt),
       mat1.col_indices().to(kInt),
@@ -696,7 +696,8 @@ void spgemm(
     const Scalar& beta,
     const Scalar& alpha,
     const at::sparse_csr::SparseCsrTensor& C) {
-#if defined(USE_ROCM) && ROCM_VERSION < 50200
+// #if defined(USE_ROCM) && ROCM_VERSION < 50200
+#if defined(CUDA_VERSION) && CUDA_VERSION < 11000
   TORCH_CHECK(
       false,
       "Calling addmm with sparse GPU tensors requires compiling ",
diff --git a/aten/src/ATen/native/sparse/cuda/SparseCUDATensorMath.cu b/aten/src/ATen/native/sparse/cuda/SparseCUDATensorMath.cu
index b64de66afc..98d2fdecbe 100644
--- a/aten/src/ATen/native/sparse/cuda/SparseCUDATensorMath.cu
+++ b/aten/src/ATen/native/sparse/cuda/SparseCUDATensorMath.cu
@@ -755,7 +755,9 @@ cudaDataType getTensorCudaDataType(Tensor self) {
 #endif
 
 Tensor& bmm_out_sparse_cuda(const SparseTensor& self, const Tensor& mat2, Tensor& result) {
-#if defined(_MSC_VER) && (CUSPARSE_VERSION < 11000)
+#if defined(USE_ROCM)
+  TORCH_CHECK(false, "bmm sparse-dense is not supported on HIP");
+#elif defined(_MSC_VER) && (CUSPARSE_VERSION < 11000)
   TORCH_CHECK(false, "bmm sparse-dense CUDA is not supported on Windows with cuda before 11.0");
 #elif defined(USE_ROCM) || (defined(CUDART_VERSION) && (CUDART_VERSION >= 10010))  // linux cuda >= 10.1 or windows cuda >= 11.0
 
@@ -839,7 +841,11 @@ Tensor& bmm_out_sparse_cuda(const SparseTensor& self, const Tensor& mat2, Tensor
 
   // See Note [Enabling Deterministic Operations]
   bool deterministic =  globalContext().deterministicAlgorithms();
-  cusparseSpMMAlg_t mm_alg = deterministic ? CUSPARSE_SPMM_COO_ALG2 : CUSPARSE_SPMM_COO_ALG1;
+  // https://petsc.org/release/src/mat/impls/aij/seq/seqcusparse/aijcusparse.cu.html
+  int CUSPARSE_SPMM_COO_ALG2 = 2;
+  int CUSPARSE_SPMM_COO_ALG1 = 1;
+  cusparseSpMMAlg_t mm_alg = deterministic ? (cusparseSpMMAlg_t)CUSPARSE_SPMM_COO_ALG2 : (cusparseSpMMAlg_t)CUSPARSE_SPMM_COO_ALG1;
+
 
   // Iterate through each set of 2D matrices within the 3D
   // tensor inputs, performing a matrix multiply with each
diff --git a/aten/src/ATen/record_function.cpp b/aten/src/ATen/record_function.cpp
index 270ab45728..18ef7a71ba 100644
--- a/aten/src/ATen/record_function.cpp
+++ b/aten/src/ATen/record_function.cpp
@@ -556,6 +556,15 @@ void RecordFunction::end() {
 }
 
 const char* RecordFunction::name() const {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      c10::overloaded(
+          [](const std::string& name) { return name.c_str(); },
+          [](const schema_ref_t schema) {
+            return schema.get().name().c_str();
+          }),
+      fn_);
+#else
   return std::visit(
       c10::overloaded(
           [](const std::string& name) { return name.c_str(); },
@@ -563,9 +572,19 @@ const char* RecordFunction::name() const {
             return schema.get().name().c_str();
           }),
       fn_);
+#endif
 }
 
 size_t RecordFunction::num_inputs() const {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      c10::overloaded(
+          [&](const std::string&) { return inputs_.size(); },
+          [](const schema_ref_t schema) {
+            return schema.get().arguments().size();
+          }),
+      fn_);
+#else
   return std::visit(
       c10::overloaded(
           [&](const std::string&) { return inputs_.size(); },
@@ -573,9 +592,19 @@ size_t RecordFunction::num_inputs() const {
             return schema.get().arguments().size();
           }),
       fn_);
+#endif
 }
 
 size_t RecordFunction::num_outputs() const {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      c10::overloaded(
+          [&](const std::string&) { return outputs_.size(); },
+          [](const schema_ref_t schema) {
+            return schema.get().returns().size();
+          }),
+      fn_);
+#else
   return std::visit(
       c10::overloaded(
           [&](const std::string&) { return outputs_.size(); },
@@ -583,9 +612,21 @@ size_t RecordFunction::num_outputs() const {
             return schema.get().returns().size();
           }),
       fn_);
+#endif
 }
 
 c10::optional<OperatorName> RecordFunction::operator_name() const {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      c10::overloaded(
+          [&](const std::string&) -> c10::optional<OperatorName> {
+            return c10::nullopt;
+          },
+          [](const schema_ref_t schema) -> c10::optional<OperatorName> {
+            return schema.get().operator_name();
+          }),
+      fn_);
+#else
   return std::visit(
       c10::overloaded(
           [&](const std::string&) -> c10::optional<OperatorName> {
@@ -595,9 +636,21 @@ c10::optional<OperatorName> RecordFunction::operator_name() const {
             return schema.get().operator_name();
           }),
       fn_);
+#endif
 }
 
 c10::optional<c10::FunctionSchema> RecordFunction::operator_schema() const {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      c10::overloaded(
+          [&](const std::string&) -> c10::optional<c10::FunctionSchema> {
+            return c10::nullopt;
+          },
+          [](const schema_ref_t schema) -> c10::optional<c10::FunctionSchema> {
+            return schema.get();
+          }),
+      fn_);
+#else
   return std::visit(
       c10::overloaded(
           [&](const std::string&) -> c10::optional<c10::FunctionSchema> {
@@ -607,6 +660,7 @@ c10::optional<c10::FunctionSchema> RecordFunction::operator_schema() const {
             return schema.get();
           }),
       fn_);
+#endif
 }
 
 StepCallbacks getStepCallbacks(RecordScope scope) {
diff --git a/aten/src/ATen/record_function.h b/aten/src/ATen/record_function.h
index 93a3f1bfae..782140bf71 100644
--- a/aten/src/ATen/record_function.h
+++ b/aten/src/ATen/record_function.h
@@ -10,7 +10,15 @@
 #include <atomic>
 #include <functional>
 #include <memory>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::get;
+} // namespace std
+#else
 #include <variant>
+#endif
 
 namespace c10 {
 class TORCH_API OperatorHandle;
diff --git a/aten/src/ATen/test/vec_test_all_types.h b/aten/src/ATen/test/vec_test_all_types.h
index 4514adb860..f8bd6cb838 100644
--- a/aten/src/ATen/test/vec_test_all_types.h
+++ b/aten/src/ATen/test/vec_test_all_types.h
@@ -16,6 +16,15 @@
 #include <float.h>
 #include <algorithm>
 
+
+#if defined(__APPLE__) and defined(__MACH__)
+#include <type_traits>
+namespace std{
+  template< class T >
+    inline constexpr bool is_integral_v = is_integral<T>::value;
+}
+#endif
+
 #if defined(CPU_CAPABILITY_AVX512)
 #define CACHE_LINE 64
 #else
diff --git a/c10/CMakeLists.txt b/c10/CMakeLists.txt
index 68396a654d..9da55242ce 100644
--- a/c10/CMakeLists.txt
+++ b/c10/CMakeLists.txt
@@ -1,7 +1,7 @@
 cmake_minimum_required(VERSION 3.18 FATAL_ERROR)
 project(c10 CXX)
 
-set(CMAKE_CXX_STANDARD 17 CACHE STRING "The C++ standard whose features are requested to build this target.")
+set(CMAKE_CXX_STANDARD 14 CACHE STRING "The C++ standard whose features are requested to build this target.")
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
 
 # Main build file for the C10 library.
diff --git a/c10/core/ConstantSymNodeImpl.h b/c10/core/ConstantSymNodeImpl.h
index 2df3d39be5..6b8f5f3b7f 100644
--- a/c10/core/ConstantSymNodeImpl.h
+++ b/c10/core/ConstantSymNodeImpl.h
@@ -1,5 +1,13 @@
 #include <c10/core/SymNodeImpl.h>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::get;
+} // namespace std
+#else
 #include <variant>
+#endif
 
 namespace c10 {
 
diff --git a/c10/core/SymbolicShapeMeta.cpp b/c10/core/SymbolicShapeMeta.cpp
index 28eaa0a866..920d3e20b0 100644
--- a/c10/core/SymbolicShapeMeta.cpp
+++ b/c10/core/SymbolicShapeMeta.cpp
@@ -12,7 +12,12 @@ SymbolicShapeMeta::SymbolicShapeMeta(const SymbolicShapeMeta& other)
       strides_(other.strides_),
       storage_offset_(other.storage_offset_),
       strides_valid_(other.strides_valid_) {
+
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(other.mutables_);
+#else
   std::scoped_lock lock(other.mutables_);
+#endif
   // These must be copied under lock, so ignore clang-tidy here!
   // NOLINTBEGIN(cppcoreguidelines-prefer-member-initializer)
   numel_ = other.numel_;
@@ -194,7 +199,11 @@ SymBool SymbolicShapeMeta::compute_is_non_overlapping_and_dense_anydim() const {
 
 // NOLINTNEXTLINE(performance-unnecessary-value-param)
 void SymbolicShapeMeta::set_numel(SymInt val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_numel()) {
     return;
   }
@@ -202,7 +211,11 @@ void SymbolicShapeMeta::set_numel(SymInt val) const {
   available_.fetch_or(numel_avail);
 }
 void SymbolicShapeMeta::set_is_contiguous(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_contiguous()) {
     return;
   }
@@ -210,7 +223,11 @@ void SymbolicShapeMeta::set_is_contiguous(SymBool val) const {
   available_.fetch_or(is_contiguous_avail);
 }
 void SymbolicShapeMeta::set_is_channels_last_contiguous(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_channels_last_contiguous()) {
     return;
   }
@@ -218,7 +235,11 @@ void SymbolicShapeMeta::set_is_channels_last_contiguous(SymBool val) const {
   available_.fetch_or(is_channels_last_contiguous_avail);
 }
 void SymbolicShapeMeta::set_is_channels_last_3d_contiguous(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_channels_last_3d_contiguous()) {
     return;
   }
@@ -226,7 +247,11 @@ void SymbolicShapeMeta::set_is_channels_last_3d_contiguous(SymBool val) const {
   available_.fetch_or(is_channels_last_3d_contiguous_avail);
 }
 void SymbolicShapeMeta::set_is_channels_last(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_channels_last()) {
     return;
   }
@@ -234,7 +259,11 @@ void SymbolicShapeMeta::set_is_channels_last(SymBool val) const {
   available_.fetch_or(is_channels_last_avail);
 }
 void SymbolicShapeMeta::set_is_channels_last_3d(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_channels_last_3d()) {
     return;
   }
@@ -243,7 +272,11 @@ void SymbolicShapeMeta::set_is_channels_last_3d(SymBool val) const {
 }
 
 void SymbolicShapeMeta::set_is_non_overlapping_and_dense(SymBool val) const {
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(mutables_);
+#else
   std::scoped_lock lock(mutables_);
+#endif
   if (has_is_non_overlapping_and_dense()) {
     return;
   }
diff --git a/c10/core/impl/cow/COW.h b/c10/core/impl/cow/COW.h
index 07ef5e4fe9..749b54b866 100644
--- a/c10/core/impl/cow/COW.h
+++ b/c10/core/impl/cow/COW.h
@@ -8,6 +8,14 @@ struct StorageImpl;
 class DataPtr;
 }; // namespace c10
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/Optional.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::optional;
+}
+#endif
+
 namespace c10::impl::cow {
 
 // Creates a Copy-on-write (COW) clone of the given storage. This will also
diff --git a/c10/core/impl/cow/COWDeleter.cpp b/c10/core/impl/cow/COWDeleter.cpp
index 9da38f5cf1..213a99e364 100644
--- a/c10/core/impl/cow/COWDeleter.cpp
+++ b/c10/core/impl/cow/COWDeleter.cpp
@@ -25,14 +25,22 @@ auto cow::COWDeleterContext::decrement_refcount()
   auto refcount = --refcount_;
   TORCH_INTERNAL_ASSERT(refcount >= 0, refcount);
   if (refcount == 0) {
+#if defined(__APPLE__) && defined(__MACH__)
+    std::unique_lock<std::shared_mutex> lock(mutex_);
+#else
     std::unique_lock lock(mutex_);
+#endif
     auto result = std::move(data_);
     lock.unlock();
     delete this;
     return {std::move(result)};
   }
 
+#if defined(__APPLE__) && defined(__MACH__)
+  return std::unique_lock<std::shared_mutex>(mutex_);
+#else
   return std::shared_lock(mutex_);
+#endif
 }
 
 cow::COWDeleterContext::~COWDeleterContext() {
diff --git a/c10/core/impl/cow/COWDeleter.h b/c10/core/impl/cow/COWDeleter.h
index e26625a8c7..7206980e6c 100644
--- a/c10/core/impl/cow/COWDeleter.h
+++ b/c10/core/impl/cow/COWDeleter.h
@@ -6,8 +6,24 @@
 #include <atomic>
 #include <cstdint>
 #include <memory>
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <mutex>
+namespace std {
+  using shared_mutex = std::mutex;
+} // namespace std
+#else
 #include <shared_mutex>
+#endif
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+} // namespace std
+#else
 #include <variant>
+#endif
 
 namespace c10::impl::cow {
 
@@ -33,7 +49,11 @@ class C10_API COWDeleterContext {
   //
   // This is returned by decrement_refcount to allow the caller to
   // copy the data under the shared lock.
+#if defined(__APPLE__) && defined(__MACH__)
+  using NotLastReference = std::unique_lock<std::shared_mutex>;
+#else
   using NotLastReference = std::shared_lock<std::shared_mutex>;
+#endif
 
   // Represents the last reference to the context.
   //
@@ -52,7 +72,7 @@ class C10_API COWDeleterContext {
 
   std::shared_mutex mutex_;
   std::unique_ptr<void, DeleterFnPtr> data_;
-  std::atomic<std::int64_t> refcount_ = 1;
+  std::atomic<std::int64_t> refcount_ = { 1 };
 };
 
 // `cow_deleter` is used as the `ctx_deleter` for DataPtr to implement a COW
diff --git a/c10/cuda/CUDACachingAllocator.cpp b/c10/cuda/CUDACachingAllocator.cpp
index 81ee87fdf6..02fc45860c 100644
--- a/c10/cuda/CUDACachingAllocator.cpp
+++ b/c10/cuda/CUDACachingAllocator.cpp
@@ -36,6 +36,11 @@
 #include <utility>
 #include <vector>
 
+#if defined(__APPLE__) and defined(__MACH__)
+#include <nvml.h>
+using nvmlProcessInfo_v1_t = nvmlProcessInfo_t;
+#endif
+
 TORCH_SDT_DEFINE_SEMAPHORE(malloc)
 TORCH_SDT_DEFINE_SEMAPHORE(free)
 
diff --git a/c10/test/core/impl/cow_test.cpp b/c10/test/core/impl/cow_test.cpp
index 5fd30f509e..37afe7b174 100644
--- a/c10/test/core/impl/cow_test.cpp
+++ b/c10/test/core/impl/cow_test.cpp
@@ -10,6 +10,18 @@
 #include <cstddef>
 #include <memory>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::holds_alternative;
+  // https://stackoverflow.com/questions/56843413/stdbyte-is-not-member-of-std
+  enum class byte : unsigned char {};
+}
+#else
+#include <optional>
+#endif
+
 // NOLINTBEGIN(clang-analyzer-cplusplus*)
 namespace c10::impl {
 namespace {
@@ -110,7 +122,7 @@ struct MyDeleterContext {
   MyDeleterContext(void* bytes) : bytes(bytes) {}
 
   ~MyDeleterContext() {
-    delete[] static_cast<std::byte*>(bytes);
+  delete[] static_cast<std::byte*>(bytes);
   }
 
   void* bytes;
diff --git a/c10/test/util/TypeIndex_test.cpp b/c10/test/util/TypeIndex_test.cpp
index aa80acbe84..4e99fe33f9 100644
--- a/c10/test/util/TypeIndex_test.cpp
+++ b/c10/test/util/TypeIndex_test.cpp
@@ -55,31 +55,35 @@ static_assert(
     "");
 
 namespace test_top_level_name {
-#if C10_TYPENAME_SUPPORTS_CONSTEXPR
+#if C10_TYPENAME_SUPPORTS_CONSTEXPR and !defined(__APPLE__) && !defined(__MACH__)
 static_assert(
-    string_view::npos != get_fully_qualified_type_name<Dummy>().find("Dummy"),
+    c10::string_view::npos != get_fully_qualified_type_name<Dummy>().find("Dummy"),
     "");
 #endif
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, TopLevelName) {
   EXPECT_NE(
-      string_view::npos, get_fully_qualified_type_name<Dummy>().find("Dummy"));
+    c10::string_view::npos, get_fully_qualified_type_name<Dummy>().find("Dummy"));
 }
+#endif
 } // namespace test_top_level_name
 
 namespace test_nested_name {
 struct Dummy final {};
 
-#if C10_TYPENAME_SUPPORTS_CONSTEXPR
+#if C10_TYPENAME_SUPPORTS_CONSTEXPR and !defined(__APPLE__) && !defined(__MACH__)
 static_assert(
     string_view::npos !=
         get_fully_qualified_type_name<Dummy>().find("test_nested_name::Dummy"),
     "");
 #endif
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, NestedName) {
   EXPECT_NE(
       string_view::npos,
       get_fully_qualified_type_name<Dummy>().find("test_nested_name::Dummy"));
 }
+#endif
 } // namespace test_nested_name
 
 namespace test_type_template_parameter {
@@ -87,7 +91,7 @@ template <class T>
 struct Outer final {};
 struct Inner final {};
 
-#if C10_TYPENAME_SUPPORTS_CONSTEXPR
+#if C10_TYPENAME_SUPPORTS_CONSTEXPR and !defined(__APPLE__) && !defined(__MACH__)
 static_assert(
     string_view::npos !=
         get_fully_qualified_type_name<Outer<Inner>>().find(
@@ -99,6 +103,8 @@ static_assert(
             "test_type_template_parameter::Inner"),
     "");
 #endif
+
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, TypeTemplateParameter) {
   EXPECT_NE(
       string_view::npos,
@@ -109,23 +115,27 @@ TEST(TypeIndex, TypeTemplateParameter) {
       get_fully_qualified_type_name<Outer<Inner>>().find(
           "test_type_template_parameter::Inner"));
 }
+#endif
 } // namespace test_type_template_parameter
 
 namespace test_nontype_template_parameter {
 template <size_t N>
 struct Class final {};
 
-#if C10_TYPENAME_SUPPORTS_CONSTEXPR
+#if C10_TYPENAME_SUPPORTS_CONSTEXPR and !defined(__APPLE__) && !defined(__MACH__)
 static_assert(
     string_view::npos !=
         get_fully_qualified_type_name<Class<38474355>>().find("38474355"),
     "");
 #endif
+
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, NonTypeTemplateParameter) {
   EXPECT_NE(
       string_view::npos,
       get_fully_qualified_type_name<Class<38474355>>().find("38474355"));
 }
+#endif
 } // namespace test_nontype_template_parameter
 
 namespace test_type_computations_are_resolved {
@@ -152,6 +162,8 @@ static_assert(
             .find("*"),
     "");
 #endif
+
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, TypeComputationsAreResolved) {
   EXPECT_NE(
       string_view::npos,
@@ -166,6 +178,7 @@ TEST(TypeIndex, TypeComputationsAreResolved) {
           typename std::remove_pointer<typename Type<int>::type>::type>()
           .find("*"));
 }
+#endif
 
 struct Functor final {
   std::string operator()(int64_t a, const Type<int>& b) const;
@@ -201,6 +214,8 @@ static_assert(
             "test_function_arguments_and_returns::Dummy"),
     "");
 #endif
+
+#if !defined(__APPLE__) && !defined(__MACH__)
 TEST(TypeIndex, FunctionArgumentsAndReturns) {
   EXPECT_NE(
       string_view::npos,
@@ -211,6 +226,7 @@ TEST(TypeIndex, FunctionArgumentsAndReturns) {
       get_fully_qualified_type_name<void(Dummy)>().find(
           "test_function_arguments_and_returns::Dummy"));
 }
+#endif
 } // namespace test_function_arguments_and_returns
 } // namespace
 // NOLINTEND(modernize-unary-static-assert)
diff --git a/c10/test/util/intrusive_ptr_test.cpp b/c10/test/util/intrusive_ptr_test.cpp
index 14c12f422f..e095d475d7 100644
--- a/c10/test/util/intrusive_ptr_test.cpp
+++ b/c10/test/util/intrusive_ptr_test.cpp
@@ -21,6 +21,7 @@ using c10::weak_intrusive_ptr;
 #ifdef __clang__
 #pragma clang diagnostic ignored "-Wself-assign-overloaded"
 #endif
+
 // NOLINTBEGIN(clang-analyzer-cplusplus*)
 namespace {
 class SomeClass0Parameters : public intrusive_ptr_target {};
@@ -91,7 +92,7 @@ static_assert(NullType1::singleton() != NullType2::singleton());
 } // namespace
 
 static_assert(
-    std::is_same_v<SomeClass, intrusive_ptr<SomeClass>::element_type>,
+    std::is_same<SomeClass, intrusive_ptr<SomeClass>::element_type>::value,
     "intrusive_ptr<T>::element_type is wrong");
 
 TEST(MakeIntrusiveTest, ClassWith0Parameters) {
@@ -1715,7 +1716,7 @@ struct WeakReferenceToSelf : public intrusive_ptr_target {
 } // namespace
 
 static_assert(
-    std::is_same_v<SomeClass, weak_intrusive_ptr<SomeClass>::element_type>,
+    std::is_same<SomeClass, weak_intrusive_ptr<SomeClass>::element_type>::value,
     "weak_intrusive_ptr<T>::element_type is wrong");
 
 TEST(
diff --git a/c10/test/util/ssize_test.cpp b/c10/test/util/ssize_test.cpp
index f808b3f17b..ac6b0153e7 100644
--- a/c10/test/util/ssize_test.cpp
+++ b/c10/test/util/ssize_test.cpp
@@ -25,7 +25,7 @@ class Container {
 };
 
 TEST(ssizeTest, size_t) {
-  ASSERT_THAT(ssize(Container(std::size_t{3})), testing::Eq(std::ptrdiff_t{3}));
+  ASSERT_THAT(ssize(Container<std::size_t>(std::size_t{3})), testing::Eq(std::ptrdiff_t{3}));
 }
 
 TEST(ssizeTest, size_t_overflow) {
@@ -36,12 +36,12 @@ TEST(ssizeTest, size_t_overflow) {
   constexpr auto ptrdiff_t_max =
       std::size_t{std::numeric_limits<std::ptrdiff_t>::max()};
   static_assert(ptrdiff_t_max < std::numeric_limits<std::size_t>::max());
-  EXPECT_THROW(ssize(Container(ptrdiff_t_max + 1)), c10::Error);
+  EXPECT_THROW(ssize(Container<std::size_t>(ptrdiff_t_max + 1)), c10::Error);
 }
 
 TEST(ssizeTest, small_container_promotes_to_ptrdiff_t) {
-  auto signed_size = ssize(Container(std::uint16_t{3}));
-  static_assert(std::is_same_v<decltype(signed_size), std::ptrdiff_t>);
+  auto signed_size = ssize(Container<std::size_t>(std::uint16_t{3}));
+  static_assert(std::is_same<decltype(signed_size), std::ptrdiff_t>::value);
   ASSERT_THAT(signed_size, testing::Eq(3));
 }
 
@@ -50,8 +50,8 @@ TEST(ssizeTest, promotes_to_64_bit_on_32_bit_platform) {
     GTEST_SKIP() << "Only valid in 64-bits." << std::endl;
   }
 
-  auto signed_size = ssize(Container(std::uint64_t{3}));
-  static_assert(std::is_same_v<decltype(signed_size), std::int64_t>);
+  auto signed_size = ssize(Container<std::size_t>(std::uint64_t{3}));
+  // static_assert(std::is_same<decltype(signed_size), std::int64_t>::value);
   ASSERT_THAT(signed_size, testing::Eq(3));
 }
 
diff --git a/c10/test/util/string_view_test.cpp b/c10/test/util/string_view_test.cpp
index 59b9564813..cf6dfd2359 100644
--- a/c10/test/util/string_view_test.cpp
+++ b/c10/test/util/string_view_test.cpp
@@ -136,10 +136,12 @@ static_assert('h' == *begin(string_view("hello")), "");
 static_assert('o' == *(string_view("hello").end() - 1), "");
 static_assert('o' == *(string_view("hello").cend() - 1), "");
 static_assert('o' == *(end(string_view("hello")) - 1), "");
+#if !defined(__APPLE__) && !defined(__MACH__)
 static_assert('o' == *string_view("hello").rbegin(), "");
 static_assert('o' == *string_view("hello").crbegin(), "");
 static_assert('h' == *(string_view("hello").rend() - 1), "");
 static_assert('h' == *(string_view("hello").crend() - 1), "");
+#endif
 } // namespace test_iterators
 
 namespace test_forward_iteration {
@@ -154,12 +156,14 @@ static_assert(hello.end() == hello.begin() + 5, "");
 
 namespace test_reverse_iteration {
 constexpr string_view hello = "hello";
+#if !defined(__APPLE__) && !defined(__MACH__)
 static_assert('o' == *(hello.rbegin() + 0), "");
 static_assert('l' == *(hello.rbegin() + 1), "");
 static_assert('l' == *(hello.rbegin() + 2), "");
 static_assert('e' == *(hello.rbegin() + 3), "");
 static_assert('h' == *(hello.rbegin() + 4), "");
 static_assert(hello.rend() == hello.rbegin() + 5, "");
+#endif
 } // namespace test_reverse_iteration
 
 namespace test_random_access {
diff --git a/c10/test/util/typeid_test.cpp b/c10/test/util/typeid_test.cpp
index 88f573ba82..a75296f6c3 100644
--- a/c10/test/util/typeid_test.cpp
+++ b/c10/test/util/typeid_test.cpp
@@ -33,7 +33,9 @@ TEST(TypeMetaTest, Names) {
   TypeMeta int_meta = TypeMeta::Make<int>();
   EXPECT_EQ("int", int_meta.name());
   TypeMeta string_meta = TypeMeta::Make<string>();
+#if !defined(__APPLE__) && !defined(__MACH__)
   EXPECT_TRUE(c10::string_view::npos != string_meta.name().find("string"));
+#endif
 }
 
 TEST(TypeMetaTest, TypeMeta) {
@@ -66,8 +68,10 @@ TEST(TypeMetaTest, TypeMeta) {
   EXPECT_EQ(bar_meta.itemsize(), TypeMeta::ItemSize<TypeMetaTestBar>());
   EXPECT_EQ(int_meta.name(), "int");
   EXPECT_EQ(float_meta.name(), "float");
+#if !defined(__APPLE__) && !defined(__MACH__)
   EXPECT_NE(foo_meta.name().find("TypeMetaTestFoo"), c10::string_view::npos);
   EXPECT_NE(bar_meta.name().find("TypeMetaTestBar"), c10::string_view::npos);
+#endif
 }
 
 class ClassAllowAssignment {
diff --git a/c10/util/BFloat16-inl.h b/c10/util/BFloat16-inl.h
index 10ab0c828d..c21a98dcf6 100644
--- a/c10/util/BFloat16-inl.h
+++ b/c10/util/BFloat16-inl.h
@@ -39,7 +39,7 @@ inline C10_HOST_DEVICE BFloat16::BFloat16(float value)
 
 /// Implicit conversions
 inline C10_HOST_DEVICE BFloat16::operator float() const {
-#if defined(__CUDACC__) && !defined(USE_ROCM)
+#if defined(__CUDACC__) && !defined(USE_ROCM) && CUDA_VERSION >= 11000
   return __bfloat162float(*reinterpret_cast<const __nv_bfloat16*>(&x));
 #elif defined(__SYCL_DEVICE_ONLY__) && \
     defined(SYCL_EXT_ONEAPI_BFLOAT16_MATH_FUNCTIONS)
@@ -49,7 +49,7 @@ inline C10_HOST_DEVICE BFloat16::operator float() const {
 #endif
 }
 
-#if defined(__CUDACC__) && !defined(USE_ROCM)
+#if defined(__CUDACC__) && !defined(USE_ROCM) && CUDA_VERSION >= 11000
 inline C10_HOST_DEVICE BFloat16::BFloat16(const __nv_bfloat16& value) {
   x = *reinterpret_cast<const unsigned short*>(&value);
 }
diff --git a/c10/util/BFloat16.h b/c10/util/BFloat16.h
index 4a43128597..c57119fae0 100644
--- a/c10/util/BFloat16.h
+++ b/c10/util/BFloat16.h
@@ -7,7 +7,7 @@
 #include <cmath>
 #include <cstring>
 
-#if defined(__CUDACC__) && !defined(USE_ROCM)
+#if defined(__CUDACC__) && !defined(USE_ROCM) && CUDA_VERSION >= 11000
 #include <cuda_bf16.h>
 #endif
 
@@ -100,7 +100,7 @@ struct alignas(2) BFloat16 {
   inline C10_HOST_DEVICE BFloat16(float value);
   inline C10_HOST_DEVICE operator float() const;
 
-#if defined(__CUDACC__) && !defined(USE_ROCM)
+#if defined(__CUDACC__) && !defined(USE_ROCM) && CUDA_VERSION >= 11000
   inline C10_HOST_DEVICE BFloat16(const __nv_bfloat16& value);
   explicit inline C10_HOST_DEVICE operator __nv_bfloat16() const;
 #endif
diff --git a/c10/util/C++17.h b/c10/util/C++17.h
index 0597544ffb..ebf9f7b449 100644
--- a/c10/util/C++17.h
+++ b/c10/util/C++17.h
@@ -22,8 +22,8 @@
     "You're trying to build PyTorch with a too old version of Clang. We need Clang 4 or later."
 #endif
 
-#if (defined(_MSC_VER) && (!defined(_MSVC_LANG) || _MSVC_LANG < 201703L)) || \
-    (!defined(_MSC_VER) && __cplusplus < 201703L)
+#if ((defined(_MSC_VER) && (!defined(_MSVC_LANG) || _MSVC_LANG < 201703L)) || \
+    (!defined(_MSC_VER) && __cplusplus < 201703L)) && !defined(__APPLE__)
 #error You need C++17 to compile PyTorch
 #endif
 
diff --git a/c10/util/Exception.h b/c10/util/Exception.h
index 6cf142c460..fa5e67ddda 100644
--- a/c10/util/Exception.h
+++ b/c10/util/Exception.h
@@ -1,4 +1,4 @@
-#ifndef C10_UTIL_EXCEPTION_H_
+  #ifndef C10_UTIL_EXCEPTION_H_
 #define C10_UTIL_EXCEPTION_H_
 
 #include <c10/macros/Macros.h>
@@ -7,7 +7,14 @@
 #include <cstddef>
 #include <exception>
 #include <string>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+} // namespace std
+#else
 #include <variant>
+#endif
 #include <vector>
 
 #if defined(_MSC_VER) && _MSC_VER <= 1900
@@ -115,7 +122,11 @@ class C10_API Warning {
   class C10_API UserWarning {};
   class C10_API DeprecationWarning {};
 
+#if defined(__APPLE__) && defined(__MACH__)
+  using warning_variant_t = c10::variant<UserWarning, DeprecationWarning>;
+#else
   using warning_variant_t = std::variant<UserWarning, DeprecationWarning>;
+#endif
 
   Warning(
       warning_variant_t type,
diff --git a/c10/util/Float8_e4m3fnuz.cpp b/c10/util/Float8_e4m3fnuz.cpp
index 7bf301ff1b..290317e642 100644
--- a/c10/util/Float8_e4m3fnuz.cpp
+++ b/c10/util/Float8_e4m3fnuz.cpp
@@ -2,6 +2,14 @@
 #include <array>
 #include <iostream>
 
+#if defined(__APPLE__) && defined(__MACH__)
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  template <class T>
+  constexpr bool is_standard_layout_v = std::is_standard_layout<T>::value;
+}
+#endif
+
 namespace c10 {
 
 namespace detail {
diff --git a/c10/util/Float8_e5m2fnuz.cpp b/c10/util/Float8_e5m2fnuz.cpp
index c98f6dc6d7..0666f6e157 100644
--- a/c10/util/Float8_e5m2fnuz.cpp
+++ b/c10/util/Float8_e5m2fnuz.cpp
@@ -2,6 +2,14 @@
 #include <array>
 #include <iostream>
 
+#if defined(__APPLE__) && defined(__MACH__)
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  template <class T>
+  constexpr bool is_standard_layout_v = std::is_standard_layout<T>::value;
+}
+#endif
+
 namespace c10 {
 
 namespace detail {
diff --git a/c10/util/MaybeOwned.h b/c10/util/MaybeOwned.h
index a6517ac2bb..ca22e21a85 100644
--- a/c10/util/MaybeOwned.h
+++ b/c10/util/MaybeOwned.h
@@ -127,8 +127,8 @@ class MaybeOwned final {
   }
 
   MaybeOwned(MaybeOwned&& rhs) noexcept(
-      std::is_nothrow_move_constructible_v<T>&&
-          std::is_nothrow_move_assignable_v<borrow_type>)
+      std::is_nothrow_move_constructible<T>::value&&
+          std::is_nothrow_move_assignable<borrow_type>::value)
       : isBorrowed_(rhs.isBorrowed_) {
     if (C10_LIKELY(rhs.isBorrowed_)) {
       MaybeOwnedTraits<T>::assignBorrow(borrow_, rhs.borrow_);
@@ -138,10 +138,10 @@ class MaybeOwned final {
   }
 
   MaybeOwned& operator=(MaybeOwned&& rhs) noexcept(
-      std::is_nothrow_move_assignable_v<T>&& std::is_nothrow_move_assignable_v<
-          borrow_type>&& std::is_nothrow_move_constructible_v<T>&&
-          std::is_nothrow_destructible_v<T>&&
-              std::is_nothrow_destructible_v<borrow_type>) {
+      std::is_nothrow_move_assignable<T>::value&& std::is_nothrow_move_assignable<
+          borrow_type>::value&& std::is_nothrow_move_constructible<T>::value&&
+          std::is_nothrow_destructible<T>::value&&
+              std::is_nothrow_destructible<borrow_type>::value) {
     if (this == &rhs) {
       return *this;
     }
@@ -179,8 +179,8 @@ class MaybeOwned final {
     return MaybeOwned(in_place, std::forward<Args>(args)...);
   }
 
-  ~MaybeOwned() noexcept(std::is_nothrow_destructible_v<T>&&
-                             std::is_nothrow_destructible_v<borrow_type>) {
+  ~MaybeOwned() noexcept(std::is_nothrow_destructible<T>::value&&
+                             std::is_nothrow_destructible<borrow_type>::value) {
     if (C10_UNLIKELY(!isBorrowed_)) {
       own_.~T();
     } else {
diff --git a/c10/util/Optional.h b/c10/util/Optional.h
index 2fcba600e9..45d58282e3 100644
--- a/c10/util/Optional.h
+++ b/c10/util/Optional.h
@@ -1,6 +1,1242 @@
 #ifndef C10_UTIL_OPTIONAL_H_
 #define C10_UTIL_OPTIONAL_H_
 
+#if defined(__APPLE__) && defined(__MACH__)
+
+#include <c10/macros/Macros.h>
+#include <c10/util/ArrayRef.h>
+#include <c10/util/in_place.h>
+
+#include <cassert>
+#include <functional>
+#include <initializer_list>
+#include <stdexcept>
+#include <string>
+#include <type_traits>
+#include <utility>
+
+#include <c10/util/C++17.h>
+#include <c10/util/Metaprogramming.h>
+
+C10_CLANG_DIAGNOSTIC_PUSH()
+#if C10_CLANG_HAS_WARNING("-Wstring-conversion")
+C10_CLANG_DIAGNOSTIC_IGNORE("-Wstring-conversion")
+#endif
+#if C10_CLANG_HAS_WARNING("-Wshorten-64-to-32")
+C10_CLANG_DIAGNOSTIC_IGNORE("-Wshorten-64-to-32")
+#endif
+#if C10_CLANG_HAS_WARNING("-Wimplicit-float-conversion")
+C10_CLANG_DIAGNOSTIC_IGNORE("-Wimplicit-float-conversion")
+#endif
+#if C10_CLANG_HAS_WARNING("-Wimplicit-int-conversion")
+C10_CLANG_DIAGNOSTIC_IGNORE("-Wimplicit-int-conversion")
+#endif
+
+#define TR2_OPTIONAL_REQUIRES(...) \
+  typename std::enable_if<__VA_ARGS__::value, bool>::type = false
+
+namespace c10 {
+
+// 20.5.4, optional for object types
+template <class T>
+class optional;
+
+// 20.5.5, optional for lvalue reference types
+template <class T>
+class optional<T&>;
+
+// workaround: std utility functions aren't constexpr yet
+template <class T>
+inline constexpr T&& constexpr_forward(
+    typename std::remove_reference<T>::type& t) noexcept {
+  return static_cast<T&&>(t);
+}
+
+template <class T>
+inline constexpr T&& constexpr_forward(
+    typename std::remove_reference<T>::type&& t) noexcept {
+  static_assert(!std::is_lvalue_reference<T>::value, "!!");
+  return static_cast<T&&>(t);
+}
+
+template <class T>
+inline constexpr typename std::remove_reference<T>::type&& constexpr_move(
+    T&& t) noexcept {
+  return static_cast<typename std::remove_reference<T>::type&&>(t);
+}
+
+#if defined NDEBUG
+#define TR2_OPTIONAL_ASSERTED_EXPRESSION(CHECK, EXPR) (EXPR)
+#else
+#define TR2_OPTIONAL_ASSERTED_EXPRESSION(CHECK, EXPR) \
+  ((CHECK) ? (EXPR) : ([] { assert(!#CHECK); }(), (EXPR)))
+#endif
+
+#if defined(__CUDA_ARCH__)
+#define TR2_OPTIONAL_HOST_CONSTEXPR
+#else
+#define TR2_OPTIONAL_HOST_CONSTEXPR constexpr
+#endif
+
+// Sphinx chokes on static_addressof, so exclude it from Doxygen
+// generation.  See https://github.com/sphinx-doc/sphinx/issues/7944
+// \cond
+
+namespace detail_ {
+
+// VS doesn't handle constexpr well, so we need to skip these stuff.
+#if (defined _MSC_VER)
+template <typename T>
+T* static_addressof(T& ref) {
+  return std::addressof(ref);
+}
+#else
+// static_addressof: a constexpr version of addressof
+template <typename T>
+struct has_overloaded_addressof {
+  template <class X>
+  constexpr static bool has_overload(...) {
+    return false;
+  }
+
+  template <class X, size_t S = sizeof(std::declval<X&>().operator&())>
+  constexpr static bool has_overload(bool) {
+    return true;
+  }
+
+  constexpr static bool value = has_overload<T>(true);
+};
+
+template <typename T, TR2_OPTIONAL_REQUIRES(!has_overloaded_addressof<T>)>
+constexpr T* static_addressof(T& ref) {
+  return &ref;
+}
+
+template <typename T, TR2_OPTIONAL_REQUIRES(has_overloaded_addressof<T>)>
+T* static_addressof(T& ref) {
+  return std::addressof(ref);
+}
+#endif
+
+// the call to convert<A>(b) has return type A and converts b to type A iff b
+// decltype(b) is implicitly convertible to A
+template <class U>
+constexpr U convert(U v) {
+  return v;
+}
+
+} // namespace detail_
+
+// \endcond
+
+constexpr struct trivial_init_t {
+} trivial_init{};
+
+// 20.5.7, Disengaged state indicator
+struct nullopt_t {
+  constexpr explicit nullopt_t(int) {}
+};
+constexpr nullopt_t nullopt{0};
+
+// 20.5.8, class bad_optional_access
+class bad_optional_access : public std::logic_error {
+ public:
+  explicit bad_optional_access(const std::string& what_arg)
+      : logic_error{what_arg} {}
+  explicit bad_optional_access(const char* what_arg) : logic_error{what_arg} {}
+};
+
+template <class T>
+union storage_t {
+  unsigned char dummy_{};
+  T value_;
+
+#if __cplusplus >= 202002L
+  constexpr
+#endif
+      storage_t(trivial_init_t) noexcept {
+    new (&dummy_) unsigned char;
+  }
+
+  template <class... Args>
+  constexpr storage_t(Args&&... args)
+      : value_(constexpr_forward<Args>(args)...) {}
+
+  ~storage_t() {}
+};
+
+template <class T>
+union constexpr_storage_t {
+  unsigned char dummy_;
+  T value_;
+
+#if __cplusplus >= 202002L
+  // C++20 lifted the requirement to initialize a union member in order to be
+  // constexpr.
+  constexpr constexpr_storage_t(trivial_init_t) noexcept {
+    new (&dummy_) unsigned char;
+  }
+#else
+  constexpr constexpr_storage_t(trivial_init_t) noexcept : dummy_() {}
+#endif
+
+  template <class... Args>
+  constexpr constexpr_storage_t(Args&&... args)
+      : value_(constexpr_forward<Args>(args)...) {}
+
+  ~constexpr_storage_t() = default;
+};
+
+template <class T>
+struct optional_base {
+  bool init_;
+  storage_t<T> storage_;
+
+  constexpr optional_base() noexcept : init_(false), storage_(trivial_init){};
+
+  explicit constexpr optional_base(const optional_base<T>& v)
+      : init_(v.init_), storage_(trivial_init) {
+    if (init_) {
+      ::new (dataptr()) T(v.storage_.value_);
+    }
+  }
+
+  explicit constexpr optional_base(const T& v) : init_(true), storage_(v) {}
+
+  explicit constexpr optional_base(optional_base<T>&& v) noexcept(
+      std::is_nothrow_move_constructible<T>::value)
+      : init_(v.init_), storage_(trivial_init) {
+    if (init_) {
+      ::new (dataptr()) T(std::move(v.storage_.value_));
+    }
+  }
+
+  explicit constexpr optional_base(T&& v)
+      : init_(true), storage_(constexpr_move(v)) {}
+
+  template <class... Args>
+  explicit optional_base(in_place_t, Args&&... args)
+      : init_(true), storage_(constexpr_forward<Args>(args)...) {}
+
+  template <
+      class U,
+      class... Args,
+      TR2_OPTIONAL_REQUIRES(std::is_constructible<T, std::initializer_list<U>>)>
+  explicit optional_base(
+      in_place_t,
+      std::initializer_list<U> il,
+      Args&&... args)
+      : init_(true), storage_(il, std::forward<Args>(args)...) {}
+
+  optional_base& operator=(const optional_base& rhs) {
+    if (init_ && !rhs.init_) {
+      clear();
+    } else if (!init_ && rhs.init_) {
+      init_ = true;
+      ::new (dataptr()) T(rhs.storage_.value_);
+    } else if (init_ && rhs.init_) {
+      storage_.value_ = rhs.storage_.value_;
+    }
+    return *this;
+  }
+
+  optional_base& operator=(optional_base&& rhs) noexcept(
+      std::is_nothrow_move_assignable<T>::value&&
+          std::is_nothrow_move_constructible<T>::value) {
+    if (init_ && !rhs.init_) {
+      clear();
+    } else if (!init_ && rhs.init_) {
+      init_ = true;
+      ::new (dataptr()) T(std::move(rhs.storage_.value_));
+    } else if (init_ && rhs.init_) {
+      storage_.value_ = std::move(rhs.storage_.value_);
+    }
+    return *this;
+  }
+
+  ~optional_base() {
+    if (init_)
+      storage_.value_.T::~T();
+  }
+
+  constexpr bool initialized() const noexcept {
+    return init_;
+  }
+
+  void setInitialized(bool init) noexcept {
+    init_ = init;
+  }
+
+ private:
+  typename std::remove_const<T>::type* dataptr() {
+    return std::addressof(storage_.value_);
+  }
+
+  constexpr const T* dataptr() const {
+    return detail_::static_addressof(storage_.value_);
+  }
+
+  void clear() noexcept {
+    if (init_) {
+      dataptr()->~T();
+    }
+    init_ = false;
+  }
+};
+
+template <class T>
+struct constexpr_optional_base {
+  bool init_;
+  constexpr_storage_t<T> storage_;
+
+  constexpr constexpr_optional_base() noexcept
+      : init_(false), storage_(trivial_init){};
+
+  explicit constexpr constexpr_optional_base(
+      const constexpr_optional_base<T>& v)
+      : init_(v.init_), storage_(trivial_init) {
+    if (init_) {
+      ::new (dataptr()) T(v.storage_.value_);
+    }
+  }
+
+  explicit constexpr constexpr_optional_base(
+      constexpr_optional_base<T>&&
+          v) noexcept(std::is_nothrow_move_constructible<T>::value)
+      : init_(v.init_), storage_(trivial_init) {
+    if (init_) {
+      ::new (dataptr()) T(std::move(v.storage_.value_));
+    }
+  }
+
+  explicit constexpr constexpr_optional_base(const T& v)
+      : init_(true), storage_(v) {}
+
+  explicit constexpr constexpr_optional_base(T&& v)
+      : init_(true), storage_(constexpr_move(v)) {}
+
+  template <class... Args>
+  explicit constexpr constexpr_optional_base(in_place_t, Args&&... args)
+      : init_(true), storage_(constexpr_forward<Args>(args)...) {}
+
+  template <
+      class U,
+      class... Args,
+      TR2_OPTIONAL_REQUIRES(std::is_constructible<T, std::initializer_list<U>>)>
+  constexpr explicit constexpr_optional_base(
+      in_place_t,
+      std::initializer_list<U> il,
+      Args&&... args)
+      : init_(true), storage_(il, std::forward<Args>(args)...) {}
+
+  ~constexpr_optional_base() = default;
+
+  constexpr_optional_base& operator=(const constexpr_optional_base& rhs) {
+    if (init_ && !rhs.init_) {
+      clear();
+    } else if (!init_ && rhs.init_) {
+      init_ = true;
+      ::new (dataptr()) T(rhs.storage_.value_);
+    } else if (init_ && rhs.init_) {
+      storage_.value_ = rhs.storage_.value_;
+    }
+    return *this;
+  }
+
+  constexpr_optional_base& operator=(constexpr_optional_base&& rhs) noexcept(
+      std::is_nothrow_move_assignable<T>::value&&
+          std::is_nothrow_move_constructible<T>::value) {
+    if (init_ && !rhs.init_) {
+      clear();
+    } else if (!init_ && rhs.init_) {
+      init_ = true;
+      ::new (dataptr()) T(std::move(rhs.storage_.value_));
+    } else if (init_ && rhs.init_) {
+      storage_.value_ = std::move(rhs.storage_.value_);
+    }
+    return *this;
+  }
+
+  constexpr bool initialized() const noexcept {
+    return init_;
+  }
+  void setInitialized(bool init) noexcept {
+    init_ = init;
+  }
+
+ private:
+  typename std::remove_const<T>::type* dataptr() {
+    return std::addressof(storage_.value_);
+  }
+
+  constexpr const T* dataptr() const {
+    return detail_::static_addressof(storage_.value_);
+  }
+
+  void clear() noexcept {
+    init_ = false;
+  }
+};
+
+// HACK: Optimization for trivially copyable types. The mainline
+// implementation fails to have trivial copy/move operations in these
+// cases, and we care about them, so just implement that directly.
+template <class T>
+struct trivially_copyable_optimization_optional_base {
+  bool init_;
+  constexpr_storage_t<T> storage_;
+
+  constexpr trivially_copyable_optimization_optional_base() noexcept
+      : init_(false), storage_(trivial_init) {}
+
+  explicit constexpr trivially_copyable_optimization_optional_base(const T& v)
+      : init_(true), storage_(v) {}
+
+  explicit constexpr trivially_copyable_optimization_optional_base(T&& v)
+      : init_(true), storage_(constexpr_move(v)) {}
+
+  template <class... Args>
+  explicit constexpr trivially_copyable_optimization_optional_base(
+      in_place_t,
+      Args&&... args)
+      : init_(true), storage_(constexpr_forward<Args>(args)...) {}
+
+  template <
+      class U,
+      class... Args,
+      TR2_OPTIONAL_REQUIRES(std::is_constructible<T, std::initializer_list<U>>)>
+  constexpr explicit trivially_copyable_optimization_optional_base(
+      in_place_t,
+      std::initializer_list<U> il,
+      Args&&... args)
+      : init_(true), storage_(il, std::forward<Args>(args)...) {}
+
+  ~trivially_copyable_optimization_optional_base() = default;
+
+  constexpr bool initialized() const noexcept {
+    return init_;
+  }
+  void setInitialized(bool init) noexcept {
+    init_ = init;
+  }
+};
+
+// HACK: Optimization for ArrayRef<T>. We take advantage of an unused
+// bit pattern in ArrayRef (inspired by Arthur O'Dwyer's
+// tombstone_traits -- see https://youtu.be/MWBfmmg8-Yo?t=2466) to
+// keep the size of c10::optional::ArrayRef<T> down to 16 bytes, which
+// allows it to be passed to functions in registers instead of getting
+// passed in memory per item 5c of the classification algorithm in
+// section 3.2.3 of the System V ABI document
+// (https://www.uclibc.org/docs/psABI-x86_64.pdf).
+template <class ArrayRefT>
+class arrayref_optional_base {
+ public:
+  union storage {
+    struct raw {
+      // ArrayRef has the invariant that if Data is nullptr then
+      // Length must be zero, so this is an unused bit pattern.
+      const void* p = nullptr;
+      size_t sz = 1;
+    } uninitialized_{};
+    ArrayRefT value_;
+
+    constexpr storage() noexcept : uninitialized_() {
+      setUninitialized();
+    }
+
+    constexpr void setUninitialized() noexcept {
+      uninitialized_.p = nullptr;
+      uninitialized_.sz = 1;
+    }
+
+    explicit constexpr storage(ArrayRefT& v) : value_(v) {}
+
+    template <typename T>
+    explicit constexpr storage(const std::initializer_list<T>& v) : value_(v) {}
+
+    template <class... Args>
+    explicit constexpr storage(Args&&... args)
+        : value_(constexpr_forward<Args>(args)...) {}
+  };
+
+  storage storage_;
+
+  constexpr arrayref_optional_base() noexcept = default;
+
+  explicit constexpr arrayref_optional_base(const ArrayRefT& v) : storage_(v) {}
+
+  template <class... Args>
+  explicit constexpr arrayref_optional_base(in_place_t, Args&&... args)
+      : storage_(constexpr_forward<Args>(args)...) {}
+
+  template <typename T>
+  explicit constexpr arrayref_optional_base(
+      in_place_t,
+      const std::initializer_list<T>& v)
+      : storage_(v) {}
+
+  constexpr bool initialized() const noexcept {
+    return storage_.uninitialized_.p != nullptr ||
+        storage_.uninitialized_.sz == 0;
+  }
+
+  void setInitialized(bool init) noexcept {
+    if (!init) {
+      storage_.setUninitialized();
+    } else {
+      assert(initialized());
+    }
+  }
+};
+
+namespace detail_ {
+template <typename T>
+struct is_arrayref : std::false_type {};
+
+template <typename T>
+struct is_arrayref<c10::ArrayRef<T>> : std::true_type {};
+} // namespace detail_
+
+template <class T>
+using OptionalBase = std::conditional_t<
+    detail_::is_arrayref<T>::value,
+    arrayref_optional_base<T>,
+    std::conditional_t<
+        std::is_trivially_destructible<T>::value &&
+            C10_IS_TRIVIALLY_COPYABLE(T) &&
+            // Avoid using is_trivially_copy_{constructible,assignable}
+            // because old GCC versions don't support them. Also,
+            // is_trivially_copyable seems not to do what I expect, so check
+            // trivially_copyable_optimization_optional_base directly.
+            std::is_copy_constructible<
+                trivially_copyable_optimization_optional_base<T>>::value &&
+            std::is_copy_assignable<
+                trivially_copyable_optimization_optional_base<T>>::value,
+        trivially_copyable_optimization_optional_base<T>,
+        std::conditional_t<
+            std::is_trivially_destructible<T>::value, // if possible
+            constexpr_optional_base<std::remove_const_t<T>>, // use base with
+                                                             // trivial
+                                                             // destructor
+            optional_base<std::remove_const_t<T>>>>>;
+
+template <class T>
+class optional : private OptionalBase<T> {
+  template <class U> // re-declaration for nvcc on Windows.
+  using OptionalBase = std::conditional_t<
+      detail_::is_arrayref<U>::value,
+      arrayref_optional_base<U>,
+      std::conditional_t<
+          std::is_trivially_destructible<U>::value &&
+              C10_IS_TRIVIALLY_COPYABLE(U) &&
+              // Avoid using is_trivially_copy_{constructible,assignable}
+              // because old GCC versions don't support them. Also,
+              // is_trivially_copyable seems not to do what I expect, so
+              // check trivially_copyable_optimization_optional_base
+              // directly.
+              std::is_copy_constructible<
+                  trivially_copyable_optimization_optional_base<U>>::value &&
+              std::is_copy_assignable<
+                  trivially_copyable_optimization_optional_base<U>>::value,
+          trivially_copyable_optimization_optional_base<U>,
+          std::conditional_t<
+              std::is_trivially_destructible<U>::value, // if possible
+              constexpr_optional_base<std::remove_const_t<U>>, // use base
+                                                               // with
+                                                               // trivial
+                                                               // destructor
+              optional_base<std::remove_const_t<U>>>>>;
+
+  static_assert(
+      !std::is_same<typename std::decay<T>::type, nullopt_t>::value,
+      "bad T");
+  static_assert(
+      !std::is_same<typename std::decay<T>::type, in_place_t>::value,
+      "bad T");
+
+  constexpr bool initialized() const noexcept {
+    return OptionalBase<T>::initialized();
+  }
+  typename std::remove_const<T>::type* dataptr() {
+    return std::addressof(OptionalBase<T>::storage_.value_);
+  }
+  constexpr const T* dataptr() const {
+    return detail_::static_addressof(OptionalBase<T>::storage_.value_);
+  }
+
+  constexpr const T& contained_val() const& {
+    return OptionalBase<T>::storage_.value_;
+  }
+  constexpr T&& contained_val() && {
+    return std::move(OptionalBase<T>::storage_.value_);
+  }
+  constexpr T& contained_val() & {
+    return OptionalBase<T>::storage_.value_;
+  }
+
+  void clear() noexcept {
+    if (initialized())
+      dataptr()->~T();
+    OptionalBase<T>::setInitialized(false);
+  }
+
+  template <class... Args>
+  void initialize(Args&&... args) noexcept(
+      noexcept(T(std::forward<Args>(args)...))) {
+    assert(!initialized());
+    ::new (static_cast<void*>(dataptr())) T(std::forward<Args>(args)...);
+    OptionalBase<T>::setInitialized(true);
+  }
+
+  template <class U, class... Args>
+  void initialize(std::initializer_list<U> il, Args&&... args) noexcept(
+      noexcept(T(il, std::forward<Args>(args)...))) {
+    assert(!initialized());
+    ::new (static_cast<void*>(dataptr())) T(il, std::forward<Args>(args)...);
+    OptionalBase<T>::setInitialized(true);
+  }
+
+ public:
+  typedef T value_type;
+
+  // 20.5.5.1, constructors
+  constexpr optional() noexcept = default;
+  constexpr optional(nullopt_t) noexcept : OptionalBase<T>(){};
+
+  optional(const optional& rhs) = default;
+  optional(optional&& rhs) = default;
+
+  // see https://github.com/akrzemi1/Optional/issues/16
+  // and https://en.cppreference.com/w/cpp/utility/optional/optional,
+  // in constructor 8, the std::optional spec can allow initialization
+  // of optionals from convertible type U
+  //
+  // 8 - implicit move construct from value
+  template <
+      typename U = T,
+      TR2_OPTIONAL_REQUIRES(
+          std::is_constructible<T, U&&>::value &&
+          !std::is_same<typename std::decay<U>::type, in_place_t>::value &&
+          !std::is_same<typename std::decay<U>::type, optional<T>>::value &&
+          std::is_convertible<U&&, T>)>
+  constexpr optional(U&& u) : OptionalBase<T>(std::forward<U>(u)) {}
+
+  // 8 - explicit move construct from value
+  template <
+      typename U = T,
+      TR2_OPTIONAL_REQUIRES(
+          std::is_constructible<T, U&&>::value &&
+          !std::is_same<typename std::decay<U>::type, in_place_t>::value &&
+          !std::is_same<typename std::decay<U>::type, optional<T>>::value &&
+          !std::is_convertible<U&&, T>)>
+  explicit constexpr optional(U&& u) : OptionalBase<T>(std::forward<U>(u)) {}
+
+  template <class... Args>
+  explicit constexpr optional(in_place_t, Args&&... args)
+      : OptionalBase<T>(in_place_t{}, constexpr_forward<Args>(args)...) {}
+
+  template <
+      class U,
+      class... Args,
+      TR2_OPTIONAL_REQUIRES(std::is_constructible<T, std::initializer_list<U>>)>
+  constexpr explicit optional(
+      in_place_t,
+      std::initializer_list<U> il,
+      Args&&... args)
+      : OptionalBase<T>(in_place_t{}, il, constexpr_forward<Args>(args)...) {}
+
+  // 20.5.4.2, Destructor
+  ~optional() = default;
+
+  // 20.5.4.3, assignment
+  optional& operator=(nullopt_t) noexcept {
+    clear();
+    return *this;
+  }
+
+  optional& operator=(const optional& rhs) = default;
+
+  optional& operator=(optional&& rhs) = default;
+
+  template <class U = T>
+  auto operator=(U&& v) -> typename std::enable_if<
+      std::is_constructible<T, U>::value &&
+          !std::is_same<typename std::decay<U>::type, optional<T>>::value &&
+          (std::is_scalar<T>::value ||
+           std::is_same<typename std::decay<U>::type, T>::value) &&
+          std::is_assignable<T&, U>::value,
+      optional&>::type {
+    if (initialized()) {
+      contained_val() = std::forward<U>(v);
+    } else {
+      initialize(std::forward<U>(v));
+    }
+    return *this;
+  }
+
+  template <class... Args>
+  void emplace(Args&&... args) {
+    clear();
+    initialize(std::forward<Args>(args)...);
+  }
+
+  template <class U, class... Args>
+  void emplace(std::initializer_list<U> il, Args&&... args) {
+    clear();
+    initialize<U, Args...>(il, std::forward<Args>(args)...);
+  }
+
+  // 20.5.4.4, Swap
+  void swap(optional<T>& rhs) noexcept(
+      std::is_nothrow_move_constructible<T>::value&& noexcept(
+          std::swap(std::declval<T&>(), std::declval<T&>()))) {
+    if (initialized() == true && rhs.initialized() == false) {
+      rhs.initialize(std::move(**this));
+      clear();
+    } else if (initialized() == false && rhs.initialized() == true) {
+      initialize(std::move(*rhs));
+      rhs.clear();
+    } else if (initialized() == true && rhs.initialized() == true) {
+      using std::swap;
+      swap(**this, *rhs);
+    }
+  }
+
+  // 20.5.4.5, Observers
+
+  explicit constexpr operator bool() const noexcept {
+    return initialized();
+  }
+  constexpr bool has_value() const noexcept {
+    return initialized();
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T const* operator->() const {
+    return TR2_OPTIONAL_ASSERTED_EXPRESSION(initialized(), dataptr());
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T* operator->() {
+    assert(initialized());
+    return dataptr();
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T const& operator*() const& {
+    return TR2_OPTIONAL_ASSERTED_EXPRESSION(initialized(), contained_val());
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T& operator*() & {
+    assert(initialized());
+    return contained_val();
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T&& operator*() && {
+    assert(initialized());
+    return constexpr_move(contained_val());
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T const& value() const& {
+    return initialized()
+        ? contained_val()
+        : (throw bad_optional_access("bad optional access"), contained_val());
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T& value() & {
+    return initialized()
+        ? contained_val()
+        : (throw bad_optional_access("bad optional access"), contained_val());
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T&& value() && {
+    if (!initialized())
+      throw bad_optional_access("bad optional access");
+    return std::move(contained_val());
+  }
+
+  template <class V>
+  constexpr T value_or(V&& v) const& {
+    return *this ? **this : detail_::convert<T>(constexpr_forward<V>(v));
+  }
+
+  template <class V>
+  constexpr T value_or(V&& v) && {
+    return *this
+        ? constexpr_move(const_cast<optional<T>&>(*this).contained_val())
+        : detail_::convert<T>(constexpr_forward<V>(v));
+  }
+
+  // 20.6.3.6, modifiers
+  void reset() noexcept {
+    clear();
+  }
+};
+
+template <class T, class F>
+constexpr T value_or_else(const optional<T>& v, F&& func) {
+  static_assert(
+      std::is_convertible<
+          typename guts::infer_function_traits_t<F>::return_type,
+          T>::value,
+      "func parameters must be a callable that returns a type convertible to the value stored in the optional");
+  return v.has_value() ? *v : detail_::convert<T>(std::forward<F>(func)());
+}
+
+template <class T, class F>
+constexpr T value_or_else(optional<T>&& v, F&& func) {
+  static_assert(
+      std::is_convertible<
+          typename guts::infer_function_traits_t<F>::return_type,
+          T>::value,
+      "func parameters must be a callable that returns a type convertible to the value stored in the optional");
+  return v.has_value() ? constexpr_move(std::move(v).contained_val())
+                       : detail_::convert<T>(std::forward<F>(func)());
+}
+
+// XXX: please refrain from using optional<T&>, since it is being against with
+// the optional standard in c++ 17, see the debate and the details here:
+// http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3406#rationale.refs
+// if you need it, consider using optional<std::reference_wrapper<T>> or *
+// pointer
+//
+// we leave the implementation here in case we want to reconsider using it in
+// the future if it becomes a definitely necessary case.
+template <class T>
+class optional<T&> {
+  // add this assert to prevent user from using optional reference as indicated
+  // above
+  static_assert(
+      sizeof(T) == 0,
+      "optional references is ill-formed, \
+    consider use optional of a std::reference_wrapper of type T to \
+    hold a reference if you really need to");
+
+  static_assert(!std::is_same<T, nullopt_t>::value, "bad T");
+  static_assert(!std::is_same<T, in_place_t>::value, "bad T");
+  T* ref;
+
+ public:
+  // 20.5.5.1, construction/destruction
+  constexpr optional() noexcept : ref(nullptr) {}
+
+  constexpr optional(nullopt_t) noexcept : ref(nullptr) {}
+
+  template <typename U = T>
+  constexpr optional(U& u) noexcept : ref(detail_::static_addressof(u)) {}
+
+  template <typename U = T>
+  optional(U&&) = delete;
+
+  constexpr optional(const optional& rhs) noexcept : ref(rhs.ref) {}
+
+  explicit constexpr optional(in_place_t, T& v) noexcept
+      : ref(detail_::static_addressof(v)) {}
+
+  explicit optional(in_place_t, T&&) = delete;
+
+  ~optional() = default;
+
+  // 20.5.5.2, mutation
+  optional& operator=(nullopt_t) noexcept {
+    ref = nullptr;
+    return *this;
+  }
+
+  // optional& operator=(const optional& rhs) noexcept {
+  // ref = rhs.ref;
+  // return *this;
+  // }
+
+  // optional& operator=(optional&& rhs) noexcept {
+  // ref = rhs.ref;
+  // return *this;
+  // }
+
+  template <typename U>
+  auto operator=(U&& rhs) noexcept -> typename std::enable_if<
+      std::is_same<typename std::decay<U>::type, optional<T&>>::value,
+      optional&>::type {
+    ref = rhs.ref;
+    return *this;
+  }
+
+  template <typename U>
+  auto operator=(U&& rhs) noexcept -> typename std::enable_if<
+      !std::is_same<typename std::decay<U>::type, optional<T&>>::value,
+      optional&>::type = delete;
+
+  void emplace(T& v) noexcept {
+    ref = detail_::static_addressof(v);
+  }
+
+  void emplace(T&&) = delete;
+
+  void swap(optional<T&>& rhs) noexcept {
+    std::swap(ref, rhs.ref);
+  }
+
+  // 20.5.5.3, observers
+  TR2_OPTIONAL_HOST_CONSTEXPR T* operator->() const {
+    return TR2_OPTIONAL_ASSERTED_EXPRESSION(ref, ref);
+  }
+
+  TR2_OPTIONAL_HOST_CONSTEXPR T& operator*() const {
+    return TR2_OPTIONAL_ASSERTED_EXPRESSION(ref, *ref);
+  }
+
+  constexpr T& value() const {
+    return ref ? *ref
+               : (throw bad_optional_access("bad optional access"), *ref);
+  }
+
+  explicit constexpr operator bool() const noexcept {
+    return ref != nullptr;
+  }
+
+  constexpr bool has_value() const noexcept {
+    return ref != nullptr;
+  }
+
+  template <class V>
+  constexpr typename std::decay<T>::type value_or(V&& v) const {
+    return *this ? **this
+                 : detail_::convert<typename std::decay<T>::type>(
+                       constexpr_forward<V>(v));
+  }
+
+  // x.x.x.x, modifiers
+  void reset() noexcept {
+    ref = nullptr;
+  }
+};
+
+template <class T>
+class optional<T&&> {
+  static_assert(sizeof(T) == 0, "optional rvalue references disallowed");
+};
+
+// 20.5.8, Relational operators
+template <class T>
+constexpr bool operator==(const optional<T>& x, const optional<T>& y) {
+  return bool(x) != bool(y) ? false : bool(x) == false ? true : *x == *y;
+}
+
+template <class T>
+constexpr bool operator!=(const optional<T>& x, const optional<T>& y) {
+  return !(x == y);
+}
+
+template <class T>
+constexpr bool operator<(const optional<T>& x, const optional<T>& y) {
+  return (!y) ? false : (!x) ? true : *x < *y;
+}
+
+template <class T>
+constexpr bool operator>(const optional<T>& x, const optional<T>& y) {
+  return (y < x);
+}
+
+template <class T>
+constexpr bool operator<=(const optional<T>& x, const optional<T>& y) {
+  return !(y < x);
+}
+
+template <class T>
+constexpr bool operator>=(const optional<T>& x, const optional<T>& y) {
+  return !(x < y);
+}
+
+// 20.5.9, Comparison with nullopt
+template <class T>
+constexpr bool operator==(const optional<T>& x, nullopt_t) noexcept {
+  return (!x);
+}
+
+template <class T>
+constexpr bool operator==(nullopt_t, const optional<T>& x) noexcept {
+  return (!x);
+}
+
+template <class T>
+constexpr bool operator!=(const optional<T>& x, nullopt_t) noexcept {
+  return bool(x);
+}
+
+template <class T>
+constexpr bool operator!=(nullopt_t, const optional<T>& x) noexcept {
+  return bool(x);
+}
+
+template <class T>
+constexpr bool operator<(const optional<T>&, nullopt_t) noexcept {
+  return false;
+}
+
+template <class T>
+constexpr bool operator<(nullopt_t, const optional<T>& x) noexcept {
+  return bool(x);
+}
+
+template <class T>
+constexpr bool operator<=(const optional<T>& x, nullopt_t) noexcept {
+  return (!x);
+}
+
+template <class T>
+constexpr bool operator<=(nullopt_t, const optional<T>&) noexcept {
+  return true;
+}
+
+template <class T>
+constexpr bool operator>(const optional<T>& x, nullopt_t) noexcept {
+  return bool(x);
+}
+
+template <class T>
+constexpr bool operator>(nullopt_t, const optional<T>&) noexcept {
+  return false;
+}
+
+template <class T>
+constexpr bool operator>=(const optional<T>&, nullopt_t) noexcept {
+  return true;
+}
+
+template <class T>
+constexpr bool operator>=(nullopt_t, const optional<T>& x) noexcept {
+  return (!x);
+}
+
+// 20.5.10, Comparison with T
+template <class T, class U>
+constexpr bool operator==(const optional<T>& x, const U& v) {
+  return bool(x) ? *x == v : false;
+}
+
+template <class T, class U>
+constexpr bool operator==(const U& v, const optional<T>& x) {
+  return bool(x) ? v == *x : false;
+}
+
+template <class T, class U>
+constexpr bool operator!=(const optional<T>& x, const U& v) {
+  return bool(x) ? *x != v : true;
+}
+
+template <class T, class U>
+constexpr bool operator!=(const U& v, const optional<T>& x) {
+  return bool(x) ? v != *x : true;
+}
+
+template <class T, class U>
+constexpr bool operator<(const optional<T>& x, const U& v) {
+  return bool(x) ? *x < v : true;
+}
+
+template <class T, class U>
+constexpr bool operator>(const U& v, const optional<T>& x) {
+  return bool(x) ? v > *x : true;
+}
+
+template <class T, class U>
+constexpr bool operator>(const optional<T>& x, const U& v) {
+  return bool(x) ? *x > v : false;
+}
+
+template <class T, class U>
+constexpr bool operator<(const U& v, const optional<T>& x) {
+  return bool(x) ? v < *x : false;
+}
+
+template <class T, class U>
+constexpr bool operator>=(const optional<T>& x, const U& v) {
+  return bool(x) ? *x >= v : false;
+}
+
+template <class T, class U>
+constexpr bool operator<=(const U& v, const optional<T>& x) {
+  return bool(x) ? v <= *x : false;
+}
+
+template <class T, class U>
+constexpr bool operator<=(const optional<T>& x, const U& v) {
+  return bool(x) ? *x <= v : true;
+}
+
+template <class T, class U>
+constexpr bool operator>=(const U& v, const optional<T>& x) {
+  return bool(x) ? v >= *x : true;
+}
+
+// Comparison of optional<T&> with T
+template <class T>
+constexpr bool operator==(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x == v : false;
+}
+
+template <class T>
+constexpr bool operator==(const T& v, const optional<T&>& x) {
+  return bool(x) ? v == *x : false;
+}
+
+template <class T>
+constexpr bool operator!=(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x != v : true;
+}
+
+template <class T>
+constexpr bool operator!=(const T& v, const optional<T&>& x) {
+  return bool(x) ? v != *x : true;
+}
+
+template <class T>
+constexpr bool operator<(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x < v : true;
+}
+
+template <class T>
+constexpr bool operator>(const T& v, const optional<T&>& x) {
+  return bool(x) ? v > *x : true;
+}
+
+template <class T>
+constexpr bool operator>(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x > v : false;
+}
+
+template <class T>
+constexpr bool operator<(const T& v, const optional<T&>& x) {
+  return bool(x) ? v < *x : false;
+}
+
+template <class T>
+constexpr bool operator>=(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x >= v : false;
+}
+
+template <class T>
+constexpr bool operator<=(const T& v, const optional<T&>& x) {
+  return bool(x) ? v <= *x : false;
+}
+
+template <class T>
+constexpr bool operator<=(const optional<T&>& x, const T& v) {
+  return bool(x) ? *x <= v : true;
+}
+
+template <class T>
+constexpr bool operator>=(const T& v, const optional<T&>& x) {
+  return bool(x) ? v >= *x : true;
+}
+
+// Comparison of optional<T const&> with T
+template <class T>
+constexpr bool operator==(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x == v : false;
+}
+
+template <class T>
+constexpr bool operator==(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v == *x : false;
+}
+
+template <class T>
+constexpr bool operator!=(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x != v : true;
+}
+
+template <class T>
+constexpr bool operator!=(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v != *x : true;
+}
+
+template <class T>
+constexpr bool operator<(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x < v : true;
+}
+
+template <class T>
+constexpr bool operator>(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v > *x : true;
+}
+
+template <class T>
+constexpr bool operator>(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x > v : false;
+}
+
+template <class T>
+constexpr bool operator<(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v < *x : false;
+}
+
+template <class T>
+constexpr bool operator>=(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x >= v : false;
+}
+
+template <class T>
+constexpr bool operator<=(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v <= *x : false;
+}
+
+template <class T>
+constexpr bool operator<=(const optional<const T&>& x, const T& v) {
+  return bool(x) ? *x <= v : true;
+}
+
+template <class T>
+constexpr bool operator>=(const T& v, const optional<const T&>& x) {
+  return bool(x) ? v >= *x : true;
+}
+
+// 20.5.12, Specialized algorithms
+template <class T>
+void swap(optional<T>& x, optional<T>& y) noexcept(noexcept(x.swap(y))) {
+  x.swap(y);
+}
+
+template <class T>
+constexpr optional<typename std::decay<T>::type> make_optional(T&& v) {
+  return optional<typename std::decay<T>::type>(constexpr_forward<T>(v));
+}
+
+template <class X>
+constexpr optional<X&> make_optional(std::reference_wrapper<X> v) {
+  return optional<X&>(v.get());
+}
+
+} // namespace c10
+
+namespace std {
+template <typename T>
+struct hash<c10::optional<T>> {
+  typedef c10::invoke_result_t<std::hash<T>, T> result_type;
+  typedef c10::optional<T> argument_type;
+
+  constexpr result_type operator()(argument_type const& arg) const {
+    return arg ? std::hash<T>{}(*arg) : result_type{};
+  }
+};
+
+template <typename T>
+struct hash<c10::optional<T&>> {
+  typedef typename hash<T>::result_type result_type;
+  typedef c10::optional<T&> argument_type;
+
+  constexpr result_type operator()(argument_type const& arg) const {
+    return arg ? std::hash<T>{}(*arg) : result_type{};
+  }
+};
+} // namespace std
+
+#undef TR2_OPTIONAL_REQUIRES
+#undef TR2_OPTIONAL_ASSERTED_EXPRESSION
+#undef TR2_OPTIONAL_HOST_CONSTEXPR
+
+C10_CLANG_DIAGNOSTIC_POP()
+
+#else
+
 #include <optional>
 #include <type_traits>
 
@@ -44,4 +1280,7 @@ constexpr T value_or_else(optional<T>&& v, F&& func) {
                        : detail_::convert<T>(std::forward<F>(func)());
 }
 } // namespace c10
+
+#endif // defined(__APPLE__) && defined(__MACH__)
+
 #endif // C10_UTIL_OPTIONAL_H_
diff --git a/c10/util/SmallVector.h b/c10/util/SmallVector.h
index a5f6d7fc53..081e66d03b 100644
--- a/c10/util/SmallVector.h
+++ b/c10/util/SmallVector.h
@@ -37,8 +37,25 @@
 #include <new>
 #include <ostream>
 #include <type_traits>
+
 #include <utility>
 
+#if defined(__APPLE__) && defined(__MACH__)
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  // template< class T >
+  //   inline constexpr bool is_move_assignable_v = is_move_assignable<T>::value;
+  // template< class T >
+  //   inline constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<T>::value;
+  // template< class T >
+  //   inline constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<T>::value;
+  // template <class T>
+  //   inline constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<T>::value;
+  // template <class T>
+  //   inline constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<T>::value;
+}
+#endif
+
 C10_CLANG_DIAGNOSTIC_PUSH()
 #if C10_CLANG_HAS_WARNING("-Wshorten-64-to-32")
 C10_CLANG_DIAGNOSTIC_IGNORE("-Wshorten-64-to-32")
@@ -1023,8 +1040,8 @@ class SmallVectorImpl : public SmallVectorTemplateBase<T> {
   SmallVectorImpl& operator=(const SmallVectorImpl& RHS);
 
   SmallVectorImpl& operator=(SmallVectorImpl&& RHS) noexcept(
-      std::is_nothrow_move_constructible_v<T>&&
-          std::is_nothrow_destructible_v<T>);
+      std::is_nothrow_move_constructible<T>::value &&
+          std::is_nothrow_destructible<T>::value);
 
   bool operator==(const SmallVectorImpl& RHS) const {
     if (this->size() != RHS.size())
@@ -1130,8 +1147,8 @@ SmallVectorImpl<T>& SmallVectorImpl<T>::operator=(
 
 template <typename T>
 SmallVectorImpl<T>& SmallVectorImpl<T>::operator=(
-    SmallVectorImpl<T>&& RHS) noexcept(std::is_nothrow_move_constructible_v<T>&&
-                                           std::is_nothrow_destructible_v<T>) {
+    SmallVectorImpl<T>&& RHS) noexcept(std::is_nothrow_move_constructible<T>::value &&
+                                           std::is_nothrow_destructible<T>::value) {
   // Avoid self-assignment.
   if (this == &RHS)
     return *this;
@@ -1344,7 +1361,7 @@ class /* LLVM_GSL_OWNER */ SmallVector : public SmallVectorImpl<T>,
   }
 
   SmallVector(SmallVector&& RHS) noexcept(
-      std::is_nothrow_move_assignable_v<SmallVectorImpl<T>>)
+      std::is_nothrow_move_assignable<SmallVectorImpl<T>>::value)
       : SmallVectorImpl<T>(N) {
     if (!RHS.empty())
       SmallVectorImpl<T>::operator=(::std::move(RHS));
@@ -1372,20 +1389,20 @@ class /* LLVM_GSL_OWNER */ SmallVector : public SmallVectorImpl<T>,
   }
 
   SmallVector(SmallVectorImpl<T>&& RHS) noexcept(
-      std::is_nothrow_move_assignable_v<SmallVectorImpl<T>>)
+      std::is_nothrow_move_assignable<SmallVectorImpl<T>>::value)
       : SmallVectorImpl<T>(N) {
     if (!RHS.empty())
       SmallVectorImpl<T>::operator=(::std::move(RHS));
   }
 
   SmallVector& operator=(SmallVector&& RHS) noexcept(
-      std::is_nothrow_move_assignable_v<SmallVectorImpl<T>>) {
+      std::is_nothrow_move_assignable<SmallVectorImpl<T>>::value) {
     SmallVectorImpl<T>::operator=(::std::move(RHS));
     return *this;
   }
 
   SmallVector& operator=(SmallVectorImpl<T>&& RHS) noexcept(
-      std::is_nothrow_move_constructible_v<SmallVectorImpl<T>>) {
+      std::is_nothrow_move_constructible<SmallVectorImpl<T>>::value) {
     SmallVectorImpl<T>::operator=(::std::move(RHS));
     return *this;
   }
diff --git a/c10/util/floating_point_utils.h b/c10/util/floating_point_utils.h
index 478e016609..6836b27cc5 100644
--- a/c10/util/floating_point_utils.h
+++ b/c10/util/floating_point_utils.h
@@ -2,7 +2,7 @@
 
 #include <cstdint>
 
-namespace c10::detail {
+namespace c10{ namespace detail {
 
 C10_HOST_DEVICE inline float fp32_from_bits(uint32_t w) {
 #if defined(__OPENCL_VERSION__)
@@ -36,4 +36,4 @@ C10_HOST_DEVICE inline uint32_t fp32_to_bits(float f) {
 #endif
 }
 
-} // namespace c10::detail
+}} // namespace c10::detail
diff --git a/c10/util/in_place.h b/c10/util/in_place.h
index 7c92472170..baa03ab9ee 100644
--- a/c10/util/in_place.h
+++ b/c10/util/in_place.h
@@ -4,9 +4,28 @@
 
 namespace c10 {
 
+
+#if defined(__APPLE__) && defined(__MACH__)
+struct in_place_t {
+  explicit in_place_t() = default;
+};
+
+template <std::size_t I>
+struct in_place_index_t {
+  explicit in_place_index_t() = default;
+};
+
+template <typename T>
+struct in_place_type_t {
+  explicit in_place_type_t() = default;
+};
+
+constexpr in_place_t in_place{};
+#else
 using std::in_place;
 using std::in_place_index_t;
 using std::in_place_t;
 using std::in_place_type_t;
+#endif
 
 } // namespace c10
diff --git a/c10/util/safe_numerics.h b/c10/util/safe_numerics.h
index c1e841d29e..81c46aa23d 100644
--- a/c10/util/safe_numerics.h
+++ b/c10/util/safe_numerics.h
@@ -19,7 +19,12 @@ namespace c10 {
 
 C10_ALWAYS_INLINE bool add_overflows(uint64_t a, uint64_t b, uint64_t* out) {
 #if C10_HAS_BUILTIN_OVERFLOW()
+// https://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins
+#if defined(__APPLE__) && defined(__MACH__)
+  return __builtin_uaddll_overflow(a, b, out);
+#else
   return __builtin_add_overflow(a, b, out);
+#endif
 #else
   unsigned long long tmp;
 #if defined(_M_IX86) || defined(_M_X64)
@@ -36,7 +41,12 @@ C10_ALWAYS_INLINE bool add_overflows(uint64_t a, uint64_t b, uint64_t* out) {
 
 C10_ALWAYS_INLINE bool mul_overflows(uint64_t a, uint64_t b, uint64_t* out) {
 #if C10_HAS_BUILTIN_OVERFLOW()
+// https://clang.llvm.org/docs/LanguageExtensions.html#checked-arithmetic-builtins
+#if defined(__APPLE__) && defined(__MACH__)
+  return __builtin_umulll_overflow(a, b, out);
+#else
   return __builtin_mul_overflow(a, b, out);
+#endif
 #else
   *out = a * b;
   // This test isnt exact, but avoids doing integer division
diff --git a/c10/util/tempfile.cpp b/c10/util/tempfile.cpp
index 28c3c7f14f..92a4db5708 100644
--- a/c10/util/tempfile.cpp
+++ b/c10/util/tempfile.cpp
@@ -58,7 +58,7 @@ std::optional<TempFile> try_make_tempfile(std::string_view name_prefix) {
 #if defined(_WIN32)
   return TempFile(std::move(filename));
 #else
-  const int fd = mkstemp(filename.data());
+  const int fd = mkstemp((char*)(filename.data()));
   if (fd == -1) {
     return std::nullopt;
   }
@@ -94,7 +94,7 @@ std::optional<TempDir> try_make_tempdir(std::string_view name_prefix) {
   return std::nullopt;
 #else
   auto filename = make_filename(name_prefix);
-  const char* dirname = mkdtemp(filename.data());
+  const char* dirname = mkdtemp((char*)(filename.data()));
   if (!dirname) {
     return std::nullopt;
   }
diff --git a/c10/util/tempfile.h b/c10/util/tempfile.h
index 4b5c16fb25..df9e473d4a 100644
--- a/c10/util/tempfile.h
+++ b/c10/util/tempfile.h
@@ -1,7 +1,16 @@
 #pragma once
 
 #include <c10/macros/Export.h>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/Optional.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::optional;
+  using ::c10::nullopt;
+}
+#else
 #include <optional>
+#endif
 #include <string>
 #include <utility>
 
diff --git a/c10/util/variant.h b/c10/util/variant.h
new file mode 100644
index 0000000000..53001afea2
--- /dev/null
+++ b/c10/util/variant.h
@@ -0,0 +1,3025 @@
+// MPark.Variant
+//
+// Copyright Michael Park, 2015-2017
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE.md or copy at
+// http://boost.org/LICENSE_1_0.txt)
+//
+// From https://github.com/mpark/variant
+//
+// C10
+// - Move to `c10` namespace.
+// - Rename namespace `detail` to `detail_`, to not conflict with existing
+//   c10 implementations in `detail` namespace.
+// - In two functions, the template name reference `I` is changed to
+//   `detail_::best_match<Arg, Ts...>::value` to work around gcc 7.3.1 bug.
+//   However, this workaround also limits the use cases of `c10::variant`.
+//   Please see NOTE [gcc 7.3.1 bug workaround] for details.
+// - The following code is moved to `c10/util/in_place.h`:
+//   ```
+//   struct in_place_t { explicit in_place_t() = default; };
+//
+//   template <std::size_t I>
+//   struct in_place_index_t { explicit in_place_index_t() = default; };
+//
+//   template <typename T>
+//   struct in_place_type_t { explicit in_place_type_t() = default; };
+//
+//   constexpr in_place_t in_place{};
+//   ```
+//   so that they can also be used in `c10/util/Optional.h`.
+
+#ifndef C10_UTIL_VARIANT_H_
+#define C10_UTIL_VARIANT_H_
+
+/*
+   variant synopsis
+
+namespace std {
+
+  // 20.7.2, class template variant
+  template <class... Types>
+  class variant {
+  public:
+
+    // 20.7.2.1, constructors
+    constexpr variant() noexcept(see below);
+    variant(const variant&);
+    variant(variant&&) noexcept(see below);
+
+    template <class T> constexpr variant(T&&) noexcept(see below);
+
+    template <class T, class... Args>
+    constexpr explicit variant(in_place_type_t<T>, Args&&...);
+
+    template <class T, class U, class... Args>
+    constexpr explicit variant(
+        in_place_type_t<T>, initializer_list<U>, Args&&...);
+
+    template <size_t I, class... Args>
+    constexpr explicit variant(in_place_index_t<I>, Args&&...);
+
+    template <size_t I, class U, class... Args>
+    constexpr explicit variant(
+        in_place_index_t<I>, initializer_list<U>, Args&&...);
+
+    // 20.7.2.2, destructor
+    ~variant();
+
+    // 20.7.2.3, assignment
+    variant& operator=(const variant&);
+    variant& operator=(variant&&) noexcept(see below);
+
+    template <class T> variant& operator=(T&&) noexcept(see below);
+
+    // 20.7.2.4, modifiers
+    template <class T, class... Args>
+    T& emplace(Args&&...);
+
+    template <class T, class U, class... Args>
+    T& emplace(initializer_list<U>, Args&&...);
+
+    template <size_t I, class... Args>
+    variant_alternative<I, variant>& emplace(Args&&...);
+
+    template <size_t I, class U, class...  Args>
+    variant_alternative<I, variant>& emplace(initializer_list<U>, Args&&...);
+
+    // 20.7.2.5, value status
+    constexpr bool valueless_by_exception() const noexcept;
+    constexpr size_t index() const noexcept;
+
+    // 20.7.2.6, swap
+    void swap(variant&) noexcept(see below);
+  };
+
+  // 20.7.3, variant helper classes
+  template <class T> struct variant_size; // undefined
+
+  template <class T>
+  constexpr size_t variant_size_v = variant_size<T>::value;
+
+  template <class T> struct variant_size<const T>;
+  template <class T> struct variant_size<volatile T>;
+  template <class T> struct variant_size<const volatile T>;
+
+  template <class... Types>
+  struct variant_size<variant<Types...>>;
+
+  template <size_t I, class T> struct variant_alternative; // undefined
+
+  template <size_t I, class T>
+  using variant_alternative_t = typename variant_alternative<I, T>::type;
+
+  template <size_t I, class T> struct variant_alternative<I, const T>;
+  template <size_t I, class T> struct variant_alternative<I, volatile T>;
+  template <size_t I, class T> struct variant_alternative<I, const volatile T>;
+
+  template <size_t I, class... Types>
+  struct variant_alternative<I, variant<Types...>>;
+
+  constexpr size_t variant_npos = -1;
+
+  // 20.7.4, value access
+  template <class T, class... Types>
+  constexpr bool holds_alternative(const variant<Types...>&) noexcept;
+
+  template <size_t I, class... Types>
+  constexpr variant_alternative_t<I, variant<Types...>>&
+  get(variant<Types...>&);
+
+  template <size_t I, class... Types>
+  constexpr variant_alternative_t<I, variant<Types...>>&&
+  get(variant<Types...>&&);
+
+  template <size_t I, class... Types>
+  constexpr variant_alternative_t<I, variant<Types...>> const&
+  get(const variant<Types...>&);
+
+  template <size_t I, class... Types>
+  constexpr variant_alternative_t<I, variant<Types...>> const&&
+  get(const variant<Types...>&&);
+
+  template <class T, class...  Types>
+  constexpr T& get(variant<Types...>&);
+
+  template <class T, class... Types>
+  constexpr T&& get(variant<Types...>&&);
+
+  template <class T, class... Types>
+  constexpr const T& get(const variant<Types...>&);
+
+  template <class T, class... Types>
+  constexpr const T&& get(const variant<Types...>&&);
+
+  template <size_t I, class... Types>
+  constexpr add_pointer_t<variant_alternative_t<I, variant<Types...>>>
+  get_if(variant<Types...>*) noexcept;
+
+  template <size_t I, class... Types>
+  constexpr add_pointer_t<const variant_alternative_t<I, variant<Types...>>>
+  get_if(const variant<Types...>*) noexcept;
+
+  template <class T, class... Types>
+  constexpr add_pointer_t<T>
+  get_if(variant<Types...>*) noexcept;
+
+  template <class T, class... Types>
+  constexpr add_pointer_t<const T>
+  get_if(const variant<Types...>*) noexcept;
+
+  // 20.7.5, relational operators
+  template <class... Types>
+  constexpr bool operator==(const variant<Types...>&, const variant<Types...>&);
+
+  template <class... Types>
+  constexpr bool operator!=(const variant<Types...>&, const variant<Types...>&);
+
+  template <class... Types>
+  constexpr bool operator<(const variant<Types...>&, const variant<Types...>&);
+
+  template <class... Types>
+  constexpr bool operator>(const variant<Types...>&, const variant<Types...>&);
+
+  template <class... Types>
+  constexpr bool operator<=(const variant<Types...>&, const variant<Types...>&);
+
+  template <class... Types>
+  constexpr bool operator>=(const variant<Types...>&, const variant<Types...>&);
+
+  // 20.7.6, visitation
+  template <class Visitor, class... Variants>
+  constexpr see below visit(Visitor&&, Variants&&...);
+
+  // 20.7.7, class monostate
+  struct monostate;
+
+  // 20.7.8, monostate relational operators
+  constexpr bool operator<(monostate, monostate) noexcept;
+  constexpr bool operator>(monostate, monostate) noexcept;
+  constexpr bool operator<=(monostate, monostate) noexcept;
+  constexpr bool operator>=(monostate, monostate) noexcept;
+  constexpr bool operator==(monostate, monostate) noexcept;
+  constexpr bool operator!=(monostate, monostate) noexcept;
+
+  // 20.7.9, specialized algorithms
+  template <class... Types>
+  void swap(variant<Types...>&, variant<Types...>&) noexcept(see below);
+
+  // 20.7.10, class bad_variant_access
+  class bad_variant_access;
+
+  // 20.7.11, hash support
+  template <class T> struct hash;
+  template <class... Types> struct hash<variant<Types...>>;
+  template <> struct hash<monostate>;
+
+} // namespace std
+
+*/
+
+#include <cstddef>
+#include <exception>
+#include <functional>
+#include <initializer_list>
+#include <new>
+#include <type_traits>
+#include <utility>
+
+// MPark.Variant
+//
+// Copyright Michael Park, 2015-2017
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE.md or copy at
+// http://boost.org/LICENSE_1_0.txt)
+
+#ifndef C10_MPARK_CONFIG_HPP
+#define C10_MPARK_CONFIG_HPP
+
+// MSVC 2015 Update 3.
+#if __cplusplus < 201103L && (!defined(_MSC_VER) || _MSC_FULL_VER < 190024210)
+#error "MPark.Variant requires C++11 support."
+#endif
+
+#ifndef __has_attribute
+#define __has_attribute(x) 0
+#endif
+
+#ifndef __has_builtin
+#define __has_builtin(x) 0
+#endif
+
+#ifndef __has_include
+#define __has_include(x) 0
+#endif
+
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+
+#if __has_attribute(always_inline) || defined(__GNUC__)
+#define C10_MPARK_ALWAYS_INLINE __attribute__((__always_inline__)) inline
+#elif defined(_MSC_VER)
+#define C10_MPARK_ALWAYS_INLINE __forceinline
+#else
+#define C10_MPARK_ALWAYS_INLINE inline
+#endif
+
+#if __has_builtin(__builtin_addressof) || \
+    (defined(__GNUC__) && __GNUC__ >= 7) || defined(_MSC_VER)
+#define C10_MPARK_BUILTIN_ADDRESSOF
+#endif
+
+#if __has_builtin(__builtin_unreachable) || defined(__GNUC__)
+#define C10_MPARK_BUILTIN_UNREACHABLE __builtin_unreachable()
+#elif defined(_MSC_VER)
+#define C10_MPARK_BUILTIN_UNREACHABLE __assume(false)
+#else
+#define C10_MPARK_BUILTIN_UNREACHABLE
+#endif
+
+// NOTE [nvcc bug workaround]
+//
+// The original line `typename Front = lib::type_pack_element_t<0, Ts...>,`
+// throws the following compiler error on nvcc:
+// ```
+// c10/util/variant.h(2367): error: parameter pack "Ts" was referenced but not
+// expanded
+// ```
+// As a workaround, we skip defining C10_MPARK_TYPE_PACK_ELEMENT for nvcc
+// compiler
+//
+// See the following issues for more context:
+// https://github.com/pytorch/extension-cpp/issues/58
+// https://github.com/mpark/variant/issues/77
+#if __has_builtin(__type_pack_element) && !defined(__CUDACC__)
+#define C10_MPARK_TYPE_PACK_ELEMENT
+#endif
+
+#if defined(__cpp_constexpr) && __cpp_constexpr >= 200704 && \
+    !(defined(__GNUC__) && __GNUC__ == 4 && __GNUC_MINOR__ == 9)
+#define C10_MPARK_CPP11_CONSTEXPR
+#endif
+
+#if defined(__cpp_constexpr) && __cpp_constexpr >= 201304
+#define C10_MPARK_CPP14_CONSTEXPR
+#endif
+
+#if __has_feature(cxx_exceptions) || defined(__cpp_exceptions) || \
+    (defined(_MSC_VER) && defined(_CPPUNWIND))
+#define C10_MPARK_EXCEPTIONS
+#endif
+
+#if defined(__cpp_generic_lambdas) || defined(_MSC_VER)
+#define C10_MPARK_GENERIC_LAMBDAS
+#endif
+
+#if defined(__cpp_lib_integer_sequence)
+#define C10_MPARK_INTEGER_SEQUENCE
+#endif
+
+#if defined(__cpp_return_type_deduction) || defined(_MSC_VER)
+#define C10_MPARK_RETURN_TYPE_DEDUCTION
+#endif
+
+#if defined(__cpp_lib_transparent_operators) || defined(_MSC_VER)
+#define C10_MPARK_TRANSPARENT_OPERATORS
+#endif
+
+#if defined(__cpp_variable_templates) || defined(_MSC_VER)
+#define C10_MPARK_VARIABLE_TEMPLATES
+#endif
+
+#if !defined(__GLIBCXX__) || __has_include(<codecvt>) // >= libstdc++-5
+#define C10_MPARK_TRIVIALITY_TYPE_TRAITS
+#define C10_MPARK_INCOMPLETE_TYPE_TRAITS
+#endif
+
+#ifdef _WIN32
+#define C10_MPARK_VISIBILITY_HIDDEN
+#else
+#define C10_MPARK_VISIBILITY_HIDDEN __attribute__((visibility("hidden")))
+#endif
+
+#endif // C10_MPARK_CONFIG_HPP
+
+// MPark.Variant
+//
+// Copyright Michael Park, 2015-2017
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE.md or copy at
+// http://boost.org/LICENSE_1_0.txt)
+
+#ifndef C10_MPARK_IN_PLACE_HPP
+#define C10_MPARK_IN_PLACE_HPP
+
+#include <c10/util/in_place.h>
+
+#include <cstddef>
+
+namespace c10 {
+
+#ifdef C10_MPARK_VARIABLE_TEMPLATES
+template <std::size_t I>
+constexpr in_place_index_t<I> in_place_index{};
+
+template <typename T>
+constexpr in_place_type_t<T> in_place_type{};
+#endif
+
+} // namespace c10
+
+#endif // C10_MPARK_IN_PLACE_HPP
+
+// MPark.Variant
+//
+// Copyright Michael Park, 2015-2017
+//
+// Distributed under the Boost Software License, Version 1.0.
+// (See accompanying file LICENSE.md or copy at
+// http://boost.org/LICENSE_1_0.txt)
+
+#ifndef C10_MPARK_LIB_HPP
+#define C10_MPARK_LIB_HPP
+
+#include <functional>
+#include <memory>
+#include <type_traits>
+#include <utility>
+
+#define C10_MPARK_RETURN(...)                              \
+  noexcept(noexcept(__VA_ARGS__))->decltype(__VA_ARGS__) { \
+    return __VA_ARGS__;                                    \
+  }
+
+namespace c10 {
+namespace lib {
+template <typename T>
+struct identity {
+  using type = T;
+};
+
+inline namespace cpp14 {
+template <typename T, std::size_t N>
+struct array {
+  constexpr const T& operator[](std::size_t index) const {
+    return data[index];
+  }
+
+  T data[N == 0 ? 1 : N];
+};
+
+template <typename T>
+using add_pointer_t = typename std::add_pointer<T>::type;
+
+template <typename... Ts>
+using common_type_t = typename std::common_type<Ts...>::type;
+
+template <typename T>
+using decay_t = typename std::decay<T>::type;
+
+template <bool B, typename T = void>
+using enable_if_t = typename std::enable_if<B, T>::type;
+
+template <typename T>
+using remove_const_t = typename std::remove_const<T>::type;
+
+template <typename T>
+using remove_reference_t = typename std::remove_reference<T>::type;
+
+template <typename T>
+inline constexpr T&& forward(remove_reference_t<T>& t) noexcept {
+  return static_cast<T&&>(t);
+}
+
+template <typename T>
+inline constexpr T&& forward(remove_reference_t<T>&& t) noexcept {
+  static_assert(
+      !std::is_lvalue_reference<T>::value,
+      "can not forward an rvalue as an lvalue");
+  return static_cast<T&&>(t);
+}
+
+template <typename T>
+inline constexpr remove_reference_t<T>&& move(T&& t) noexcept {
+  return static_cast<remove_reference_t<T>&&>(t);
+}
+
+#ifdef C10_MPARK_INTEGER_SEQUENCE
+using std::index_sequence;
+using std::index_sequence_for;
+using std::integer_sequence;
+using std::make_index_sequence;
+#else
+template <typename T, T... Is>
+struct integer_sequence {
+  using value_type = T;
+  static constexpr std::size_t size() noexcept {
+    return sizeof...(Is);
+  }
+};
+
+template <std::size_t... Is>
+using index_sequence = integer_sequence<std::size_t, Is...>;
+
+template <typename Lhs, typename Rhs>
+struct make_index_sequence_concat;
+
+template <std::size_t... Lhs, std::size_t... Rhs>
+struct make_index_sequence_concat<
+    index_sequence<Lhs...>,
+    index_sequence<Rhs...>>
+    : identity<index_sequence<Lhs..., (sizeof...(Lhs) + Rhs)...>> {};
+
+template <std::size_t N>
+struct make_index_sequence_impl;
+
+template <std::size_t N>
+using make_index_sequence = typename make_index_sequence_impl<N>::type;
+
+template <std::size_t N>
+struct make_index_sequence_impl : make_index_sequence_concat<
+                                      make_index_sequence<N / 2>,
+                                      make_index_sequence<N - (N / 2)>> {};
+
+template <>
+struct make_index_sequence_impl<0> : identity<index_sequence<>> {};
+
+template <>
+struct make_index_sequence_impl<1> : identity<index_sequence<0>> {};
+
+template <typename... Ts>
+using index_sequence_for = make_index_sequence<sizeof...(Ts)>;
+#endif
+
+// <functional>
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using equal_to = std::equal_to<>;
+#else
+struct equal_to {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) == lib::forward<Rhs>(rhs))
+};
+#endif
+
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using not_equal_to = std::not_equal_to<>;
+#else
+struct not_equal_to {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) != lib::forward<Rhs>(rhs))
+};
+#endif
+
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using less = std::less<>;
+#else
+struct less {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) < lib::forward<Rhs>(rhs))
+};
+#endif
+
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using greater = std::greater<>;
+#else
+struct greater {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) > lib::forward<Rhs>(rhs))
+};
+#endif
+
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using less_equal = std::less_equal<>;
+#else
+struct less_equal {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) <= lib::forward<Rhs>(rhs))
+};
+#endif
+
+#ifdef C10_MPARK_TRANSPARENT_OPERATORS
+using greater_equal = std::greater_equal<>;
+#else
+struct greater_equal {
+  template <typename Lhs, typename Rhs>
+  inline constexpr auto operator()(Lhs&& lhs, Rhs&& rhs) const
+      C10_MPARK_RETURN(lib::forward<Lhs>(lhs) >= lib::forward<Rhs>(rhs))
+};
+#endif
+} // namespace cpp14
+
+inline namespace cpp17 {
+
+// <type_traits>
+template <bool B>
+using bool_constant = std::integral_constant<bool, B>;
+
+template <typename...>
+struct voider : identity<void> {};
+
+template <typename... Ts>
+using void_t = typename voider<Ts...>::type;
+
+namespace detail_ {
+namespace swappable {
+
+using std::swap;
+
+template <typename T>
+struct is_swappable {
+ private:
+  template <
+      typename U,
+      typename = decltype(swap(std::declval<U&>(), std::declval<U&>()))>
+  inline static std::true_type test(int);
+
+  template <typename U>
+  inline static std::false_type test(...);
+
+ public:
+  static constexpr bool value = decltype(test<T>(0))::value;
+};
+
+template <bool IsSwappable, typename T>
+struct is_nothrow_swappable {
+  static constexpr bool value =
+      noexcept(swap(std::declval<T&>(), std::declval<T&>()));
+};
+
+template <typename T>
+struct is_nothrow_swappable<false, T> : std::false_type {};
+
+} // namespace swappable
+} // namespace detail_
+
+using detail_::swappable::is_swappable;
+
+template <typename T>
+using is_nothrow_swappable =
+    detail_::swappable::is_nothrow_swappable<is_swappable<T>::value, T>;
+
+// <functional>
+namespace detail_ {
+
+template <typename T>
+struct is_reference_wrapper : std::false_type {};
+
+template <typename T>
+struct is_reference_wrapper<std::reference_wrapper<T>> : std::true_type {};
+
+template <bool, int>
+struct Invoke;
+
+template <>
+struct Invoke<true /* pmf */, 0 /* is_base_of */> {
+  template <typename R, typename T, typename Arg, typename... Args>
+  inline static constexpr auto invoke(R T::*pmf, Arg&& arg, Args&&... args)
+      C10_MPARK_RETURN(
+          (lib::forward<Arg>(arg).*pmf)(lib::forward<Args>(args)...))
+};
+
+template <>
+struct Invoke<true /* pmf */, 1 /* is_reference_wrapper */> {
+  template <typename R, typename T, typename Arg, typename... Args>
+  inline static constexpr auto invoke(R T::*pmf, Arg&& arg, Args&&... args)
+      C10_MPARK_RETURN(
+          (lib::forward<Arg>(arg).get().*pmf)(lib::forward<Args>(args)...))
+};
+
+template <>
+struct Invoke<true /* pmf */, 2 /* otherwise */> {
+  template <typename R, typename T, typename Arg, typename... Args>
+  inline static constexpr auto invoke(R T::*pmf, Arg&& arg, Args&&... args)
+      C10_MPARK_RETURN(
+          ((*lib::forward<Arg>(arg)).*pmf)(lib::forward<Args>(args)...))
+};
+
+template <>
+struct Invoke<false /* pmo */, 0 /* is_base_of */> {
+  template <typename R, typename T, typename Arg>
+  inline static constexpr auto invoke(R T::*pmo, Arg&& arg)
+      C10_MPARK_RETURN(lib::forward<Arg>(arg).*pmo)
+};
+
+template <>
+struct Invoke<false /* pmo */, 1 /* is_reference_wrapper */> {
+  template <typename R, typename T, typename Arg>
+  inline static constexpr auto invoke(R T::*pmo, Arg&& arg)
+      C10_MPARK_RETURN(lib::forward<Arg>(arg).get().*pmo)
+};
+
+template <>
+struct Invoke<false /* pmo */, 2 /* otherwise */> {
+  template <typename R, typename T, typename Arg>
+  inline static constexpr auto invoke(R T::*pmo, Arg&& arg)
+      C10_MPARK_RETURN((*lib::forward<Arg>(arg)).*pmo)
+};
+
+template <typename R, typename T, typename Arg, typename... Args>
+inline constexpr auto invoke(R T::*f, Arg&& arg, Args&&... args)
+    C10_MPARK_RETURN(
+        Invoke<
+            std::is_function<R>::value,
+            (std::is_base_of<T, lib::decay_t<Arg>>::value         ? 0
+                 : is_reference_wrapper<lib::decay_t<Arg>>::value ? 1
+                                                                  : 2)>::
+            invoke(f, lib::forward<Arg>(arg), lib::forward<Args>(args)...))
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4100)
+#endif
+        template <typename F, typename... Args>
+        inline constexpr auto invoke(F&& f, Args&&... args)
+            C10_MPARK_RETURN(lib::forward<F>(f)(lib::forward<Args>(args)...))
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+} // namespace detail_
+
+template <typename F, typename... Args>
+inline constexpr auto invoke(F&& f, Args&&... args) C10_MPARK_RETURN(
+    detail_::invoke(lib::forward<F>(f), lib::forward<Args>(args)...))
+
+    namespace detail_ {
+  template <typename Void, typename, typename...>
+  struct invoke_result {};
+
+  template <typename F, typename... Args>
+  struct invoke_result<
+      void_t<decltype(lib::invoke(std::declval<F>(), std::declval<Args>()...))>,
+      F,
+      Args...>
+      : identity<decltype(lib::invoke(
+            std::declval<F>(), std::declval<Args>()...))> {};
+
+} // namespace detail_
+
+template <typename F, typename... Args>
+using invoke_result = detail_::invoke_result<void, F, Args...>;
+
+template <typename F, typename... Args>
+using invoke_result_t = typename invoke_result<F, Args...>::type;
+
+namespace detail_ {
+
+template <typename Void, typename, typename...>
+struct is_invocable : std::false_type {};
+
+template <typename F, typename... Args>
+struct is_invocable<void_t<invoke_result_t<F, Args...>>, F, Args...>
+    : std::true_type {};
+
+template <typename Void, typename, typename, typename...>
+struct is_invocable_r : std::false_type {};
+
+template <typename R, typename F, typename... Args>
+struct is_invocable_r<void_t<invoke_result_t<F, Args...>>, R, F, Args...>
+    : std::is_convertible<invoke_result_t<F, Args...>, R> {};
+
+} // namespace detail_
+
+template <typename F, typename... Args>
+using is_invocable = detail_::is_invocable<void, F, Args...>;
+
+template <typename R, typename F, typename... Args>
+using is_invocable_r = detail_::is_invocable_r<void, R, F, Args...>;
+
+namespace detail_ {
+
+template <bool Invocable, typename F, typename... Args>
+struct is_nothrow_invocable {
+  static constexpr bool value =
+      noexcept(lib::invoke(std::declval<F>(), std::declval<Args>()...));
+};
+
+template <typename F, typename... Args>
+struct is_nothrow_invocable<false, F, Args...> : std::false_type {};
+
+template <bool Invocable, typename R, typename F, typename... Args>
+struct is_nothrow_invocable_r {
+ private:
+  inline static R impl() {
+    return lib::invoke(std::declval<F>(), std::declval<Args>()...);
+  }
+
+ public:
+  static constexpr bool value = noexcept(impl());
+};
+
+template <typename R, typename F, typename... Args>
+struct is_nothrow_invocable_r<false, R, F, Args...> : std::false_type {};
+
+} // namespace detail_
+
+template <typename F, typename... Args>
+using is_nothrow_invocable =
+    detail_::is_nothrow_invocable<is_invocable<F, Args...>::value, F, Args...>;
+
+template <typename R, typename F, typename... Args>
+using is_nothrow_invocable_r = detail_::
+    is_nothrow_invocable_r<is_invocable_r<R, F, Args...>::value, R, F, Args...>;
+
+// <memory>
+#ifdef C10_MPARK_BUILTIN_ADDRESSOF
+template <typename T>
+inline constexpr T* addressof(T& arg) noexcept {
+  return __builtin_addressof(arg);
+}
+#else
+namespace detail_ {
+
+namespace has_addressof_impl {
+
+struct fail;
+
+template <typename T>
+inline fail operator&(T&&);
+
+template <typename T>
+inline static constexpr bool impl() {
+  return (std::is_class<T>::value || std::is_union<T>::value) &&
+      !std::is_same<decltype(&std::declval<T&>()), fail>::value;
+}
+
+} // namespace has_addressof_impl
+
+template <typename T>
+using has_addressof = bool_constant<has_addressof_impl::impl<T>()>;
+
+template <typename T>
+inline constexpr T* addressof(T& arg, std::true_type) noexcept {
+  return std::addressof(arg);
+}
+
+template <typename T>
+inline constexpr T* addressof(T& arg, std::false_type) noexcept {
+  return &arg;
+}
+
+} // namespace detail_
+
+template <typename T>
+inline constexpr T* addressof(T& arg) noexcept {
+  return detail_::addressof(arg, detail_::has_addressof<T>{});
+}
+#endif
+
+template <typename T>
+inline constexpr T* addressof(const T&&) = delete;
+
+} // namespace cpp17
+
+template <typename T>
+struct remove_all_extents : identity<T> {};
+
+template <typename T, std::size_t N>
+struct remove_all_extents<array<T, N>> : remove_all_extents<T> {};
+
+template <typename T>
+using remove_all_extents_t = typename remove_all_extents<T>::type;
+
+template <std::size_t N>
+using size_constant = std::integral_constant<std::size_t, N>;
+
+template <std::size_t I, typename T>
+struct indexed_type : size_constant<I> {
+  using type = T;
+};
+
+template <bool... Bs>
+using all = std::is_same<
+    integer_sequence<bool, true, Bs...>,
+    integer_sequence<bool, Bs..., true>>;
+
+#ifdef C10_MPARK_TYPE_PACK_ELEMENT
+template <std::size_t I, typename... Ts>
+using type_pack_element_t = __type_pack_element<I, Ts...>;
+#else
+template <std::size_t I, typename... Ts>
+struct type_pack_element_impl {
+ private:
+  template <typename>
+  struct set;
+
+  template <std::size_t... Is>
+  struct set<index_sequence<Is...>> : indexed_type<Is, Ts>... {};
+
+  template <typename T>
+  inline static std::enable_if<true, T> impl(indexed_type<I, T>);
+
+  inline static std::enable_if<false> impl(...);
+
+ public:
+  using type = decltype(impl(set<index_sequence_for<Ts...>>{}));
+};
+
+template <std::size_t I, typename... Ts>
+using type_pack_element = typename type_pack_element_impl<I, Ts...>::type;
+
+template <std::size_t I, typename... Ts>
+using type_pack_element_t = typename type_pack_element<I, Ts...>::type;
+#endif
+
+#ifdef C10_MPARK_TRIVIALITY_TYPE_TRAITS
+using std::is_trivially_copy_assignable;
+using std::is_trivially_copy_constructible;
+using std::is_trivially_move_assignable;
+using std::is_trivially_move_constructible;
+#else
+template <typename T>
+struct is_trivially_copy_constructible
+    : bool_constant<std::is_copy_constructible<T>::value&& __has_trivial_copy(
+          T)> {};
+
+template <typename T>
+struct is_trivially_move_constructible : bool_constant<__is_trivial(T)> {};
+
+template <typename T>
+struct is_trivially_copy_assignable
+    : bool_constant<std::is_copy_assignable<T>::value&& __has_trivial_assign(
+          T)> {};
+
+template <typename T>
+struct is_trivially_move_assignable : bool_constant<__is_trivial(T)> {};
+#endif
+
+template <typename T, bool>
+struct dependent_type : T {};
+
+template <typename Is, std::size_t J>
+struct push_back;
+
+template <typename Is, std::size_t J>
+using push_back_t = typename push_back<Is, J>::type;
+
+template <std::size_t... Is, std::size_t J>
+struct push_back<index_sequence<Is...>, J> {
+  using type = index_sequence<Is..., J>;
+};
+
+} // namespace lib
+} // namespace c10
+
+#undef C10_MPARK_RETURN
+
+#endif // C10_MPARK_LIB_HPP
+
+namespace c10 {
+
+#ifdef C10_MPARK_RETURN_TYPE_DEDUCTION
+
+#define AUTO auto
+#define AUTO_RETURN(...) \
+  { return __VA_ARGS__; }
+
+#define AUTO_REFREF auto&&
+#define AUTO_REFREF_RETURN(...) \
+  { return __VA_ARGS__; }
+
+#define DECLTYPE_AUTO decltype(auto)
+#define DECLTYPE_AUTO_RETURN(...) \
+  { return __VA_ARGS__; }
+
+#else
+
+#define AUTO auto
+#define AUTO_RETURN(...)                  \
+  ->lib::decay_t<decltype(__VA_ARGS__)> { \
+    return __VA_ARGS__;                   \
+  }
+
+#define AUTO_REFREF auto
+#define AUTO_REFREF_RETURN(...)                                           \
+  ->decltype((__VA_ARGS__)) {                                             \
+    static_assert(std::is_reference<decltype((__VA_ARGS__))>::value, ""); \
+    return __VA_ARGS__;                                                   \
+  }
+
+#define DECLTYPE_AUTO auto
+#define DECLTYPE_AUTO_RETURN(...) \
+  ->decltype(__VA_ARGS__) {       \
+    return __VA_ARGS__;           \
+  }
+
+#endif
+
+class bad_variant_access : public std::exception {
+ public:
+  const char* what() const noexcept override {
+    return "bad_variant_access";
+  }
+};
+
+[[noreturn]] inline void throw_bad_variant_access() {
+#ifdef C10_MPARK_EXCEPTIONS
+  throw bad_variant_access{};
+#else
+  std::terminate();
+  C10_MPARK_BUILTIN_UNREACHABLE;
+#endif
+}
+
+template <typename... Ts>
+class variant;
+
+template <typename T>
+struct variant_size;
+
+#ifdef C10_MPARK_VARIABLE_TEMPLATES
+template <typename T>
+constexpr std::size_t variant_size_v = variant_size<T>::value;
+#endif
+
+template <typename T>
+struct variant_size<const T> : variant_size<T> {};
+
+template <typename T>
+struct variant_size<volatile T> : variant_size<T> {};
+
+template <typename T>
+struct variant_size<const volatile T> : variant_size<T> {};
+
+template <typename... Ts>
+struct variant_size<variant<Ts...>> : lib::size_constant<sizeof...(Ts)> {};
+
+template <std::size_t I, typename T>
+struct variant_alternative;
+
+template <std::size_t I, typename T>
+using variant_alternative_t = typename variant_alternative<I, T>::type;
+
+template <std::size_t I, typename T>
+struct variant_alternative<I, const T>
+    : std::add_const<variant_alternative_t<I, T>> {};
+
+template <std::size_t I, typename T>
+struct variant_alternative<I, volatile T>
+    : std::add_volatile<variant_alternative_t<I, T>> {};
+
+template <std::size_t I, typename T>
+struct variant_alternative<I, const volatile T>
+    : std::add_cv<variant_alternative_t<I, T>> {};
+
+template <std::size_t I, typename... Ts>
+struct variant_alternative<I, variant<Ts...>> {
+  static_assert(
+      I < sizeof...(Ts),
+      "index out of bounds in `std::variant_alternative<>`");
+  using type = lib::type_pack_element_t<I, Ts...>;
+};
+
+constexpr std::size_t variant_npos = static_cast<std::size_t>(-1);
+
+namespace detail_ {
+
+constexpr std::size_t not_found = static_cast<std::size_t>(-1);
+constexpr std::size_t ambiguous = static_cast<std::size_t>(-2);
+
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+template <typename T, typename... Ts>
+inline constexpr std::size_t find_index() {
+  constexpr lib::array<bool, sizeof...(Ts)> matches = {
+      {std::is_same<T, Ts>::value...}};
+  std::size_t result = not_found;
+  for (std::size_t i = 0; i < sizeof...(Ts); ++i) {
+    if (matches[i]) {
+      if (result != not_found) {
+        return ambiguous;
+      }
+      result = i;
+    }
+  }
+  return result;
+}
+#else
+inline constexpr std::size_t find_index_impl(std::size_t result, std::size_t) {
+  return result;
+}
+
+template <typename... Bs>
+inline constexpr std::size_t find_index_impl(
+    std::size_t result,
+    std::size_t idx,
+    bool b,
+    Bs... bs) {
+  return b
+      ? (result != not_found ? ambiguous : find_index_impl(idx, idx + 1, bs...))
+      : find_index_impl(result, idx + 1, bs...);
+}
+
+template <typename T, typename... Ts>
+inline constexpr std::size_t find_index() {
+  return find_index_impl(not_found, 0, std::is_same<T, Ts>::value...);
+}
+#endif
+
+template <std::size_t I>
+using find_index_sfinae_impl =
+    lib::enable_if_t<I != not_found && I != ambiguous, lib::size_constant<I>>;
+
+template <typename T, typename... Ts>
+using find_index_sfinae = find_index_sfinae_impl<find_index<T, Ts...>()>;
+
+template <std::size_t I>
+struct find_index_checked_impl : lib::size_constant<I> {
+  static_assert(I != not_found, "the specified type is not found.");
+  static_assert(I != ambiguous, "the specified type is ambiguous.");
+};
+
+template <typename T, typename... Ts>
+using find_index_checked = find_index_checked_impl<find_index<T, Ts...>()>;
+
+struct valueless_t {};
+
+enum class Trait { TriviallyAvailable, Available, Unavailable };
+
+template <
+    typename T,
+    template <typename>
+    class IsTriviallyAvailable,
+    template <typename>
+    class IsAvailable>
+inline constexpr Trait trait() {
+  return IsTriviallyAvailable<T>::value ? Trait::TriviallyAvailable
+      : IsAvailable<T>::value           ? Trait::Available
+                                        : Trait::Unavailable;
+}
+
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+template <typename... Traits>
+inline constexpr Trait common_trait(Traits... traits_) {
+  Trait result = Trait::TriviallyAvailable;
+  lib::array<Trait, sizeof...(Traits)> traits = {{traits_...}};
+  for (std::size_t i = 0; i < sizeof...(Traits); ++i) {
+    Trait t = traits[i];
+    if (static_cast<int>(t) > static_cast<int>(result)) {
+      result = t;
+    }
+  }
+  return result;
+}
+#else
+inline constexpr Trait common_trait_impl(Trait result) {
+  return result;
+}
+
+template <typename... Traits>
+inline constexpr Trait common_trait_impl(Trait result, Trait t, Traits... ts) {
+  return static_cast<int>(t) > static_cast<int>(result)
+      ? common_trait_impl(t, ts...)
+      : common_trait_impl(result, ts...);
+}
+
+template <typename... Traits>
+inline constexpr Trait common_trait(Traits... ts) {
+  return common_trait_impl(Trait::TriviallyAvailable, ts...);
+}
+#endif
+
+template <typename... Ts>
+struct traits {
+  static constexpr Trait copy_constructible_trait =
+      common_trait(trait<
+                   Ts,
+                   lib::is_trivially_copy_constructible,
+                   std::is_copy_constructible>()...);
+
+  static constexpr Trait move_constructible_trait =
+      common_trait(trait<
+                   Ts,
+                   lib::is_trivially_move_constructible,
+                   std::is_move_constructible>()...);
+
+  static constexpr Trait copy_assignable_trait = common_trait(
+      copy_constructible_trait,
+      trait<
+          Ts,
+          lib::is_trivially_copy_assignable,
+          std::is_copy_assignable>()...);
+
+  static constexpr Trait move_assignable_trait = common_trait(
+      move_constructible_trait,
+      trait<
+          Ts,
+          lib::is_trivially_move_assignable,
+          std::is_move_assignable>()...);
+
+  static constexpr Trait destructible_trait = common_trait(
+      trait<Ts, std::is_trivially_destructible, std::is_destructible>()...);
+};
+
+namespace access {
+
+struct recursive_union {
+#ifdef C10_MPARK_RETURN_TYPE_DEDUCTION
+  template <typename V>
+  inline static constexpr auto&& get_alt(V&& v, in_place_index_t<0>) {
+    return lib::forward<V>(v).head_;
+  }
+
+  template <typename V, std::size_t I>
+  inline static constexpr auto&& get_alt(V&& v, in_place_index_t<I>) {
+    return get_alt(lib::forward<V>(v).tail_, in_place_index_t<I - 1>{});
+  }
+#else
+  template <std::size_t I, bool Dummy = true>
+  struct get_alt_impl {
+    template <typename V>
+    inline constexpr AUTO_REFREF operator()(V&& v) const
+        AUTO_REFREF_RETURN(get_alt_impl<I - 1>{}(lib::forward<V>(v).tail_))
+  };
+
+  template <bool Dummy>
+  struct get_alt_impl<0, Dummy> {
+    template <typename V>
+    inline constexpr AUTO_REFREF operator()(V&& v) const
+        AUTO_REFREF_RETURN(lib::forward<V>(v).head_)
+  };
+
+  template <typename V, std::size_t I>
+  inline static constexpr AUTO_REFREF get_alt(V&& v, in_place_index_t<I>)
+      AUTO_REFREF_RETURN(get_alt_impl<I>{}(lib::forward<V>(v)))
+#endif
+};
+
+struct base {
+  template <std::size_t I, typename V>
+  inline static constexpr AUTO_REFREF get_alt(V&& v)
+#ifdef _MSC_VER
+      AUTO_REFREF_RETURN(recursive_union::get_alt(
+          lib::forward<V>(v).data_,
+          in_place_index_t<I>{}))
+#else
+      AUTO_REFREF_RETURN(recursive_union::get_alt(
+          data(lib::forward<V>(v)),
+          in_place_index_t<I>{}))
+#endif
+};
+
+struct variant {
+  template <std::size_t I, typename V>
+  inline static constexpr AUTO_REFREF get_alt(V&& v)
+      AUTO_REFREF_RETURN(base::get_alt<I>(lib::forward<V>(v).impl_))
+};
+
+} // namespace access
+
+namespace visitation {
+
+#if defined(C10_MPARK_CPP14_CONSTEXPR) && !defined(_MSC_VER)
+#define C10_MPARK_VARIANT_SWITCH_VISIT
+#endif
+
+struct base {
+  template <typename Visitor, typename... Vs>
+  using dispatch_result_t = decltype(lib::invoke(
+      std::declval<Visitor>(),
+      access::base::get_alt<0>(std::declval<Vs>())...));
+
+  template <typename Expected>
+  struct expected {
+    template <typename Actual>
+    inline static constexpr bool but_got() {
+      return std::is_same<Expected, Actual>::value;
+    }
+  };
+
+  template <typename Expected, typename Actual>
+  struct visit_return_type_check {
+    static_assert(
+        expected<Expected>::template but_got<Actual>(),
+        "`visit` requires the visitor to have a single return type");
+
+    template <typename Visitor, typename... Alts>
+    inline static constexpr DECLTYPE_AUTO invoke(
+        Visitor&& visitor,
+        Alts&&... alts)
+        DECLTYPE_AUTO_RETURN(lib::invoke(
+            lib::forward<Visitor>(visitor),
+            lib::forward<Alts>(alts)...))
+  };
+
+#ifdef C10_MPARK_VARIANT_SWITCH_VISIT
+  template <bool B, typename R, typename... ITs>
+  struct dispatcher;
+
+  template <typename R, typename... ITs>
+  struct dispatcher<false, R, ITs...> {
+    template <std::size_t B, typename F, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch(
+        F&&,
+        typename ITs::type&&...,
+        Vs&&...) {
+      C10_MPARK_BUILTIN_UNREACHABLE;
+    }
+
+    template <std::size_t I, typename F, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch_case(F&&, Vs&&...) {
+      C10_MPARK_BUILTIN_UNREACHABLE;
+    }
+
+    template <std::size_t B, typename F, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch_at(
+        std::size_t,
+        F&&,
+        Vs&&...) {
+      C10_MPARK_BUILTIN_UNREACHABLE;
+    }
+  };
+
+  template <typename R, typename... ITs>
+  struct dispatcher<true, R, ITs...> {
+    template <std::size_t B, typename F>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch(
+        F&& f,
+        typename ITs::type&&... visited_vs) {
+      using Expected = R;
+      using Actual = decltype(lib::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<ITs::value>(
+              lib::forward<typename ITs::type>(visited_vs))...));
+      return visit_return_type_check<Expected, Actual>::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<ITs::value>(
+              lib::forward<typename ITs::type>(visited_vs))...);
+    }
+
+    template <std::size_t B, typename F, typename V, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch(
+        F&& f,
+        typename ITs::type&&... visited_vs,
+        V&& v,
+        Vs&&... vs) {
+#define C10_MPARK_DISPATCH(I)                              \
+  dispatcher<                                              \
+      (I < lib::decay_t<V>::size()),                       \
+      R,                                                   \
+      ITs...,                                              \
+      lib::indexed_type<I, V>>::                           \
+      template dispatch<0>(                                \
+          lib::forward<F>(f),                              \
+          lib::forward<typename ITs::type>(visited_vs)..., \
+          lib::forward<V>(v),                              \
+          lib::forward<Vs>(vs)...)
+
+#define C10_MPARK_DEFAULT(I)                                                  \
+  dispatcher<(I < lib::decay_t<V>::size()), R, ITs...>::template dispatch<I>( \
+      lib::forward<F>(f),                                                     \
+      lib::forward<typename ITs::type>(visited_vs)...,                        \
+      lib::forward<V>(v),                                                     \
+      lib::forward<Vs>(vs)...)
+
+      switch (v.index()) {
+        case B + 0:
+          return C10_MPARK_DISPATCH(B + 0);
+        case B + 1:
+          return C10_MPARK_DISPATCH(B + 1);
+        case B + 2:
+          return C10_MPARK_DISPATCH(B + 2);
+        case B + 3:
+          return C10_MPARK_DISPATCH(B + 3);
+        case B + 4:
+          return C10_MPARK_DISPATCH(B + 4);
+        case B + 5:
+          return C10_MPARK_DISPATCH(B + 5);
+        case B + 6:
+          return C10_MPARK_DISPATCH(B + 6);
+        case B + 7:
+          return C10_MPARK_DISPATCH(B + 7);
+        case B + 8:
+          return C10_MPARK_DISPATCH(B + 8);
+        case B + 9:
+          return C10_MPARK_DISPATCH(B + 9);
+        case B + 10:
+          return C10_MPARK_DISPATCH(B + 10);
+        case B + 11:
+          return C10_MPARK_DISPATCH(B + 11);
+        case B + 12:
+          return C10_MPARK_DISPATCH(B + 12);
+        case B + 13:
+          return C10_MPARK_DISPATCH(B + 13);
+        case B + 14:
+          return C10_MPARK_DISPATCH(B + 14);
+        case B + 15:
+          return C10_MPARK_DISPATCH(B + 15);
+        case B + 16:
+          return C10_MPARK_DISPATCH(B + 16);
+        case B + 17:
+          return C10_MPARK_DISPATCH(B + 17);
+        case B + 18:
+          return C10_MPARK_DISPATCH(B + 18);
+        case B + 19:
+          return C10_MPARK_DISPATCH(B + 19);
+        case B + 20:
+          return C10_MPARK_DISPATCH(B + 20);
+        case B + 21:
+          return C10_MPARK_DISPATCH(B + 21);
+        case B + 22:
+          return C10_MPARK_DISPATCH(B + 22);
+        case B + 23:
+          return C10_MPARK_DISPATCH(B + 23);
+        case B + 24:
+          return C10_MPARK_DISPATCH(B + 24);
+        case B + 25:
+          return C10_MPARK_DISPATCH(B + 25);
+        case B + 26:
+          return C10_MPARK_DISPATCH(B + 26);
+        case B + 27:
+          return C10_MPARK_DISPATCH(B + 27);
+        case B + 28:
+          return C10_MPARK_DISPATCH(B + 28);
+        case B + 29:
+          return C10_MPARK_DISPATCH(B + 29);
+        case B + 30:
+          return C10_MPARK_DISPATCH(B + 30);
+        case B + 31:
+          return C10_MPARK_DISPATCH(B + 31);
+        default:
+          return C10_MPARK_DEFAULT(B + 32);
+      }
+
+#undef C10_MPARK_DEFAULT
+#undef C10_MPARK_DISPATCH
+    }
+
+    template <std::size_t I, typename F, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch_case(
+        F&& f,
+        Vs&&... vs) {
+      using Expected = R;
+      using Actual = decltype(lib::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<I>(lib::forward<Vs>(vs))...));
+      return visit_return_type_check<Expected, Actual>::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<I>(lib::forward<Vs>(vs))...);
+    }
+
+    template <std::size_t B, typename F, typename V, typename... Vs>
+    C10_MPARK_ALWAYS_INLINE static constexpr R dispatch_at(
+        std::size_t index,
+        F&& f,
+        V&& v,
+        Vs&&... vs) {
+      static_assert(
+          lib::all<(
+              lib::decay_t<V>::size() == lib::decay_t<Vs>::size())...>::value,
+          "all of the variants must be the same size.");
+#define C10_MPARK_DISPATCH_AT(I)                                           \
+  dispatcher<(I < lib::decay_t<V>::size()), R>::template dispatch_case<I>( \
+      lib::forward<F>(f), lib::forward<V>(v), lib::forward<Vs>(vs)...)
+
+#define C10_MPARK_DEFAULT(I)                                             \
+  dispatcher<(I < lib::decay_t<V>::size()), R>::template dispatch_at<I>( \
+      index, lib::forward<F>(f), lib::forward<V>(v), lib::forward<Vs>(vs)...)
+
+      switch (index) {
+        case B + 0:
+          return C10_MPARK_DISPATCH_AT(B + 0);
+        case B + 1:
+          return C10_MPARK_DISPATCH_AT(B + 1);
+        case B + 2:
+          return C10_MPARK_DISPATCH_AT(B + 2);
+        case B + 3:
+          return C10_MPARK_DISPATCH_AT(B + 3);
+        case B + 4:
+          return C10_MPARK_DISPATCH_AT(B + 4);
+        case B + 5:
+          return C10_MPARK_DISPATCH_AT(B + 5);
+        case B + 6:
+          return C10_MPARK_DISPATCH_AT(B + 6);
+        case B + 7:
+          return C10_MPARK_DISPATCH_AT(B + 7);
+        case B + 8:
+          return C10_MPARK_DISPATCH_AT(B + 8);
+        case B + 9:
+          return C10_MPARK_DISPATCH_AT(B + 9);
+        case B + 10:
+          return C10_MPARK_DISPATCH_AT(B + 10);
+        case B + 11:
+          return C10_MPARK_DISPATCH_AT(B + 11);
+        case B + 12:
+          return C10_MPARK_DISPATCH_AT(B + 12);
+        case B + 13:
+          return C10_MPARK_DISPATCH_AT(B + 13);
+        case B + 14:
+          return C10_MPARK_DISPATCH_AT(B + 14);
+        case B + 15:
+          return C10_MPARK_DISPATCH_AT(B + 15);
+        case B + 16:
+          return C10_MPARK_DISPATCH_AT(B + 16);
+        case B + 17:
+          return C10_MPARK_DISPATCH_AT(B + 17);
+        case B + 18:
+          return C10_MPARK_DISPATCH_AT(B + 18);
+        case B + 19:
+          return C10_MPARK_DISPATCH_AT(B + 19);
+        case B + 20:
+          return C10_MPARK_DISPATCH_AT(B + 20);
+        case B + 21:
+          return C10_MPARK_DISPATCH_AT(B + 21);
+        case B + 22:
+          return C10_MPARK_DISPATCH_AT(B + 22);
+        case B + 23:
+          return C10_MPARK_DISPATCH_AT(B + 23);
+        case B + 24:
+          return C10_MPARK_DISPATCH_AT(B + 24);
+        case B + 25:
+          return C10_MPARK_DISPATCH_AT(B + 25);
+        case B + 26:
+          return C10_MPARK_DISPATCH_AT(B + 26);
+        case B + 27:
+          return C10_MPARK_DISPATCH_AT(B + 27);
+        case B + 28:
+          return C10_MPARK_DISPATCH_AT(B + 28);
+        case B + 29:
+          return C10_MPARK_DISPATCH_AT(B + 29);
+        case B + 30:
+          return C10_MPARK_DISPATCH_AT(B + 30);
+        case B + 31:
+          return C10_MPARK_DISPATCH_AT(B + 31);
+        default:
+          return C10_MPARK_DEFAULT(B + 32);
+      }
+
+#undef C10_MPARK_DEFAULT
+#undef C10_MPARK_DISPATCH_AT
+    }
+  };
+#else
+  template <typename T>
+  inline static constexpr const T& at(const T& elem) noexcept {
+    return elem;
+  }
+
+  template <typename T, std::size_t N, typename... Is>
+  inline static constexpr const lib::remove_all_extents_t<T>& at(
+      const lib::array<T, N>& elems,
+      std::size_t i,
+      Is... is) noexcept {
+    return at(elems[i], is...);
+  }
+
+  template <typename F, typename... Fs>
+  inline static constexpr lib::array<lib::decay_t<F>, sizeof...(Fs) + 1>
+  make_farray(F&& f, Fs&&... fs) {
+    return {{lib::forward<F>(f), lib::forward<Fs>(fs)...}};
+  }
+
+  template <typename F, typename... Vs>
+  struct make_fmatrix_impl {
+    template <std::size_t... Is>
+    inline static constexpr dispatch_result_t<F, Vs...> dispatch(
+        F&& f,
+        Vs&&... vs) {
+      using Expected = dispatch_result_t<F, Vs...>;
+      using Actual = decltype(lib::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<Is>(lib::forward<Vs>(vs))...));
+      return visit_return_type_check<Expected, Actual>::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<Is>(lib::forward<Vs>(vs))...);
+    }
+
+#ifdef C10_MPARK_RETURN_TYPE_DEDUCTION
+    template <std::size_t... Is>
+    inline static constexpr auto impl(lib::index_sequence<Is...>) {
+      return &dispatch<Is...>;
+    }
+
+    template <typename Is, std::size_t... Js, typename... Ls>
+    inline static constexpr auto impl(
+        Is,
+        lib::index_sequence<Js...>,
+        Ls... ls) {
+      return make_farray(impl(lib::push_back_t<Is, Js>{}, ls...)...);
+    }
+#else
+    template <typename...>
+    struct impl;
+
+    template <std::size_t... Is>
+    struct impl<lib::index_sequence<Is...>> {
+      inline constexpr AUTO operator()() const AUTO_RETURN(&dispatch<Is...>)
+    };
+
+    template <typename Is, std::size_t... Js, typename... Ls>
+    struct impl<Is, lib::index_sequence<Js...>, Ls...> {
+      inline constexpr AUTO operator()() const
+          AUTO_RETURN(make_farray(impl<lib::push_back_t<Is, Js>, Ls...>{}()...))
+    };
+#endif
+  };
+
+#ifdef C10_MPARK_RETURN_TYPE_DEDUCTION
+  template <typename F, typename... Vs>
+  inline static constexpr auto make_fmatrix() {
+    return make_fmatrix_impl<F, Vs...>::impl(
+        lib::index_sequence<>{},
+        lib::make_index_sequence<lib::decay_t<Vs>::size()>{}...);
+  }
+#else
+  template <typename F, typename... Vs>
+  inline static constexpr AUTO make_fmatrix()
+      AUTO_RETURN(typename make_fmatrix_impl<F, Vs...>::template impl<
+                  lib::index_sequence<>,
+                  lib::make_index_sequence<lib::decay_t<Vs>::size()>...>{}())
+#endif
+
+  template <typename F, typename... Vs>
+  struct make_fdiagonal_impl {
+    template <std::size_t I>
+    inline static constexpr dispatch_result_t<F, Vs...> dispatch(
+        F&& f,
+        Vs&&... vs) {
+      using Expected = dispatch_result_t<F, Vs...>;
+      using Actual = decltype(lib::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<I>(lib::forward<Vs>(vs))...));
+      return visit_return_type_check<Expected, Actual>::invoke(
+          lib::forward<F>(f),
+          access::base::get_alt<I>(lib::forward<Vs>(vs))...);
+    }
+
+    template <std::size_t... Is>
+    inline static constexpr AUTO impl(lib::index_sequence<Is...>)
+        AUTO_RETURN(make_farray(&dispatch<Is>...))
+  };
+
+  template <typename F, typename V, typename... Vs>
+  inline static constexpr auto make_fdiagonal()
+      -> decltype(make_fdiagonal_impl<F, V, Vs...>::impl(
+          lib::make_index_sequence<lib::decay_t<V>::size()>{})) {
+    static_assert(
+        lib::all<(
+            lib::decay_t<V>::size() == lib::decay_t<Vs>::size())...>::value,
+        "all of the variants must be the same size.");
+    return make_fdiagonal_impl<F, V, Vs...>::impl(
+        lib::make_index_sequence<lib::decay_t<V>::size()>{});
+  }
+#endif
+};
+
+#if !defined(C10_MPARK_VARIANT_SWITCH_VISIT) && \
+    (!defined(_MSC_VER) || _MSC_VER >= 1910)
+template <typename F, typename... Vs>
+using fmatrix_t = decltype(base::make_fmatrix<F, Vs...>());
+
+template <typename F, typename... Vs>
+struct fmatrix {
+  static constexpr fmatrix_t<F, Vs...> value = base::make_fmatrix<F, Vs...>();
+};
+
+template <typename F, typename... Vs>
+constexpr fmatrix_t<F, Vs...> fmatrix<F, Vs...>::value;
+
+template <typename F, typename... Vs>
+using fdiagonal_t = decltype(base::make_fdiagonal<F, Vs...>());
+
+template <typename F, typename... Vs>
+struct fdiagonal {
+  static constexpr fdiagonal_t<F, Vs...> value =
+      base::make_fdiagonal<F, Vs...>();
+};
+
+template <typename F, typename... Vs>
+constexpr fdiagonal_t<F, Vs...> fdiagonal<F, Vs...>::value;
+#endif
+
+struct alt {
+  template <typename Visitor, typename... Vs>
+  inline static constexpr DECLTYPE_AUTO visit_alt(Visitor&& visitor, Vs&&... vs)
+#ifdef C10_MPARK_VARIANT_SWITCH_VISIT
+      DECLTYPE_AUTO_RETURN(base::dispatcher<
+                           true,
+                           base::dispatch_result_t<
+                               Visitor,
+                               decltype(as_base(lib::forward<Vs>(vs)))...>>::
+                               template dispatch<0>(
+                                   lib::forward<Visitor>(visitor),
+                                   as_base(lib::forward<Vs>(vs))...))
+#elif !defined(_MSC_VER) || _MSC_VER >= 1910
+      DECLTYPE_AUTO_RETURN(base::at(
+          fmatrix<Visitor&&, decltype(as_base(lib::forward<Vs>(vs)))...>::value,
+          vs.index()...)(
+          lib::forward<Visitor>(visitor),
+          as_base(lib::forward<Vs>(vs))...))
+#else
+      DECLTYPE_AUTO_RETURN(base::at(
+          base::make_fmatrix<
+              Visitor&&,
+              decltype(as_base(lib::forward<Vs>(vs)))...>(),
+          vs.index()...)(
+          lib::forward<Visitor>(visitor),
+          as_base(lib::forward<Vs>(vs))...))
+#endif
+
+          template <typename Visitor, typename... Vs>
+          inline static constexpr DECLTYPE_AUTO
+      visit_alt_at(std::size_t index, Visitor&& visitor, Vs&&... vs)
+#ifdef C10_MPARK_VARIANT_SWITCH_VISIT
+          DECLTYPE_AUTO_RETURN(
+              base::dispatcher<
+                  true,
+                  base::dispatch_result_t<
+                      Visitor,
+                      decltype(as_base(lib::forward<Vs>(vs)))...>>::
+                  template dispatch_at<0>(
+                      index,
+                      lib::forward<Visitor>(visitor),
+                      as_base(lib::forward<Vs>(vs))...))
+#elif !defined(_MSC_VER) || _MSC_VER >= 1910
+          DECLTYPE_AUTO_RETURN(base::at(
+              fdiagonal<Visitor&&, decltype(as_base(lib::forward<Vs>(vs)))...>::
+                  value,
+              index)(
+              lib::forward<Visitor>(visitor),
+              as_base(lib::forward<Vs>(vs))...))
+#else
+          DECLTYPE_AUTO_RETURN(base::at(
+              base::make_fdiagonal<
+                  Visitor&&,
+                  decltype(as_base(lib::forward<Vs>(vs)))...>(),
+              index)(
+              lib::forward<Visitor>(visitor),
+              as_base(lib::forward<Vs>(vs))...))
+#endif
+};
+
+struct variant {
+ private:
+  template <typename Visitor>
+  struct visitor {
+    template <typename... Values>
+    inline static constexpr bool does_not_handle() {
+      return lib::is_invocable<Visitor, Values...>::value;
+    }
+  };
+
+  template <typename Visitor, typename... Values>
+  struct visit_exhaustiveness_check {
+    static_assert(
+        visitor<Visitor>::template does_not_handle<Values...>(),
+        "`visit` requires the visitor to be exhaustive.");
+
+    inline static constexpr DECLTYPE_AUTO invoke(
+        Visitor&& visitor,
+        Values&&... values)
+        DECLTYPE_AUTO_RETURN(lib::invoke(
+            lib::forward<Visitor>(visitor),
+            lib::forward<Values>(values)...))
+  };
+
+  template <typename Visitor>
+  struct C10_MPARK_VISIBILITY_HIDDEN value_visitor {
+    Visitor&& visitor_;
+
+    template <typename... Alts>
+    inline constexpr DECLTYPE_AUTO operator()(Alts&&... alts) const
+        DECLTYPE_AUTO_RETURN(visit_exhaustiveness_check<
+                             Visitor,
+                             decltype((lib::forward<Alts>(alts).value))...>::
+                                 invoke(
+                                     lib::forward<Visitor>(visitor_),
+                                     lib::forward<Alts>(alts).value...))
+  };
+
+  template <typename Visitor>
+  inline static constexpr AUTO make_value_visitor(Visitor&& visitor)
+      AUTO_RETURN(value_visitor<Visitor>{lib::forward<Visitor>(visitor)})
+
+          public
+      : template <typename Visitor, typename... Vs>
+        inline static constexpr DECLTYPE_AUTO
+        visit_alt(Visitor&& visitor, Vs&&... vs)
+            DECLTYPE_AUTO_RETURN(alt::visit_alt(
+                lib::forward<Visitor>(visitor),
+                lib::forward<Vs>(vs).impl_...))
+
+                template <typename Visitor, typename... Vs>
+                inline static constexpr DECLTYPE_AUTO
+        visit_alt_at(std::size_t index, Visitor&& visitor, Vs&&... vs)
+            DECLTYPE_AUTO_RETURN(alt::visit_alt_at(
+                index,
+                lib::forward<Visitor>(visitor),
+                lib::forward<Vs>(vs).impl_...))
+
+                template <typename Visitor, typename... Vs>
+                inline static constexpr DECLTYPE_AUTO
+        visit_value(Visitor&& visitor, Vs&&... vs)
+            DECLTYPE_AUTO_RETURN(visit_alt(
+                make_value_visitor(lib::forward<Visitor>(visitor)),
+                lib::forward<Vs>(vs)...))
+
+                template <typename Visitor, typename... Vs>
+                inline static constexpr DECLTYPE_AUTO
+        visit_value_at(std::size_t index, Visitor&& visitor, Vs&&... vs)
+            DECLTYPE_AUTO_RETURN(visit_alt_at(
+                index,
+                make_value_visitor(lib::forward<Visitor>(visitor)),
+                lib::forward<Vs>(vs)...))
+};
+
+} // namespace visitation
+
+template <std::size_t Index, typename T>
+struct alt {
+  using value_type = T;
+
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4244)
+#endif
+  template <typename... Args>
+  inline explicit constexpr alt(in_place_t, Args&&... args)
+      : value(lib::forward<Args>(args)...) {}
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+
+  T value;
+};
+
+template <Trait DestructibleTrait, std::size_t Index, typename... Ts>
+union recursive_union;
+
+template <Trait DestructibleTrait, std::size_t Index>
+union recursive_union<DestructibleTrait, Index> {};
+
+#define C10_MPARK_VARIANT_RECURSIVE_UNION(destructible_trait, destructor)  \
+  template <std::size_t Index, typename T, typename... Ts>                 \
+  union recursive_union<destructible_trait, Index, T, Ts...> {             \
+   public:                                                                 \
+    inline explicit constexpr recursive_union(valueless_t) noexcept        \
+        : dummy_{} {}                                                      \
+                                                                           \
+    template <typename... Args>                                            \
+    inline explicit constexpr recursive_union(                             \
+        in_place_index_t<0>,                                               \
+        Args&&... args)                                                    \
+        : head_(in_place_t{}, lib::forward<Args>(args)...) {}              \
+                                                                           \
+    template <std::size_t I, typename... Args>                             \
+    inline explicit constexpr recursive_union(                             \
+        in_place_index_t<I>,                                               \
+        Args&&... args)                                                    \
+        : tail_(in_place_index_t<I - 1>{}, lib::forward<Args>(args)...) {} \
+                                                                           \
+    recursive_union(const recursive_union&) = default;                     \
+    recursive_union(recursive_union&&) = default;                          \
+                                                                           \
+    destructor                                                             \
+                                                                           \
+        recursive_union&                                                   \
+        operator=(const recursive_union&) = default;                       \
+    recursive_union& operator=(recursive_union&&) = default;               \
+                                                                           \
+   private:                                                                \
+    char dummy_;                                                           \
+    alt<Index, T> head_;                                                   \
+    recursive_union<destructible_trait, Index + 1, Ts...> tail_;           \
+                                                                           \
+    friend struct access::recursive_union;                                 \
+  }
+
+C10_MPARK_VARIANT_RECURSIVE_UNION(Trait::TriviallyAvailable,
+                                  ~recursive_union() = default;);
+C10_MPARK_VARIANT_RECURSIVE_UNION(Trait::Available, ~recursive_union(){});
+C10_MPARK_VARIANT_RECURSIVE_UNION(Trait::Unavailable,
+                                  ~recursive_union() = delete;);
+
+#undef C10_MPARK_VARIANT_RECURSIVE_UNION
+
+using index_t = unsigned int;
+
+template <Trait DestructibleTrait, typename... Ts>
+class base {
+ public:
+  inline explicit constexpr base(valueless_t tag) noexcept
+      : data_(tag), index_(static_cast<index_t>(-1)) {}
+
+  template <std::size_t I, typename... Args>
+  inline explicit constexpr base(in_place_index_t<I>, Args&&... args)
+      : data_(in_place_index_t<I>{}, lib::forward<Args>(args)...), index_(I) {}
+
+  inline constexpr bool valueless_by_exception() const noexcept {
+    return index_ == static_cast<index_t>(-1);
+  }
+
+  inline constexpr std::size_t index() const noexcept {
+    return valueless_by_exception() ? variant_npos : index_;
+  }
+
+ protected:
+  using data_t = recursive_union<DestructibleTrait, 0, Ts...>;
+
+  friend inline constexpr base& as_base(base& b) {
+    return b;
+  }
+  friend inline constexpr const base& as_base(const base& b) {
+    return b;
+  }
+  friend inline constexpr base&& as_base(base&& b) {
+    return lib::move(b);
+  }
+  friend inline constexpr const base&& as_base(const base&& b) {
+    return lib::move(b);
+  }
+
+  friend inline constexpr data_t& data(base& b) {
+    return b.data_;
+  }
+  friend inline constexpr const data_t& data(const base& b) {
+    return b.data_;
+  }
+  friend inline constexpr data_t&& data(base&& b) {
+    return lib::move(b).data_;
+  }
+  friend inline constexpr const data_t&& data(const base&& b) {
+    return lib::move(b).data_;
+  }
+
+  inline static constexpr std::size_t size() {
+    return sizeof...(Ts);
+  }
+
+  data_t data_;
+  index_t index_;
+
+  friend struct access::base;
+  friend struct visitation::base;
+};
+
+struct dtor {
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4100)
+#endif
+  template <typename Alt>
+  inline void operator()(Alt& alt) const noexcept {
+    alt.~Alt();
+  }
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+};
+
+#if !defined(_MSC_VER) || _MSC_VER >= 1910
+#define C10_MPARK_INHERITING_CTOR(type, base) using base::base;
+#else
+#define C10_MPARK_INHERITING_CTOR(type, base)    \
+  template <typename... Args>                    \
+  inline explicit constexpr type(Args&&... args) \
+      : base(lib::forward<Args>(args)...) {}
+#endif
+
+template <typename Traits, Trait = Traits::destructible_trait>
+class destructor;
+
+#define C10_MPARK_VARIANT_DESTRUCTOR(destructible_trait, definition, destroy) \
+  template <typename... Ts>                                                   \
+  class destructor<traits<Ts...>, destructible_trait>                         \
+      : public base<destructible_trait, Ts...> {                              \
+    using super = base<destructible_trait, Ts...>;                            \
+                                                                              \
+   public:                                                                    \
+    C10_MPARK_INHERITING_CTOR(destructor, super)                              \
+    using super::operator=;                                                   \
+                                                                              \
+    destructor(const destructor&) = default;                                  \
+    destructor(destructor&&) = default;                                       \
+    definition destructor& operator=(const destructor&) = default;            \
+    destructor& operator=(destructor&&) = default;                            \
+                                                                              \
+   protected:                                                                 \
+    destroy                                                                   \
+  }
+
+C10_MPARK_VARIANT_DESTRUCTOR(
+    Trait::TriviallyAvailable, ~destructor() = default;
+    , inline void destroy() noexcept {
+      this->index_ = static_cast<index_t>(-1);
+    });
+
+C10_MPARK_VARIANT_DESTRUCTOR(
+    Trait::Available,
+    ~destructor() { destroy(); },
+    inline void destroy() noexcept {
+      if (!this->valueless_by_exception()) {
+        visitation::alt::visit_alt(dtor{}, *this);
+      }
+      this->index_ = static_cast<index_t>(-1);
+    });
+
+C10_MPARK_VARIANT_DESTRUCTOR(Trait::Unavailable, ~destructor() = delete;
+                             , inline void destroy() noexcept = delete;);
+
+#undef C10_MPARK_VARIANT_DESTRUCTOR
+
+template <typename Traits>
+class constructor : public destructor<Traits> {
+  using super = destructor<Traits>;
+
+ public:
+  C10_MPARK_INHERITING_CTOR(constructor, super)
+  using super::operator=;
+
+ protected:
+#ifndef C10_MPARK_GENERIC_LAMBDAS
+  struct ctor {
+    template <typename LhsAlt, typename RhsAlt>
+    inline void operator()(LhsAlt& lhs_alt, RhsAlt&& rhs_alt) const {
+      constructor::construct_alt(lhs_alt, lib::forward<RhsAlt>(rhs_alt).value);
+    }
+  };
+#endif
+
+  template <std::size_t I, typename T, typename... Args>
+  inline static T& construct_alt(alt<I, T>& a, Args&&... args) {
+    auto* result = ::new (static_cast<void*>(lib::addressof(a)))
+        alt<I, T>(in_place_t{}, lib::forward<Args>(args)...);
+    return result->value;
+  }
+
+  template <typename Rhs>
+  inline static void generic_construct(constructor& lhs, Rhs&& rhs) {
+    lhs.destroy();
+    if (!rhs.valueless_by_exception()) {
+      visitation::alt::visit_alt_at(
+          rhs.index(),
+#ifdef C10_MPARK_GENERIC_LAMBDAS
+          [](auto& lhs_alt, auto&& rhs_alt) {
+            constructor::construct_alt(
+                lhs_alt, lib::forward<decltype(rhs_alt)>(rhs_alt).value);
+          }
+#else
+          ctor {}
+#endif
+          ,
+          lhs,
+          lib::forward<Rhs>(rhs));
+      lhs.index_ = rhs.index_;
+    }
+  }
+};
+
+template <typename Traits, Trait = Traits::move_constructible_trait>
+class move_constructor;
+
+#define C10_MPARK_VARIANT_MOVE_CONSTRUCTOR(                         \
+    move_constructible_trait, definition)                           \
+  template <typename... Ts>                                         \
+  class move_constructor<traits<Ts...>, move_constructible_trait>   \
+      : public constructor<traits<Ts...>> {                         \
+    using super = constructor<traits<Ts...>>;                       \
+                                                                    \
+   public:                                                          \
+    C10_MPARK_INHERITING_CTOR(move_constructor, super)              \
+    using super::operator=;                                         \
+                                                                    \
+    move_constructor(const move_constructor&) = default;            \
+    definition ~move_constructor() = default;                       \
+    move_constructor& operator=(const move_constructor&) = default; \
+    move_constructor& operator=(move_constructor&&) = default;      \
+  }
+
+C10_MPARK_VARIANT_MOVE_CONSTRUCTOR(
+    Trait::TriviallyAvailable,
+    move_constructor(move_constructor&& that) = default;);
+
+C10_MPARK_VARIANT_MOVE_CONSTRUCTOR(
+    Trait::Available,
+    move_constructor(move_constructor&& that) noexcept(
+        lib::all<std::is_nothrow_move_constructible<Ts>::value...>::value)
+    : move_constructor(valueless_t{}) {
+      this->generic_construct(*this, lib::move(that));
+    });
+
+C10_MPARK_VARIANT_MOVE_CONSTRUCTOR(
+    Trait::Unavailable, move_constructor(move_constructor&&) = delete;);
+
+#undef C10_MPARK_VARIANT_MOVE_CONSTRUCTOR
+
+template <typename Traits, Trait = Traits::copy_constructible_trait>
+class copy_constructor;
+
+#define C10_MPARK_VARIANT_COPY_CONSTRUCTOR(                         \
+    copy_constructible_trait, definition)                           \
+  template <typename... Ts>                                         \
+  class copy_constructor<traits<Ts...>, copy_constructible_trait>   \
+      : public move_constructor<traits<Ts...>> {                    \
+    using super = move_constructor<traits<Ts...>>;                  \
+                                                                    \
+   public:                                                          \
+    C10_MPARK_INHERITING_CTOR(copy_constructor, super)              \
+    using super::operator=;                                         \
+                                                                    \
+    definition copy_constructor(copy_constructor&&) = default;      \
+    ~copy_constructor() = default;                                  \
+    copy_constructor& operator=(const copy_constructor&) = default; \
+    copy_constructor& operator=(copy_constructor&&) = default;      \
+  }
+
+C10_MPARK_VARIANT_COPY_CONSTRUCTOR(
+    Trait::TriviallyAvailable,
+    copy_constructor(const copy_constructor& that) = default;);
+
+C10_MPARK_VARIANT_COPY_CONSTRUCTOR(
+    Trait::Available, copy_constructor(const copy_constructor& that)
+    : copy_constructor(valueless_t{}) {
+      this->generic_construct(*this, that);
+    });
+
+C10_MPARK_VARIANT_COPY_CONSTRUCTOR(
+    Trait::Unavailable, copy_constructor(const copy_constructor&) = delete;);
+
+#undef C10_MPARK_VARIANT_COPY_CONSTRUCTOR
+
+template <typename Traits>
+class assignment : public copy_constructor<Traits> {
+  using super = copy_constructor<Traits>;
+
+ public:
+  C10_MPARK_INHERITING_CTOR(assignment, super)
+  using super::operator=;
+
+  template <std::size_t I, typename... Args>
+  inline /* auto & */ auto emplace(Args&&... args)
+      -> decltype(this->construct_alt(
+          access::base::get_alt<I>(*this),
+          lib::forward<Args>(args)...)) {
+    this->destroy();
+    auto& result = this->construct_alt(
+        access::base::get_alt<I>(*this), lib::forward<Args>(args)...);
+    this->index_ = I;
+    return result;
+  }
+
+ protected:
+#ifndef C10_MPARK_GENERIC_LAMBDAS
+  template <typename That>
+  struct assigner {
+    template <typename ThisAlt, typename ThatAlt>
+    inline void operator()(ThisAlt& this_alt, ThatAlt&& that_alt) const {
+      self->assign_alt(this_alt, lib::forward<ThatAlt>(that_alt).value);
+    }
+    assignment* self;
+  };
+#endif
+
+  template <std::size_t I, typename T, typename Arg>
+  inline void assign_alt(alt<I, T>& a, Arg&& arg) {
+    if (this->index() == I) {
+#ifdef _MSC_VER
+#pragma warning(push)
+#pragma warning(disable : 4244)
+#endif
+      a.value = lib::forward<Arg>(arg);
+#ifdef _MSC_VER
+#pragma warning(pop)
+#endif
+    } else {
+      struct {
+        void operator()(std::true_type) const {
+          this_->emplace<I>(lib::forward<Arg>(arg_));
+        }
+        void operator()(std::false_type) const {
+          this_->emplace<I>(T(lib::forward<Arg>(arg_)));
+        }
+        assignment* this_;
+        Arg&& arg_;
+      } impl{this, lib::forward<Arg>(arg)};
+      impl(
+          lib::bool_constant < std::is_nothrow_constructible<T, Arg>::value ||
+          !std::is_nothrow_move_constructible<T>::value > {});
+    }
+  }
+
+  template <typename That>
+  inline void generic_assign(That&& that) {
+    if (this->valueless_by_exception() && that.valueless_by_exception()) {
+      // do nothing.
+    } else if (that.valueless_by_exception()) {
+      this->destroy();
+    } else {
+      visitation::alt::visit_alt_at(
+          that.index(),
+#ifdef C10_MPARK_GENERIC_LAMBDAS
+          [this](auto& this_alt, auto&& that_alt) {
+            this->assign_alt(
+                this_alt, lib::forward<decltype(that_alt)>(that_alt).value);
+          }
+#else
+          assigner<That> { this }
+#endif
+          ,
+          *this,
+          lib::forward<That>(that));
+    }
+  }
+};
+
+template <typename Traits, Trait = Traits::move_assignable_trait>
+class move_assignment;
+
+#define C10_MPARK_VARIANT_MOVE_ASSIGNMENT(move_assignable_trait, definition) \
+  template <typename... Ts>                                                  \
+  class move_assignment<traits<Ts...>, move_assignable_trait>                \
+      : public assignment<traits<Ts...>> {                                   \
+    using super = assignment<traits<Ts...>>;                                 \
+                                                                             \
+   public:                                                                   \
+    C10_MPARK_INHERITING_CTOR(move_assignment, super)                        \
+    using super::operator=;                                                  \
+                                                                             \
+    move_assignment(const move_assignment&) = default;                       \
+    move_assignment(move_assignment&&) = default;                            \
+    ~move_assignment() = default;                                            \
+    move_assignment& operator=(const move_assignment&) = default;            \
+    definition                                                               \
+  }
+
+C10_MPARK_VARIANT_MOVE_ASSIGNMENT(
+    Trait::TriviallyAvailable,
+    move_assignment& operator=(move_assignment&& that) = default;);
+
+C10_MPARK_VARIANT_MOVE_ASSIGNMENT(
+    Trait::Available,
+    move_assignment&
+    operator=(move_assignment&& that) noexcept(
+        lib::all<
+            (std::is_nothrow_move_constructible<Ts>::value &&
+             std::is_nothrow_move_assignable<Ts>::value)...>::value) {
+      this->generic_assign(lib::move(that));
+      return *this;
+    });
+
+C10_MPARK_VARIANT_MOVE_ASSIGNMENT(
+    Trait::Unavailable,
+    move_assignment& operator=(move_assignment&&) = delete;);
+
+#undef C10_MPARK_VARIANT_MOVE_ASSIGNMENT
+
+template <typename Traits, Trait = Traits::copy_assignable_trait>
+class copy_assignment;
+
+#define C10_MPARK_VARIANT_COPY_ASSIGNMENT(copy_assignable_trait, definition) \
+  template <typename... Ts>                                                  \
+  class copy_assignment<traits<Ts...>, copy_assignable_trait>                \
+      : public move_assignment<traits<Ts...>> {                              \
+    using super = move_assignment<traits<Ts...>>;                            \
+                                                                             \
+   public:                                                                   \
+    C10_MPARK_INHERITING_CTOR(copy_assignment, super)                        \
+    using super::operator=;                                                  \
+                                                                             \
+    copy_assignment(const copy_assignment&) = default;                       \
+    copy_assignment(copy_assignment&&) = default;                            \
+    ~copy_assignment() = default;                                            \
+    definition copy_assignment& operator=(copy_assignment&&) = default;      \
+  }
+
+C10_MPARK_VARIANT_COPY_ASSIGNMENT(
+    Trait::TriviallyAvailable,
+    copy_assignment& operator=(const copy_assignment& that) = default;);
+
+C10_MPARK_VARIANT_COPY_ASSIGNMENT(
+    Trait::Available,
+    copy_assignment&
+    operator=(const copy_assignment& that) {
+      this->generic_assign(that);
+      return *this;
+    });
+
+C10_MPARK_VARIANT_COPY_ASSIGNMENT(
+    Trait::Unavailable,
+    copy_assignment& operator=(const copy_assignment&) = delete;);
+
+#undef C10_MPARK_VARIANT_COPY_ASSIGNMENT
+
+template <typename... Ts>
+class impl : public copy_assignment<traits<Ts...>> {
+  using super = copy_assignment<traits<Ts...>>;
+
+ public:
+  C10_MPARK_INHERITING_CTOR(impl, super)
+
+  template <std::size_t I, typename Arg>
+  inline void assign(Arg&& arg) {
+    this->assign_alt(access::base::get_alt<I>(*this), lib::forward<Arg>(arg));
+  }
+
+  inline void swap(impl& that) {
+    if (this->valueless_by_exception() && that.valueless_by_exception()) {
+      // do nothing.
+    } else if (this->index() == that.index()) {
+      visitation::alt::visit_alt_at(
+          this->index(),
+#ifdef C10_MPARK_GENERIC_LAMBDAS
+          [](auto& this_alt, auto& that_alt) {
+            using std::swap;
+            swap(this_alt.value, that_alt.value);
+          }
+#else
+          swapper {}
+#endif
+          ,
+          *this,
+          that);
+    } else {
+      impl* lhs = this;
+      impl* rhs = lib::addressof(that);
+      if (lhs->move_nothrow() && !rhs->move_nothrow()) {
+        std::swap(lhs, rhs);
+      }
+      impl tmp(lib::move(*rhs));
+#ifdef C10_MPARK_EXCEPTIONS
+      // EXTENSION: When the move construction of `lhs` into `rhs` throws
+      // and `tmp` is nothrow move constructible then we move `tmp` back
+      // into `rhs` and provide the strong exception safety guarantee.
+      try {
+        this->generic_construct(*rhs, lib::move(*lhs));
+      } catch (...) {
+        if (tmp.move_nothrow()) {
+          this->generic_construct(*rhs, lib::move(tmp));
+        }
+        throw;
+      }
+#else
+      this->generic_construct(*rhs, lib::move(*lhs));
+#endif
+      this->generic_construct(*lhs, lib::move(tmp));
+    }
+  }
+
+ private:
+#ifndef C10_MPARK_GENERIC_LAMBDAS
+  struct swapper {
+    template <typename ThisAlt, typename ThatAlt>
+    inline void operator()(ThisAlt& this_alt, ThatAlt& that_alt) const {
+      using std::swap;
+      swap(this_alt.value, that_alt.value);
+    }
+  };
+#endif
+
+  inline constexpr bool move_nothrow() const {
+    return this->valueless_by_exception() ||
+        lib::array<bool, sizeof...(Ts)>{
+            {std::is_nothrow_move_constructible<Ts>::value...}}[this->index()];
+  }
+};
+
+#undef C10_MPARK_INHERITING_CTOR
+
+template <std::size_t I, typename T>
+struct overload_leaf {
+  using F = lib::size_constant<I> (*)(T);
+  operator F() const {
+    return nullptr;
+  }
+};
+
+template <typename... Ts>
+struct overload_impl {
+ private:
+  template <typename>
+  struct impl;
+
+  template <std::size_t... Is>
+  struct impl<lib::index_sequence<Is...>> : overload_leaf<Is, Ts>... {};
+
+ public:
+  using type = impl<lib::index_sequence_for<Ts...>>;
+};
+
+template <typename... Ts>
+using overload = typename overload_impl<Ts...>::type;
+
+template <typename T, typename... Ts>
+using best_match = lib::invoke_result_t<overload<Ts...>, T&&>;
+
+template <typename T>
+struct is_in_place_index : std::false_type {};
+
+template <std::size_t I>
+struct is_in_place_index<in_place_index_t<I>> : std::true_type {};
+
+template <typename T>
+struct is_in_place_type : std::false_type {};
+
+template <typename T>
+struct is_in_place_type<in_place_type_t<T>> : std::true_type {};
+
+} // namespace detail_
+
+template <typename... Ts>
+class variant {
+  static_assert(
+      0 < sizeof...(Ts),
+      "variant must consist of at least one alternative.");
+
+  static_assert(
+      lib::all<!std::is_array<Ts>::value...>::value,
+      "variant can not have an array type as an alternative.");
+
+  static_assert(
+      lib::all<!std::is_reference<Ts>::value...>::value,
+      "variant can not have a reference type as an alternative.");
+
+  static_assert(
+      lib::all<!std::is_void<Ts>::value...>::value,
+      "variant can not have a void type as an alternative.");
+
+ public:
+  template <
+      typename Front = lib::type_pack_element_t<0, Ts...>,
+      lib::enable_if_t<std::is_default_constructible<Front>::value, int> = 0>
+  inline constexpr variant() noexcept(
+      std::is_nothrow_default_constructible<Front>::value)
+      : impl_(in_place_index_t<0>{}) {}
+
+  variant(const variant&) = default;
+  variant(variant&&) = default;
+
+  // NOTE [gcc 7.3.1 bug workaround]
+  //
+  // The original line `typename T = lib::type_pack_element_t<I, Ts...>`
+  // throws the following compiler error on gcc 7.3.1:
+  // ```
+  // ../c10/util/variant.h:2250:9: internal compiler error:
+  // unexpected expression I of kind template_parm_index
+  //          typename T = lib::type_pack_element_t<I, Ts...>,
+  //          ^~~~~~~~
+  // ```
+  // As a workaround, `I` is changed to `detail_::best_match<Arg,
+  // Ts...>::value`, which is the default value for `I` in this template. Note
+  // that this workaround effectively disallows setting `I` to any other
+  // non-default value, and we add a `static_assert` in the function body to
+  // check for this.
+  //
+  // See the following issues for more context:
+  // - https://github.com/mpark/variant/issues/43
+  // - https://github.com/eggs-cpp/variant/issues/31
+  template <
+      typename Arg,
+      typename Decayed = lib::decay_t<Arg>,
+      lib::enable_if_t<!std::is_same<Decayed, variant>::value, int> = 0,
+      lib::enable_if_t<!detail_::is_in_place_index<Decayed>::value, int> = 0,
+      lib::enable_if_t<!detail_::is_in_place_type<Decayed>::value, int> = 0,
+      std::size_t I = detail_::best_match<Arg, Ts...>::value,
+      typename T = lib::
+          type_pack_element_t<detail_::best_match<Arg, Ts...>::value, Ts...>,
+      lib::enable_if_t<std::is_constructible<T, Arg>::value, int> = 0>
+  inline constexpr variant(Arg&& arg) noexcept(
+      std::is_nothrow_constructible<T, Arg>::value)
+      : impl_(in_place_index_t<I>{}, lib::forward<Arg>(arg)) {
+    static_assert(
+        I == detail_::best_match<Arg, Ts...>::value,
+        "Setting template parameter `I` to a custom non-default value is not supported. "
+        "Please file a feature request if you see this.");
+  }
+
+  template <
+      std::size_t I,
+      typename... Args,
+      typename T = lib::type_pack_element_t<I, Ts...>,
+      lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
+  inline explicit constexpr variant(
+      in_place_index_t<I>,
+      Args&&... args) noexcept(std::is_nothrow_constructible<T, Args...>::value)
+      : impl_(in_place_index_t<I>{}, lib::forward<Args>(args)...) {}
+
+  template <
+      std::size_t I,
+      typename Up,
+      typename... Args,
+      typename T = lib::type_pack_element_t<I, Ts...>,
+      lib::enable_if_t<
+          std::is_constructible<T, std::initializer_list<Up>&, Args...>::value,
+          int> = 0>
+  inline explicit constexpr variant(
+      in_place_index_t<I>,
+      std::initializer_list<Up> il,
+      Args&&... args) noexcept(std::
+                                   is_nothrow_constructible<
+                                       T,
+                                       std::initializer_list<Up>&,
+                                       Args...>::value)
+      : impl_(in_place_index_t<I>{}, il, lib::forward<Args>(args)...) {}
+
+  template <
+      typename T,
+      typename... Args,
+      std::size_t I = detail_::find_index_sfinae<T, Ts...>::value,
+      lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
+  inline explicit constexpr variant(
+      in_place_type_t<T>,
+      Args&&... args) noexcept(std::is_nothrow_constructible<T, Args...>::value)
+      : impl_(in_place_index_t<I>{}, lib::forward<Args>(args)...) {}
+
+  template <
+      typename T,
+      typename Up,
+      typename... Args,
+      std::size_t I = detail_::find_index_sfinae<T, Ts...>::value,
+      lib::enable_if_t<
+          std::is_constructible<T, std::initializer_list<Up>&, Args...>::value,
+          int> = 0>
+  inline explicit constexpr variant(
+      in_place_type_t<T>,
+      std::initializer_list<Up> il,
+      Args&&... args) noexcept(std::
+                                   is_nothrow_constructible<
+                                       T,
+                                       std::initializer_list<Up>&,
+                                       Args...>::value)
+      : impl_(in_place_index_t<I>{}, il, lib::forward<Args>(args)...) {}
+
+  ~variant() = default;
+
+  variant& operator=(const variant&) = default;
+  variant& operator=(variant&&) = default;
+
+  // NOTE: See NOTE [gcc 7.3.1 bug workaround] for the changes made to this
+  // function.
+  template <
+      typename Arg,
+      lib::enable_if_t<!std::is_same<lib::decay_t<Arg>, variant>::value, int> =
+          0,
+      std::size_t I = detail_::best_match<Arg, Ts...>::value,
+      typename T = lib::
+          type_pack_element_t<detail_::best_match<Arg, Ts...>::value, Ts...>,
+      lib::enable_if_t<
+          (std::is_assignable<T&, Arg>::value &&
+           std::is_constructible<T, Arg>::value),
+          int> = 0>
+  inline variant& operator=(Arg&& arg) noexcept(
+      (std::is_nothrow_assignable<T&, Arg>::value &&
+       std::is_nothrow_constructible<T, Arg>::value)) {
+    static_assert(
+        I == detail_::best_match<Arg, Ts...>::value,
+        "Setting template parameter `I` to a custom non-default value is not supported. "
+        "Please file a feature request if you see this.");
+    impl_.template assign<I>(lib::forward<Arg>(arg));
+    return *this;
+  }
+
+  template <
+      std::size_t I,
+      typename... Args,
+      typename T = lib::type_pack_element_t<I, Ts...>,
+      lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
+  inline T& emplace(Args&&... args) {
+    return impl_.template emplace<I>(lib::forward<Args>(args)...);
+  }
+
+  template <
+      std::size_t I,
+      typename Up,
+      typename... Args,
+      typename T = lib::type_pack_element_t<I, Ts...>,
+      lib::enable_if_t<
+          std::is_constructible<T, std::initializer_list<Up>&, Args...>::value,
+          int> = 0>
+  inline T& emplace(std::initializer_list<Up> il, Args&&... args) {
+    return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
+  }
+
+  template <
+      typename T,
+      typename... Args,
+      std::size_t I = detail_::find_index_sfinae<T, Ts...>::value,
+      lib::enable_if_t<std::is_constructible<T, Args...>::value, int> = 0>
+  inline T& emplace(Args&&... args) {
+    return impl_.template emplace<I>(lib::forward<Args>(args)...);
+  }
+
+  template <
+      typename T,
+      typename Up,
+      typename... Args,
+      std::size_t I = detail_::find_index_sfinae<T, Ts...>::value,
+      lib::enable_if_t<
+          std::is_constructible<T, std::initializer_list<Up>&, Args...>::value,
+          int> = 0>
+  inline T& emplace(std::initializer_list<Up> il, Args&&... args) {
+    return impl_.template emplace<I>(il, lib::forward<Args>(args)...);
+  }
+
+  inline constexpr bool valueless_by_exception() const noexcept {
+    return impl_.valueless_by_exception();
+  }
+
+  inline constexpr std::size_t index() const noexcept {
+    return impl_.index();
+  }
+
+  template <
+      bool Dummy = true,
+      lib::enable_if_t<
+          lib::all<
+              Dummy,
+              (lib::dependent_type<std::is_move_constructible<Ts>, Dummy>::
+                   value &&
+               lib::dependent_type<lib::is_swappable<Ts>, Dummy>::value)...>::
+              value,
+          int> = 0>
+  inline void swap(variant& that) noexcept(
+      lib::all<
+          (std::is_nothrow_move_constructible<Ts>::value &&
+           lib::is_nothrow_swappable<Ts>::value)...>::value) {
+    impl_.swap(that.impl_);
+  }
+
+ private:
+  detail_::impl<Ts...> impl_;
+
+  friend struct detail_::access::variant;
+  friend struct detail_::visitation::variant;
+};
+
+template <std::size_t I, typename... Ts>
+inline constexpr bool holds_alternative(const variant<Ts...>& v) noexcept {
+  return v.index() == I;
+}
+
+template <typename T, typename... Ts>
+inline constexpr bool holds_alternative(const variant<Ts...>& v) noexcept {
+  return holds_alternative<detail_::find_index_checked<T, Ts...>::value>(v);
+}
+
+namespace detail_ {
+template <std::size_t I, typename V>
+struct generic_get_impl {
+  constexpr generic_get_impl(int) noexcept {}
+
+  constexpr AUTO_REFREF operator()(V&& v) const
+      AUTO_REFREF_RETURN(access::variant::get_alt<I>(lib::forward<V>(v)).value)
+};
+
+template <std::size_t I, typename V>
+inline constexpr AUTO_REFREF generic_get(V&& v)
+    AUTO_REFREF_RETURN(generic_get_impl<I, V>(
+        holds_alternative<I>(v)
+            ? 0
+            : (throw_bad_variant_access(), 0))(lib::forward<V>(v)))
+} // namespace detail_
+
+template <std::size_t I, typename... Ts>
+inline constexpr variant_alternative_t<I, variant<Ts...>>& get(
+    variant<Ts...>& v) {
+  return detail_::generic_get<I>(v);
+}
+
+template <std::size_t I, typename... Ts>
+inline constexpr variant_alternative_t<I, variant<Ts...>>&& get(
+    variant<Ts...>&& v) {
+  return detail_::generic_get<I>(lib::move(v));
+}
+
+template <std::size_t I, typename... Ts>
+inline constexpr const variant_alternative_t<I, variant<Ts...>>& get(
+    const variant<Ts...>& v) {
+  return detail_::generic_get<I>(v);
+}
+
+template <std::size_t I, typename... Ts>
+inline constexpr const variant_alternative_t<I, variant<Ts...>>&& get(
+    const variant<Ts...>&& v) {
+  return detail_::generic_get<I>(lib::move(v));
+}
+
+template <typename T, typename... Ts>
+inline constexpr T& get(variant<Ts...>& v) {
+  return get<detail_::find_index_checked<T, Ts...>::value>(v);
+}
+
+template <typename T, typename... Ts>
+inline constexpr T&& get(variant<Ts...>&& v) {
+  return get<detail_::find_index_checked<T, Ts...>::value>(lib::move(v));
+}
+
+template <typename T, typename... Ts>
+inline constexpr const T& get(const variant<Ts...>& v) {
+  return get<detail_::find_index_checked<T, Ts...>::value>(v);
+}
+
+template <typename T, typename... Ts>
+inline constexpr const T&& get(const variant<Ts...>&& v) {
+  return get<detail_::find_index_checked<T, Ts...>::value>(lib::move(v));
+}
+
+namespace detail_ {
+
+template <std::size_t I, typename V>
+inline constexpr /* auto * */ AUTO generic_get_if(V* v) noexcept AUTO_RETURN(
+    v&& holds_alternative<I>(*v)
+        ? lib::addressof(access::variant::get_alt<I>(*v).value)
+        : nullptr)
+
+} // namespace detail_
+
+template <std::size_t I, typename... Ts>
+inline constexpr lib::add_pointer_t<variant_alternative_t<I, variant<Ts...>>>
+get_if(variant<Ts...>* v) noexcept {
+  return detail_::generic_get_if<I>(v);
+}
+
+template <std::size_t I, typename... Ts>
+inline constexpr lib::add_pointer_t<
+    const variant_alternative_t<I, variant<Ts...>>>
+get_if(const variant<Ts...>* v) noexcept {
+  return detail_::generic_get_if<I>(v);
+}
+
+template <typename T, typename... Ts>
+inline constexpr lib::add_pointer_t<T> get_if(variant<Ts...>* v) noexcept {
+  return get_if<detail_::find_index_checked<T, Ts...>::value>(v);
+}
+
+template <typename T, typename... Ts>
+inline constexpr lib::add_pointer_t<const T> get_if(
+    const variant<Ts...>* v) noexcept {
+  return get_if<detail_::find_index_checked<T, Ts...>::value>(v);
+}
+
+namespace detail_ {
+template <typename RelOp>
+struct convert_to_bool {
+  template <typename Lhs, typename Rhs>
+  inline constexpr bool operator()(Lhs&& lhs, Rhs&& rhs) const {
+    static_assert(
+        std::is_convertible<lib::invoke_result_t<RelOp, Lhs, Rhs>, bool>::value,
+        "relational operators must return a type"
+        " implicitly convertible to bool");
+    return lib::invoke(RelOp{}, lib::forward<Lhs>(lhs), lib::forward<Rhs>(rhs));
+  }
+};
+} // namespace detail_
+
+template <typename... Ts>
+inline constexpr bool operator==(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using equal_to = detail_::convert_to_bool<lib::equal_to>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (lhs.index() != rhs.index())
+    return false;
+  if (lhs.valueless_by_exception())
+    return true;
+  return variant::visit_value_at(lhs.index(), equal_to{}, lhs, rhs);
+#else
+  return lhs.index() == rhs.index() &&
+      (lhs.valueless_by_exception() ||
+       variant::visit_value_at(lhs.index(), equal_to{}, lhs, rhs));
+#endif
+}
+
+template <typename... Ts>
+inline constexpr bool operator!=(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using not_equal_to = detail_::convert_to_bool<lib::not_equal_to>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (lhs.index() != rhs.index())
+    return true;
+  if (lhs.valueless_by_exception())
+    return false;
+  return variant::visit_value_at(lhs.index(), not_equal_to{}, lhs, rhs);
+#else
+  return lhs.index() != rhs.index() ||
+      (!lhs.valueless_by_exception() &&
+       variant::visit_value_at(lhs.index(), not_equal_to{}, lhs, rhs));
+#endif
+}
+
+template <typename... Ts>
+inline constexpr bool operator<(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using less = detail_::convert_to_bool<lib::less>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (rhs.valueless_by_exception())
+    return false;
+  if (lhs.valueless_by_exception())
+    return true;
+  if (lhs.index() < rhs.index())
+    return true;
+  if (lhs.index() > rhs.index())
+    return false;
+  return variant::visit_value_at(lhs.index(), less{}, lhs, rhs);
+#else
+  return !rhs.valueless_by_exception() &&
+      (lhs.valueless_by_exception() || lhs.index() < rhs.index() ||
+       (lhs.index() == rhs.index() &&
+        variant::visit_value_at(lhs.index(), less{}, lhs, rhs)));
+#endif
+}
+
+template <typename... Ts>
+inline constexpr bool operator>(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using greater = detail_::convert_to_bool<lib::greater>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (lhs.valueless_by_exception())
+    return false;
+  if (rhs.valueless_by_exception())
+    return true;
+  if (lhs.index() > rhs.index())
+    return true;
+  if (lhs.index() < rhs.index())
+    return false;
+  return variant::visit_value_at(lhs.index(), greater{}, lhs, rhs);
+#else
+  return !lhs.valueless_by_exception() &&
+      (rhs.valueless_by_exception() || lhs.index() > rhs.index() ||
+       (lhs.index() == rhs.index() &&
+        variant::visit_value_at(lhs.index(), greater{}, lhs, rhs)));
+#endif
+}
+
+template <typename... Ts>
+inline constexpr bool operator<=(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using less_equal = detail_::convert_to_bool<lib::less_equal>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (lhs.valueless_by_exception())
+    return true;
+  if (rhs.valueless_by_exception())
+    return false;
+  if (lhs.index() < rhs.index())
+    return true;
+  if (lhs.index() > rhs.index())
+    return false;
+  return variant::visit_value_at(lhs.index(), less_equal{}, lhs, rhs);
+#else
+  return lhs.valueless_by_exception() ||
+      (!rhs.valueless_by_exception() &&
+       (lhs.index() < rhs.index() ||
+        (lhs.index() == rhs.index() &&
+         variant::visit_value_at(lhs.index(), less_equal{}, lhs, rhs))));
+#endif
+}
+
+template <typename... Ts>
+inline constexpr bool operator>=(
+    const variant<Ts...>& lhs,
+    const variant<Ts...>& rhs) {
+  using detail_::visitation::variant;
+  using greater_equal = detail_::convert_to_bool<lib::greater_equal>;
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+  if (rhs.valueless_by_exception())
+    return true;
+  if (lhs.valueless_by_exception())
+    return false;
+  if (lhs.index() > rhs.index())
+    return true;
+  if (lhs.index() < rhs.index())
+    return false;
+  return variant::visit_value_at(lhs.index(), greater_equal{}, lhs, rhs);
+#else
+  return rhs.valueless_by_exception() ||
+      (!lhs.valueless_by_exception() &&
+       (lhs.index() > rhs.index() ||
+        (lhs.index() == rhs.index() &&
+         variant::visit_value_at(lhs.index(), greater_equal{}, lhs, rhs))));
+#endif
+}
+
+struct monostate {};
+
+inline constexpr bool operator<(monostate, monostate) noexcept {
+  return false;
+}
+
+inline constexpr bool operator>(monostate, monostate) noexcept {
+  return false;
+}
+
+inline constexpr bool operator<=(monostate, monostate) noexcept {
+  return true;
+}
+
+inline constexpr bool operator>=(monostate, monostate) noexcept {
+  return true;
+}
+
+inline constexpr bool operator==(monostate, monostate) noexcept {
+  return true;
+}
+
+inline constexpr bool operator!=(monostate, monostate) noexcept {
+  return false;
+}
+
+#ifdef C10_MPARK_CPP14_CONSTEXPR
+namespace detail_ {
+
+inline constexpr bool any(std::initializer_list<bool> bs) {
+  for (bool b : bs) {
+    if (b) {
+      return true;
+    }
+  }
+  return false;
+}
+
+} // namespace detail_
+
+template <typename Visitor, typename... Vs>
+inline constexpr decltype(auto) visit(Visitor&& visitor, Vs&&... vs) {
+  return (!detail_::any({vs.valueless_by_exception()...})
+              ? (void)0
+              : throw_bad_variant_access()),
+         detail_::visitation::variant::visit_value(
+             lib::forward<Visitor>(visitor), lib::forward<Vs>(vs)...);
+}
+#else
+namespace detail_ {
+
+template <std::size_t N>
+inline constexpr bool all_impl(const lib::array<bool, N>& bs, std::size_t idx) {
+  return idx >= N || (bs[idx] && all_impl(bs, idx + 1));
+}
+
+template <std::size_t N>
+inline constexpr bool all(const lib::array<bool, N>& bs) {
+  return all_impl(bs, 0);
+}
+
+} // namespace detail_
+
+template <typename Visitor, typename... Vs>
+inline constexpr DECLTYPE_AUTO visit(Visitor&& visitor, Vs&&... vs)
+    DECLTYPE_AUTO_RETURN(
+        (detail_::all(lib::array<bool, sizeof...(Vs)>{
+             {!vs.valueless_by_exception()...}})
+             ? (void)0
+             : throw_bad_variant_access()),
+        detail_::visitation::variant::visit_value(
+            lib::forward<Visitor>(visitor),
+            lib::forward<Vs>(vs)...))
+#endif
+
+template <typename... Ts>
+inline auto swap(variant<Ts...>& lhs, variant<Ts...>& rhs) noexcept(
+    noexcept(lhs.swap(rhs))) -> decltype(lhs.swap(rhs)) {
+  lhs.swap(rhs);
+}
+
+namespace detail_ {
+
+template <typename T, typename...>
+using enabled_type = T;
+
+namespace hash {
+
+template <typename H, typename K>
+constexpr bool meets_requirements() noexcept {
+  return std::is_copy_constructible<H>::value &&
+      std::is_move_constructible<H>::value &&
+      lib::is_invocable_r<std::size_t, H, const K&>::value;
+}
+
+template <typename K>
+constexpr bool is_enabled() noexcept {
+  using H = std::hash<K>;
+  return meets_requirements<H, K>() &&
+      std::is_default_constructible<H>::value &&
+      std::is_copy_assignable<H>::value && std::is_move_assignable<H>::value;
+}
+
+} // namespace hash
+
+} // namespace detail_
+
+#undef AUTO
+#undef AUTO_RETURN
+
+#undef AUTO_REFREF
+#undef AUTO_REFREF_RETURN
+
+#undef DECLTYPE_AUTO
+#undef DECLTYPE_AUTO_RETURN
+
+} // namespace c10
+
+namespace std {
+
+template <typename... Ts>
+struct hash<c10::detail_::enabled_type<
+    c10::variant<Ts...>,
+    c10::lib::enable_if_t<c10::lib::all<c10::detail_::hash::is_enabled<
+        c10::lib::remove_const_t<Ts>>()...>::value>>> {
+  using argument_type = c10::variant<Ts...>;
+  using result_type = std::size_t;
+
+  inline result_type operator()(const argument_type& v) const {
+    using c10::detail_::visitation::variant;
+    std::size_t result = v.valueless_by_exception()
+        ? 299792458 // Random value chosen by the universe upon creation
+        : variant::visit_alt(
+#ifdef C10_MPARK_GENERIC_LAMBDAS
+              [](const auto& alt) {
+                using alt_type = c10::lib::decay_t<decltype(alt)>;
+                using value_type =
+                    c10::lib::remove_const_t<typename alt_type::value_type>;
+                return hash<value_type>{}(alt.value);
+              }
+#else
+              hasher {}
+#endif
+              ,
+              v);
+    return hash_combine(result, hash<std::size_t>{}(v.index()));
+  }
+
+ private:
+#ifndef C10_MPARK_GENERIC_LAMBDAS
+  struct hasher {
+    template <typename Alt>
+    inline std::size_t operator()(const Alt& alt) const {
+      using alt_type = c10::lib::decay_t<Alt>;
+      using value_type =
+          c10::lib::remove_const_t<typename alt_type::value_type>;
+      return hash<value_type>{}(alt.value);
+    }
+  };
+#endif
+
+  static std::size_t hash_combine(std::size_t lhs, std::size_t rhs) {
+    return lhs ^= rhs + 0x9e3779b9 + (lhs << 6) + (lhs >> 2);
+  }
+};
+
+template <>
+struct hash<c10::monostate> {
+  using argument_type = c10::monostate;
+  using result_type = std::size_t;
+
+  inline result_type operator()(const argument_type&) const noexcept {
+    return 66740831; // return a fundamentally attractive random value.
+  }
+};
+
+} // namespace std
+
+#endif // C10_UTIL_VARIANT_H_
diff --git a/caffe2/CMakeLists.txt b/caffe2/CMakeLists.txt
index 748363725b..9bdfbd10f3 100644
--- a/caffe2/CMakeLists.txt
+++ b/caffe2/CMakeLists.txt
@@ -93,11 +93,11 @@ if(INTERN_BUILD_ATEN_OPS)
   list(APPEND Caffe2_CPU_TEST_SRCS ${ATen_CORE_TEST_SRCS})
   list(APPEND Caffe2_VULKAN_TEST_SRCS ${ATen_VULKAN_TEST_SRCS})
   list(APPEND Caffe2_CPU_INCLUDE ${ATen_CPU_INCLUDE})
-  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE})
+  list(APPEND Caffe2_CPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include)
   list(APPEND Caffe2_HIP_INCLUDE ${ATen_HIP_INCLUDE})
   list(APPEND Caffe2_VULKAN_INCLUDE ${ATen_VULKAN_INCLUDE})
-  list(APPEND Caffe2_DEPENDENCY_LIBS ${ATen_CPU_DEPENDENCY_LIBS})
-  list(APPEND Caffe2_CUDA_DEPENDENCY_LIBS ${ATen_CUDA_DEPENDENCY_LIBS})
+  list(APPEND Caffe2_DEPENDENCY_LIBS ${ATen_CPU_DEPENDENCY_LIBS} /Users/llv23/opt/miniconda3/lib/libomp.dylib)
+  list(APPEND Caffe2_CUDA_DEPENDENCY_LIBS ${ATen_CUDA_DEPENDENCY_LIBS} /Users/llv23/opt/miniconda3/lib/libomp.dylib)
   list(APPEND Caffe2_HIP_DEPENDENCY_LIBS ${ATen_HIP_DEPENDENCY_LIBS})
   list(APPEND Caffe2_DEPENDENCY_INCLUDE ${ATen_THIRD_PARTY_INCLUDE})
   set(Caffe2_CUDA_DEPENDENCY_LIBS ${Caffe2_CUDA_DEPENDENCY_LIBS} PARENT_SCOPE)
@@ -1338,6 +1338,9 @@ if(USE_DISTRIBUTED)
         "${TORCH_SRC_DIR}/csrc/distributed/c10d/ProcessGroupMPI.cpp"
         PROPERTIES COMPILE_FLAGS -Wno-deprecated-declarations)
     endif()
+    if(USE_CUDA_MPI)
+      add_definitions(-DUSE_CUDA_MPI=1)
+    endif()
     target_compile_definitions(torch_cpu PUBLIC USE_C10D_MPI)
   endif()
   # Pass USE_RPC in order to reduce use of
@@ -1406,6 +1409,7 @@ target_include_directories(torch_cpu SYSTEM PRIVATE "${Caffe2_DEPENDENCY_INCLUDE
 target_compile_definitions(torch_cpu PRIVATE CAFFE2_BUILD_MAIN_LIB)
 if(USE_CUDA)
   target_compile_definitions(torch_cuda PRIVATE TORCH_CUDA_BUILD_MAIN_LIB)
+  target_include_directories(torch_cpu SYSTEM PRIVATE "/usr/local/cuda/include")
 elseif(USE_ROCM)
   target_compile_definitions(torch_hip PRIVATE TORCH_HIP_BUILD_MAIN_LIB)
 endif()
@@ -1680,7 +1684,7 @@ if(BUILD_MOBILE_TEST)
   foreach(test_src ${ATen_MOBILE_TEST_SRCS})
     get_filename_component(test_name ${test_src} NAME_WE)
     add_executable(${test_name} "${test_src}")
-    target_link_libraries(${test_name} torch_library gtest_main)
+    target_link_libraries(${test_name} torch_library gtest_main /Users/llv23/opt/miniconda3/lib/libomp.dylib)
     target_include_directories(${test_name} PRIVATE $<INSTALL_INTERFACE:include>)
     target_include_directories(${test_name} PRIVATE $<BUILD_INTERFACE:${CMAKE_BINARY_DIR}/include>)
     target_include_directories(${test_name} PRIVATE ${ATen_CPU_INCLUDE})
@@ -1928,6 +1932,9 @@ if(BUILD_PYTHON)
   target_compile_definitions(torch_python PRIVATE BUILD_CAFFE2)
   if(USE_NUMPY)
     target_compile_options(caffe2_pybind11_state PRIVATE "-DUSE_NUMPY")
+    # Orlando; refer to how to fix issue: ../caffe2/python/pybind_state.h:27:10: fatal error: 'numpy/arrayobject.h' file not found
+    find_package(Python3 REQUIRED COMPONENTS NumPy)
+    target_include_directories(caffe2_pybind11_state PRIVATE ${Python3_NumPy_INCLUDE_DIRS})
     target_link_libraries(caffe2_pybind11_state  PRIVATE numpy::numpy)
   endif()
   if(NOT MSVC)
diff --git a/caffe2/core/macros.h.in b/caffe2/core/macros.h.in
index 4a2fe0c946..18de9be4d1 100644
--- a/caffe2/core/macros.h.in
+++ b/caffe2/core/macros.h.in
@@ -7,6 +7,7 @@
 
 #cmakedefine CAFFE2_BUILD_SHARED_LIBS
 #cmakedefine CAFFE2_FORCE_FALLBACK_CUDA_MPI
+#cmakedefine CAFFE2_USE_CUDA_MPI
 #cmakedefine CAFFE2_HAS_MKL_DNN
 #cmakedefine CAFFE2_HAS_MKL_SGEMM_PACK
 #cmakedefine CAFFE2_PERF_WITH_AVX
@@ -48,6 +49,7 @@
   {"CUDNN_VERSION", "${CUDNN_VERSION}"}, \
   {"USE_NCCL", "${USE_NCCL}"}, \
   {"USE_MPI", "${USE_MPI}"}, \
+  {"USE_CUDA_MPI", "${USE_CUDA_MPI}"}, \
   {"USE_GFLAGS", "${USE_GFLAGS}"}, \
   {"USE_GLOG", "${USE_GLOG}"}, \
   {"USE_GLOO", "${USE_GLOI}"}, \
diff --git a/caffe2/mpi/mpi_ops_gpu.cc b/caffe2/mpi/mpi_ops_gpu.cc
index bb645a5c78..cac6214c44 100644
--- a/caffe2/mpi/mpi_ops_gpu.cc
+++ b/caffe2/mpi/mpi_ops_gpu.cc
@@ -32,9 +32,23 @@ namespace caffe2 {
 #define CAFFE2_HAS_CUDA_MPI_ALLREDUCE 1
 #else // CAFFE2_OMPI_VERSION >= 10805
 #define CAFFE2_HAS_CUDA_MPI_ALLREDUCE 0
-#endif // CAFFE2_OMPI_VERSION >= 10805
 #endif // CAFFE2_OMPI_VERSION >= 2000
-#else // !OPEN_MPI
+#elif MVAPICH2_NUMVERSION // !OPEN_MPI
+#define CAFFE2_MV2_VERSION MVAPICH2_NUMVERSION
+#if CAFFE2_MV2_VERSION >= 20305300
+#include "mpi-ext.h"
+#if MPIX_CUDA_AWARE_SUPPORT
+#define CAFFE2_HAS_CUDA_MPI_BASICS 1
+#define CAFFE2_HAS_CUDA_MPI_ALLREDUCE 1
+#endif // MPIX_CUDA_AWARE_SUPPORT
+#else //CAFFE2_MV2_VERSION >= 235
+// In the case of MVAPICH2-GDR before 2.3.5, we don't have compile-time flags
+// // to figure out if CUDA is supported; as a result, we will assume that the
+// // user has built MVAPICH2-GDR with CUDA support.
+#define CAFFE2_HAS_CUDA_MPI_BASICS 1
+#define CAFFE2_HAS_CUDA_MPI_ALLREDUCE 1
+#endif //CAFFE2_MV2_VERSION >= 235
+#else // !OPEN_MPI && !MVAPICH_GDR
 // We have not really tested against other MPI environments, so let's go for a
 // safe path and basically say we don't have cuda-aware functions.
 #define CAFFE2_HAS_CUDA_MPI_BASICS 0
diff --git a/cmake/Dependencies.cmake b/cmake/Dependencies.cmake
index acc95842b6..ebf2aadd95 100644
--- a/cmake/Dependencies.cmake
+++ b/cmake/Dependencies.cmake
@@ -1059,6 +1059,7 @@ if(BUILD_PYTHON)
 
   # These should fill in the rest of the variables, like versions, but resepct
   # the variables we set above
+  set(CMAKE_PREFIX_PATH "/Users/llv23/opt/miniconda3")
   set(Python_ADDITIONAL_VERSIONS ${PYTHON_VERSION} 3.8)
   find_package(PythonInterp 3.0)
   find_package(PythonLibs 3.0)
@@ -1133,7 +1134,7 @@ if(APPLE)
   target_link_options(pybind::pybind11 INTERFACE -undefined dynamic_lookup)
 endif()
 
-# ---[ MPI
+# ---[ MPI 
 if(USE_MPI)
   find_package(MPI)
   if(MPI_CXX_FOUND)
@@ -1145,17 +1146,42 @@ if(USE_MPI)
     find_program(OMPI_INFO
       NAMES ompi_info
       HINTS ${MPI_CXX_LIBRARIES}/../bin)
-    if(OMPI_INFO)
+      if(OMPI_INFO)
       execute_process(COMMAND ${OMPI_INFO}
                       OUTPUT_VARIABLE _output)
       if(_output MATCHES "smcuda")
         message(STATUS "Found OpenMPI with CUDA support built.")
       else()
-        message(WARNING "OpenMPI found, but it is not built with CUDA support.")
-        set(CAFFE2_FORCE_FALLBACK_CUDA_MPI 1)
+        if(USE_CUDA_MPI)
+          if(USE_CUDA)
+            message(WARNING "OpenMPI with CUDA support not found, but forcing anyway.")
+          else()
+            message(WARNING "Force building for OpenMPI with CUDA.")
+          endif()
+          set(CAFFE2_USE_CUDA_MPI 1)
+        else()
+          message(WARNING "OpenMPI found, but it is not built with CUDA support.")
+          set(CAFFE2_FORCE_FALLBACK_CUDA_MPI 1)
+        endif()
       endif()
+    else()
+      find_program(MV2_INFO NAMES mpiname HINTS ${MPI_CXX_LIBRARIES}/../bin)
+      if(MV2_INFO)
+          execute_process(COMMAND ${MV2_INFO} "-a" OUTPUT_VARIABLE _output)
+          if(_output MATCHES "enable-cuda")
+              message(STATUS "Found MVAPICH2 with CUDA support built.")
+          else()
+              if(USE_CUDA_MPI)
+                  message(WARNING "MVAPICH2 with CUDA support not found, but forcing anyway.")
+                  set(CAFFE2_USE_CUDA_MPI 1)
+              else()
+                  message(WARNING "MVAPICH2 found, but it is not built with CUDA SUPPORT.")
+                  set(CAFFE2_FORCE_FALLBACK_CUDA_MPI 1)
+              endif()
+          endif()
+      endif()   
     endif()
-  else()
+      else()
     message(WARNING "Not compiling with MPI. Suppress this warning with -DUSE_MPI=OFF")
     caffe2_update_option(USE_MPI OFF)
   endif()
@@ -1337,6 +1363,11 @@ if(USE_UCC)
   endif()
 endif()
 
+# --[ CUDA
+if(USE_CUDA)
+  include_directories(SYSTEM /usr/local/cuda/include)
+endif()
+
 # ---[ CUB
 if(USE_CUDA)
   find_package(CUB)
diff --git a/cmake/Modules_CUDA_fix/upstream/FindCUDA/select_compute_arch.cmake b/cmake/Modules_CUDA_fix/upstream/FindCUDA/select_compute_arch.cmake
index 769ddacfcf..0cb1432a9a 100644
--- a/cmake/Modules_CUDA_fix/upstream/FindCUDA/select_compute_arch.cmake
+++ b/cmake/Modules_CUDA_fix/upstream/FindCUDA/select_compute_arch.cmake
@@ -27,55 +27,55 @@ endif()
 # See: https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#gpu-feature-list
 
 # This list will be used for CUDA_ARCH_NAME = All option
-set(CUDA_KNOWN_GPU_ARCHITECTURES  "Kepler" "Maxwell")
+set(CUDA_KNOWN_GPU_ARCHITECTURES  "Pascal")
 
 # This list will be used for CUDA_ARCH_NAME = Common option (enabled by default)
-set(CUDA_COMMON_GPU_ARCHITECTURES "3.5" "5.0")
+set(CUDA_COMMON_GPU_ARCHITECTURES "6.1")
 
 # This list is used to filter CUDA archs when autodetecting
-set(CUDA_ALL_GPU_ARCHITECTURES "3.5" "5.0")
+set(CUDA_ALL_GPU_ARCHITECTURES "6.1")
 
-if(CUDA_VERSION VERSION_GREATER "10.5")
-  list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Ampere")
-  list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.0")
-  list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.0")
+# if(CUDA_VERSION VERSION_GREATER "10.5")
+#   list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Ampere")
+#   list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.0")
+#   list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.0")
 
-  if(CUDA_VERSION VERSION_LESS "11.1")
-    set(CUDA_LIMIT_GPU_ARCHITECTURE "8.0")
-    list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.0+PTX")
-  endif()
-endif()
+#    if(CUDA_VERSION VERSION_LESS "11.1")
+#      set(CUDA_LIMIT_GPU_ARCHITECTURE "8.0")
+#      list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.0+PTX")
+#    endif()
+# endif()
 
-if(NOT CUDA_VERSION VERSION_LESS "11.1")
-  list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.6")
-  list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.6")
-  set(CUDA_LIMIT_GPU_ARCHITECUTRE "8.6")
+# if(NOT CUDA_VERSION VERSION_LESS "11.1")
+#   list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.6")
+#   list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.6")
+#   set(CUDA_LIMIT_GPU_ARCHITECUTRE "8.6")
 
-  if(CUDA_VERSION VERSION_LESS "11.8")
-    set(CUDA_LIMIT_GPU_ARCHITECTURE "8.9")
-    list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.6+PTX")
-  endif()
-endif()
+#   if(CUDA_VERSION VERSION_LESS "11.8")
+#     set(CUDA_LIMIT_GPU_ARCHITECTURE "8.9")
+#     list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.6+PTX")
+#   endif()
+# endif()
 
-if(NOT CUDA_VERSION VERSION_LESS "11.8")
-  list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Ada")
-  list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Hopper")
-  list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.9")
-  list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0")
-  list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.9")
-  list(APPEND CUDA_ALL_GPU_ARCHITECTURES "9.0")
+# if(NOT CUDA_VERSION VERSION_LESS "11.8")
+#   list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Ada")
+#   list(APPEND CUDA_KNOWN_GPU_ARCHITECTURES "Hopper")
+#   list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.9")
+#   list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0")
+#   list(APPEND CUDA_ALL_GPU_ARCHITECTURES "8.9")
+#   list(APPEND CUDA_ALL_GPU_ARCHITECTURES "9.0")
 
-  if(CUDA_VERSION VERSION_LESS "12.0")
-    set(CUDA_LIMIT_GPU_ARCHITECTURE "9.0")
-    list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.9+PTX")
-    list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0+PTX")
-  endif()
-endif()
+#   if(CUDA_VERSION VERSION_LESS "12.0")
+#     set(CUDA_LIMIT_GPU_ARCHITECTURE "9.0")
+#     list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "8.9+PTX")
+#     list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0+PTX")
+#   endif()
+# endif()
 
-if(NOT CUDA_VERSION VERSION_LESS "12.0")
-  list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0a")
-  list(APPEND CUDA_ALL_GPU_ARCHITECTURES "9.0a")
-endif()
+# if(NOT CUDA_VERSION VERSION_LESS "12.0")
+#   list(APPEND CUDA_COMMON_GPU_ARCHITECTURES "9.0a")
+#   list(APPEND CUDA_ALL_GPU_ARCHITECTURES "9.0a")
+# endif()
 
 ################################################################################################
 # A function for automatic detection of GPUs installed  (if autodetection is enabled)
diff --git a/cmake/Summary.cmake b/cmake/Summary.cmake
index 9c05aac28b..e7b6f7ae4f 100644
--- a/cmake/Summary.cmake
+++ b/cmake/Summary.cmake
@@ -184,6 +184,7 @@ function(caffe2_print_configuration_summary)
   message(STATUS "  USE_DISTRIBUTED       : ${USE_DISTRIBUTED}")
   if(${USE_DISTRIBUTED})
     message(STATUS "    USE_MPI               : ${USE_MPI}")
+    message(STATUS "    USE_CUDA_MPI          : ${USE_CUDA_MPI}")
     message(STATUS "    USE_GLOO              : ${USE_GLOO}")
     message(STATUS "    USE_GLOO_WITH_OPENSSL : ${USE_GLOO_WITH_OPENSSL}")
     message(STATUS "    USE_TENSORPIPE        : ${USE_TENSORPIPE}")
diff --git a/cmake/public/cuda.cmake b/cmake/public/cuda.cmake
index c7595774d8..34e1a731e5 100644
--- a/cmake/public/cuda.cmake
+++ b/cmake/public/cuda.cmake
@@ -46,7 +46,7 @@ if("${CMAKE_CXX_COMPILER_ID}" MATCHES "Clang")
 endif()
 enable_language(CUDA)
 if("X${CMAKE_CUDA_STANDARD}" STREQUAL "X" )
-  set(CMAKE_CUDA_STANDARD ${CMAKE_CXX_STANDARD})
+  set(CMAKE_CUDA_STANDARD 14)
 endif()
 set(CMAKE_CUDA_STANDARD_REQUIRED ON)
 
@@ -73,8 +73,8 @@ endif()
 message(STATUS "Caffe2: CUDA detected: " ${CUDA_VERSION})
 message(STATUS "Caffe2: CUDA nvcc is: " ${CUDA_NVCC_EXECUTABLE})
 message(STATUS "Caffe2: CUDA toolkit directory: " ${CUDA_TOOLKIT_ROOT_DIR})
-if(CUDA_VERSION VERSION_LESS 11.0)
-  message(FATAL_ERROR "PyTorch requires CUDA 11.0 or above.")
+if(CUDA_VERSION VERSION_LESS 10.2)
+  message(FATAL_ERROR "PyTorch requires CUDA 10.2 or above.")
 endif()
 
 if(CUDA_FOUND)
@@ -251,8 +251,8 @@ if(CAFFE2_USE_CUDNN)
       "Cannot find cuDNN library. Turning the option off")
     set(CAFFE2_USE_CUDNN OFF)
   else()
-    if(CUDNN_VERSION VERSION_LESS "8.0.0")
-      message(FATAL_ERROR "PyTorch requires cuDNN 8 and above.")
+    if(CUDNN_VERSION VERSION_LESS "7.6.5")
+      message(FATAL_ERROR "PyTorch requires cuDNN 7.6.5 and above.")
     endif()
   endif()
 
diff --git a/functorch/CMakeLists.txt b/functorch/CMakeLists.txt
index f2f3274587..a8e92a9393 100644
--- a/functorch/CMakeLists.txt
+++ b/functorch/CMakeLists.txt
@@ -1,6 +1,6 @@
 cmake_minimum_required(VERSION 3.18)
 project(functorch)
-set(CMAKE_CXX_STANDARD 17)
+set(CMAKE_CXX_STANDARD 14)
 
 include(GNUInstallDirs)
 include(CMakePackageConfigHelpers)
diff --git a/migration_note.md b/migration_note.md
new file mode 100644
index 0000000000..1b595d9612
--- /dev/null
+++ b/migration_note.md
@@ -0,0 +1,69 @@
+# Migration note
+
+```bash
+export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
+export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean # prepare
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+```
+
+
+## 1, Missing ATen cuda
+
+/usr/local/bin/ccache /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DUSE_CUDA_MPI=1 -DUSE_EXTERNAL_MZCRC -D_FILE_OFFSET_BITS=64 -Dcaffe2_nvrtc_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -D_LIBCPP_DISABLE_AVAILABILITY -fvisibility-inlines-hidden -DUSE_PTHREADPOOL -DNDEBUG -DUSE_KINETO -DLIBKINETO_NOCUPTI -DLIBKINETO_NOROCTRACER -DUSE_FBGEMM -DUSE_QNNPACK -DUSE_PYTORCH_QNNPACK -DUSE_XNNPACK -DSYMBOLICATE_MOBILE_DEBUG_HANDLE -O2 -fPIC -Wall -Wextra -Werror=return-type -Werror=non-virtual-dtor -Werror=braced-scalar-init -Wnarrowing -Wno-missing-field-initializers -Wno-type-limits -Wno-array-bounds -Wno-unknown-pragmas -Wno-unused-parameter -Wno-unused-function -Wno-unused-result -Wno-strict-overflow -Wno-strict-aliasing -Wvla-extension -Wnewline-eof -Winconsistent-missing-override -Winconsistent-missing-destructor-override -Wno-pass-failed -Wno-error=pedantic -Wno-error=old-style-cast -Wno-error=inconsistent-missing-override -Wno-error=inconsistent-missing-destructor-override -Wconstant-conversion -Wno-invalid-partial-specialization -Wno-aligned-allocation-unavailable -Wno-missing-braces -Qunused-arguments -fcolor-diagnostics -faligned-new -fno-math-errno -fno-trapping-math -Werror=format -Wno-unused-private-field -Wno-missing-braces -DHAVE_AVX2_CPU_DEFINITION -O3 -DNDEBUG -DNDEBUG -std=gnu++14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -mmacosx-version-min=10.9 -fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -MD -MT caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -MF caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o.d -o caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp
+
+## 2, Migrating from c10 to std
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get;
+  // https://stackoverflow.com/questions/56843413/stdbyte-is-not-member-of-std
+  enum class byte : unsigned char {};
+}// namespace std
+#else
+#include <variant>
+#endif
+
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/Optional.h>
+namespace std {
+  using c10::optional;
+}//namespace
+#else
+#include <optional>
+#endif
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#endif
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
+#if defined(__APPLE__) && defined(__MACH__)
+c10::visit
+#else
+#endif 
+
+MetadataShape compute_variant_shape(const at::Tensor& input) {
+  if (input.is_nested() && !input.unsafeGetTensorImpl()->is_python_dispatch()) {
+    auto nested_size = input._nested_tensor_size();
+#if defined(__APPLE__) && defined(__MACH__)
+    return MetadataShape{c10::in_place_type<at::Tensor>, nested_size};
+#else
+    return MetadataShape{std::in_place_type<at::Tensor>, nested_size};
+#endif
+  }
+#if defined(__APPLE__) && defined(__MACH__)
+  return MetadataShape{c10::in_place_type<SymIntSmallVec>, input.sym_sizes()};
+#else
+  return MetadataShape{std::in_place_type<SymIntSmallVec>, input.sym_sizes()};
+#endif
+}
diff --git a/test/cpp/api/CMakeLists.txt b/test/cpp/api/CMakeLists.txt
index a980a0de60..fad43526c9 100644
--- a/test/cpp/api/CMakeLists.txt
+++ b/test/cpp/api/CMakeLists.txt
@@ -48,7 +48,11 @@ endif()
 
 add_executable(test_api ${TORCH_API_TEST_SOURCES})
 target_include_directories(test_api PRIVATE ${ATen_CPU_INCLUDE})
-target_link_libraries(test_api PRIVATE torch gtest)
+if (${CMAKE_SYSTEM_NAME} MATCHES "Darwin")
+  target_link_libraries(test_api PRIVATE torch gtest -Xpreprocessor -fopenmp /Users/llv23/opt/miniconda3/lib/libomp.dylib /Users/llv23/opt/miniconda3/lib/libgomp.dylib)
+else()
+  target_link_libraries(test_api PRIVATE torch gtest)
+endif()
 if(NOT MSVC)
   target_compile_options_if_supported(test_api -Wno-unused-variable)
 endif()
diff --git a/third_party/tensorpipe b/third_party/tensorpipe
index 52791a2fd2..86433ef513 160000
--- a/third_party/tensorpipe
+++ b/third_party/tensorpipe
@@ -1 +1 @@
-Subproject commit 52791a2fd214b2a9dc5759d36725909c1daa7f2e
+Subproject commit 86433ef5131338e7e0e7331ff94a4af5cf840712
diff --git a/torch/csrc/api/include/torch/enum.h b/torch/csrc/api/include/torch/enum.h
index debfc6c785..afcc58539c 100644
--- a/torch/csrc/api/include/torch/enum.h
+++ b/torch/csrc/api/include/torch/enum.h
@@ -1,7 +1,16 @@
 #pragma once
 
 #include <string>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get;
+}// namespace std
+#else
 #include <variant>
+#endif
 
 #include <ATen/core/Reduction.h>
 #include <c10/util/Exception.h>
@@ -188,7 +197,11 @@ struct _compute_enum_name {
 
 template <typename V>
 std::string get_enum_name(V variant_enum) {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(enumtype::_compute_enum_name{}, variant_enum);
+#else
   return std::visit(enumtype::_compute_enum_name{}, variant_enum);
+#endif
 }
 
 template <typename V>
diff --git a/torch/csrc/api/include/torch/nn/functional/conv.h b/torch/csrc/api/include/torch/nn/functional/conv.h
index 22f8d04ab7..29b5c0894a 100644
--- a/torch/csrc/api/include/torch/nn/functional/conv.h
+++ b/torch/csrc/api/include/torch/nn/functional/conv.h
@@ -3,6 +3,12 @@
 #include <torch/nn/options/conv.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 namespace functional {
@@ -31,12 +37,21 @@ inline Tensor conv1d(
     const Conv1dFuncOptions::padding_t& padding,
     ExpandingArray<1> dilation,
     int64_t groups) {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      [&](const auto& pad) {
+        return torch::conv1d(
+            input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
+      },
+      padding);
+#else
   return std::visit(
       [&](const auto& pad) {
         return torch::conv1d(
             input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
       },
       padding);
+#endif
 }
 } // namespace detail
 #endif /* DOXYGEN_SHOULD_SKIP_THIS */
@@ -77,12 +92,21 @@ inline Tensor conv2d(
     const Conv2dFuncOptions::padding_t& padding,
     ExpandingArray<2> dilation,
     int64_t groups) {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      [&](const auto& pad) {
+        return torch::conv2d(
+            input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
+      },
+      padding);
+#else
   return std::visit(
       [&](const auto& pad) {
         return torch::conv2d(
             input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
       },
       padding);
+#endif
 }
 } // namespace detail
 #endif /* DOXYGEN_SHOULD_SKIP_THIS */
@@ -123,12 +147,21 @@ inline Tensor conv3d(
     const Conv3dFuncOptions::padding_t& padding,
     ExpandingArray<3> dilation,
     int64_t groups) {
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(
+      [&](const auto& pad) {
+        return torch::conv3d(
+            input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
+      },
+      padding);
+#else
   return std::visit(
       [&](const auto& pad) {
         return torch::conv3d(
             input, weight, bias, stride, padding_unwrap(pad), dilation, groups);
       },
       padding);
+#endif
 }
 } // namespace detail
 #endif /* DOXYGEN_SHOULD_SKIP_THIS */
diff --git a/torch/csrc/api/include/torch/nn/functional/embedding.h b/torch/csrc/api/include/torch/nn/functional/embedding.h
index 37f373774e..bede302da9 100644
--- a/torch/csrc/api/include/torch/nn/functional/embedding.h
+++ b/torch/csrc/api/include/torch/nn/functional/embedding.h
@@ -2,6 +2,15 @@
 
 #include <torch/nn/options/embedding.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 namespace functional {
diff --git a/torch/csrc/api/include/torch/nn/functional/upsampling.h b/torch/csrc/api/include/torch/nn/functional/upsampling.h
index f786b9d698..fb8a343f44 100644
--- a/torch/csrc/api/include/torch/nn/functional/upsampling.h
+++ b/torch/csrc/api/include/torch/nn/functional/upsampling.h
@@ -7,6 +7,17 @@
 #include <cmath>
 #include <utility>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 namespace functional {
diff --git a/torch/csrc/api/include/torch/nn/init.h b/torch/csrc/api/include/torch/nn/init.h
index d08d785f1d..7f36db896d 100644
--- a/torch/csrc/api/include/torch/nn/init.h
+++ b/torch/csrc/api/include/torch/nn/init.h
@@ -4,10 +4,38 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 namespace init {
 
+
+#if defined(__APPLE__) && defined(__MACH__)
+using NonlinearityType = c10::variant<
+    enumtype::kLinear,
+    enumtype::kConv1D,
+    enumtype::kConv2D,
+    enumtype::kConv3D,
+    enumtype::kConvTranspose1D,
+    enumtype::kConvTranspose2D,
+    enumtype::kConvTranspose3D,
+    enumtype::kSigmoid,
+    enumtype::kTanh,
+    enumtype::kReLU,
+    enumtype::kLeakyReLU>;
+
+using FanModeType = c10::variant<enumtype::kFanIn, enumtype::kFanOut>;
+#else
 using NonlinearityType = std::variant<
     enumtype::kLinear,
     enumtype::kConv1D,
@@ -22,6 +50,7 @@ using NonlinearityType = std::variant<
     enumtype::kLeakyReLU>;
 
 using FanModeType = std::variant<enumtype::kFanIn, enumtype::kFanOut>;
+#endif
 
 } // namespace init
 } // namespace nn
diff --git a/torch/csrc/api/include/torch/nn/modules/conv.h b/torch/csrc/api/include/torch/nn/modules/conv.h
index 68bd10c0db..f61a9fab2d 100644
--- a/torch/csrc/api/include/torch/nn/modules/conv.h
+++ b/torch/csrc/api/include/torch/nn/modules/conv.h
@@ -17,6 +17,17 @@
 #include <cstddef>
 #include <vector>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -42,6 +53,38 @@ class ConvNdImpl : public torch::nn::Cloneable<Derived> {
         options.out_channels() % options.groups() == 0,
         "out_channels must be divisible by groups");
 
+#if defined(__APPLE__) && defined(__MACH__)
+    c10::visit(
+        c10::overloaded(
+            [&](enumtype::kValid) {
+              _reversed_padding_repeated_twice.resize(2 * D);
+              std::fill_n(_reversed_padding_repeated_twice.begin(), 2 * D, 0);
+            },
+            [&](enumtype::kSame) {
+              for (const auto i : c10::irange(D)) {
+                const auto stride = (*options.stride())[i];
+                TORCH_CHECK(
+                    stride == 1,
+                    "padding='same' is not supported for strided convolutions");
+              }
+
+              _reversed_padding_repeated_twice.resize(2 * D);
+              for (const auto i : c10::irange(D)) {
+                const auto dilation = (*options.dilation())[i];
+                const auto kernel_size = (*options.kernel_size())[i];
+                const auto total_padding = dilation * (kernel_size - 1);
+                auto left_pad = total_padding / 2;
+                auto right_pad = total_padding - left_pad;
+                _reversed_padding_repeated_twice[2 * i] = left_pad;
+                _reversed_padding_repeated_twice[2 * i + 1] = right_pad;
+              }
+            },
+            [&](const ExpandingArray<D>& pad) {
+              _reversed_padding_repeated_twice =
+                  torch::nn::modules::utils::_reverse_repeat_vector(pad, 2);
+            }),
+        options.padding());
+#else
     std::visit(
         c10::overloaded(
             [&](enumtype::kValid) {
@@ -72,6 +115,7 @@ class ConvNdImpl : public torch::nn::Cloneable<Derived> {
                   torch::nn::modules::utils::_reverse_repeat_vector(pad, 2);
             }),
         options.padding());
+#endif
 
     if (options.transposed()) {
       std::vector<int64_t> weight_sizes = {
@@ -121,6 +165,18 @@ class ConvNdImpl : public torch::nn::Cloneable<Derived> {
            << "(" << options.in_channels() << ", " << options.out_channels()
            << ", kernel_size=" << options.kernel_size()
            << ", stride=" << options.stride();
+#if defined(__APPLE__) && defined(__MACH__)
+    c10::visit(
+        c10::overloaded(
+            [&](enumtype::kValid) { stream << ", padding='valid'"; },
+            [&](enumtype::kSame) { stream << ", padding='same'"; },
+            [&](const ExpandingArray<D>& pad) {
+              if (*pad != *ExpandingArray<D>(0)) {
+                stream << ", padding=" << pad;
+              }
+            }),
+        options.padding());
+#else
     std::visit(
         c10::overloaded(
             [&](enumtype::kValid) { stream << ", padding='valid'"; },
@@ -131,6 +187,7 @@ class ConvNdImpl : public torch::nn::Cloneable<Derived> {
               }
             }),
         options.padding());
+#endif
     if (*options.dilation() != *ExpandingArray<D>(1)) {
       stream << ", dilation=" << options.dilation();
     }
diff --git a/torch/csrc/api/include/torch/nn/options/conv.h b/torch/csrc/api/include/torch/nn/options/conv.h
index 0b5b5b1b3f..91d6345441 100644
--- a/torch/csrc/api/include/torch/nn/options/conv.h
+++ b/torch/csrc/api/include/torch/nn/options/conv.h
@@ -11,6 +11,20 @@ namespace nn {
 
 namespace detail {
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+typedef c10::variant<
+    enumtype::kZeros,
+    enumtype::kReflect,
+    enumtype::kReplicate,
+    enumtype::kCircular>
+    conv_padding_mode_t;
+
+template <size_t D>
+using conv_padding_t =
+    c10::variant<ExpandingArray<D>, enumtype::kValid, enumtype::kSame>;
+#else
+#include <variant>
 typedef std::variant<
     enumtype::kZeros,
     enumtype::kReflect,
@@ -21,6 +35,7 @@ typedef std::variant<
 template <size_t D>
 using conv_padding_t =
     std::variant<ExpandingArray<D>, enumtype::kValid, enumtype::kSame>;
+#endif
 
 /// Options for a `D`-dimensional convolution or convolution transpose module.
 template <size_t D>
diff --git a/torch/csrc/api/include/torch/nn/options/embedding.h b/torch/csrc/api/include/torch/nn/options/embedding.h
index d8d0671630..957dd7be3c 100644
--- a/torch/csrc/api/include/torch/nn/options/embedding.h
+++ b/torch/csrc/api/include/torch/nn/options/embedding.h
@@ -5,6 +5,12 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -101,8 +107,13 @@ struct TORCH_API EmbeddingFuncOptions {
 
 // ============================================================================
 
+#if defined(__APPLE__) && defined(__MACH__)
+typedef c10::variant<enumtype::kSum, enumtype::kMean, enumtype::kMax>
+    EmbeddingBagMode;
+#else
 typedef std::variant<enumtype::kSum, enumtype::kMean, enumtype::kMax>
     EmbeddingBagMode;
+#endif
 
 /// Options for the `EmbeddingBag` module.
 ///
diff --git a/torch/csrc/api/include/torch/nn/options/loss.h b/torch/csrc/api/include/torch/nn/options/loss.h
index c9eb2b66f3..f167314058 100644
--- a/torch/csrc/api/include/torch/nn/options/loss.h
+++ b/torch/csrc/api/include/torch/nn/options/loss.h
@@ -5,6 +5,12 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -15,8 +21,13 @@ namespace nn {
 /// L1Loss model(L1LossOptions(torch::kNone));
 /// ```
 struct TORCH_API L1LossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(L1LossOptions, reduction, kNone, kMean, kSum)
 
@@ -48,12 +59,21 @@ using L1LossFuncOptions = L1LossOptions;
 /// model(KLDivLossOptions().reduction(torch::kNone).log_target(false));
 /// ```
 struct TORCH_API KLDivLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<
+      enumtype::kNone,
+      enumtype::kBatchMean,
+      enumtype::kSum,
+      enumtype::kMean>
+      reduction_t;
+#else
   typedef std::variant<
       enumtype::kNone,
       enumtype::kBatchMean,
       enumtype::kSum,
       enumtype::kMean>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG4(
       KLDivLossOptions,
@@ -95,8 +115,13 @@ using KLDivFuncOptions = KLDivLossOptions;
 /// MSELoss model(MSELossOptions(torch::kNone));
 /// ```
 struct TORCH_API MSELossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(MSELossOptions, reduction, kNone, kMean, kSum)
 
@@ -128,8 +153,13 @@ using MSELossFuncOptions = MSELossOptions;
 /// BCELoss model(BCELossOptions().reduction(torch::kNone).weight(weight));
 /// ```
 struct TORCH_API BCELossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// A manual rescaling weight given to the loss of each batch element.
   TORCH_ARG(Tensor, weight) = {};
@@ -163,8 +193,13 @@ using BinaryCrossEntropyFuncOptions = BCELossOptions;
 /// model(HingeEmbeddingLossOptions().margin(4).reduction(torch::kNone));
 /// ```
 struct TORCH_API HingeEmbeddingLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// Specifies the threshold for which the distance of a negative sample must
   /// reach in order to incur zero loss. Default: 1
@@ -197,8 +232,13 @@ using HingeEmbeddingLossFuncOptions = HingeEmbeddingLossOptions;
 /// MultiMarginLoss model(MultiMarginLossOptions().margin(2).weight(weight));
 /// ```
 struct TORCH_API MultiMarginLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// Has a default value of :math:`1`. :math:`1` and :math:`2`
   /// are the only supported values.
@@ -242,8 +282,13 @@ using MultiMarginLossFuncOptions = MultiMarginLossOptions;
 /// CosineEmbeddingLoss model(CosineEmbeddingLossOptions().margin(0.5));
 /// ```
 struct TORCH_API CosineEmbeddingLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// Specifies the threshold for which the distance of a negative sample must
   /// reach in order to incur zero loss. Should be a number from -1 to 1, 0
@@ -277,8 +322,13 @@ using CosineEmbeddingLossFuncOptions = CosineEmbeddingLossOptions;
 /// MultiLabelMarginLoss model(MultiLabelMarginLossOptions(torch::kNone));
 /// ```
 struct TORCH_API MultiLabelMarginLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(
       MultiLabelMarginLossOptions,
@@ -318,8 +368,13 @@ using MultilabelMarginLossFuncOptions = MultiLabelMarginLossOptions;
 /// SoftMarginLoss model(SoftMarginLossOptions(torch::kNone));
 /// ```
 struct TORCH_API SoftMarginLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(
       SoftMarginLossOptions,
@@ -360,8 +415,13 @@ using SoftMarginLossFuncOptions = SoftMarginLossOptions;
 /// model(MultiLabelSoftMarginLossOptions().reduction(torch::kNone).weight(weight));
 /// ```
 struct TORCH_API MultiLabelSoftMarginLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// A manual rescaling weight given to each
   /// class. If given, it has to be a Tensor of size `C`. Otherwise, it is
@@ -400,8 +460,13 @@ using MultilabelSoftMarginLossFuncOptions = MultiLabelSoftMarginLossOptions;
 /// model(TripletMarginLossOptions().margin(3).p(2).eps(1e-06).swap(false));
 /// ```
 struct TORCH_API TripletMarginLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// Specifies the threshold for which the distance of a negative sample must
   /// reach in order to incur zero loss. Default: 1
@@ -442,8 +507,13 @@ using TripletMarginLossFuncOptions = TripletMarginLossOptions;
 /// model(TripletMarginWithDistanceLossOptions().margin(3).swap(false));
 /// ```
 struct TORCH_API TripletMarginWithDistanceLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
   typedef std::function<Tensor(const Tensor&, const Tensor&)>
       distance_function_t;
 
@@ -493,8 +563,13 @@ using TripletMarginWithDistanceLossFuncOptions =
 /// model(CTCLossOptions().blank(42).zero_infinity(false).reduction(torch::kSum));
 /// ```
 struct TORCH_API CTCLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// blank label. Default `0`.
   TORCH_ARG(int64_t, blank) = 0;
@@ -530,8 +605,13 @@ using CTCLossFuncOptions = CTCLossOptions;
 /// SmoothL1Loss model(SmoothL1LossOptions().reduction(torch::kNone).beta(0.5));
 /// ```
 struct TORCH_API SmoothL1LossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(
       SmoothL1LossOptions,
@@ -574,8 +654,13 @@ using SmoothL1LossFuncOptions = SmoothL1LossOptions;
 /// HuberLoss model(HuberLossOptions().reduction(torch::kNone).delta(0.5));
 /// ```
 struct TORCH_API HuberLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   TORCH_OPTIONS_CTOR_VARIANT_ARG3(
       HuberLossOptions,
@@ -618,8 +703,13 @@ using HuberLossFuncOptions = HuberLossOptions;
 /// model(PoissonNLLLossOptions().log_input(false).full(true).eps(0.42).reduction(torch::kSum));
 /// ```
 struct TORCH_API PoissonNLLLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// if true the loss is computed as `exp(input) - target * input`,
   /// if false the loss is `input - target * log(input + eps)`.
@@ -659,8 +749,13 @@ using PoissonNLLLossFuncOptions = PoissonNLLLossOptions;
 /// model(MarginRankingLossOptions().margin(0.5).reduction(torch::kSum));
 /// ```
 struct TORCH_API MarginRankingLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// Has a default value of `0`.
   TORCH_ARG(double, margin) = 0;
@@ -692,8 +787,13 @@ using MarginRankingLossFuncOptions = MarginRankingLossOptions;
 /// NLLLoss model(NLLLossOptions().ignore_index(-100).reduction(torch::kMean));
 /// ```
 struct TORCH_API NLLLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// A manual rescaling weight given to each
   /// class. If given, it has to be a Tensor of size `C`. Otherwise, it is
@@ -731,8 +831,13 @@ using NLLLossFuncOptions = NLLLossOptions;
 /// model(CrossEntropyLossOptions().ignore_index(-100).reduction(torch::kMean));
 /// ```
 struct TORCH_API CrossEntropyLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
 
   /// A manual rescaling weight given to each class. If given, has to be a
   /// Tensor of size C
@@ -771,8 +876,13 @@ using CrossEntropyFuncOptions = CrossEntropyLossOptions;
 /// model(BCEWithLogitsLossOptions().reduction(torch::kNone).weight(weight));
 /// ```
 struct TORCH_API BCEWithLogitsLossOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
+      reduction_t;
+#else
   typedef std::variant<enumtype::kNone, enumtype::kMean, enumtype::kSum>
       reduction_t;
+#endif
   /// A manual rescaling weight given to the loss of each batch element.
   /// If given, has to be a Tensor of size `nbatch`.
   TORCH_ARG(Tensor, weight) = {};
diff --git a/torch/csrc/api/include/torch/nn/options/padding.h b/torch/csrc/api/include/torch/nn/options/padding.h
index 8b8312f78e..d74802bcc3 100644
--- a/torch/csrc/api/include/torch/nn/options/padding.h
+++ b/torch/csrc/api/include/torch/nn/options/padding.h
@@ -6,6 +6,12 @@
 #include <torch/expanding_array.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -194,12 +200,21 @@ namespace functional {
 /// 2}).mode(torch::kReplicate));
 /// ```
 struct TORCH_API PadFuncOptions {
+#if defined(__APPLE__) && defined(__clang__)
+  typedef c10::variant<
+      enumtype::kConstant,
+      enumtype::kReflect,
+      enumtype::kReplicate,
+      enumtype::kCircular>
+      mode_t;
+#else
   typedef std::variant<
       enumtype::kConstant,
       enumtype::kReflect,
       enumtype::kReplicate,
       enumtype::kCircular>
       mode_t;
+#endif
 
   PadFuncOptions(std::vector<int64_t> pad);
 
diff --git a/torch/csrc/api/include/torch/nn/options/rnn.h b/torch/csrc/api/include/torch/nn/options/rnn.h
index 133acc5002..395b55fbf4 100644
--- a/torch/csrc/api/include/torch/nn/options/rnn.h
+++ b/torch/csrc/api/include/torch/nn/options/rnn.h
@@ -5,6 +5,12 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -12,12 +18,22 @@ namespace detail {
 
 /// Common options for RNN, LSTM and GRU modules.
 struct TORCH_API RNNOptionsBase {
+
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<
+      enumtype::kLSTM,
+      enumtype::kGRU,
+      enumtype::kRNN_TANH,
+      enumtype::kRNN_RELU>
+      rnn_options_base_mode_t;
+#else
   typedef std::variant<
       enumtype::kLSTM,
       enumtype::kGRU,
       enumtype::kRNN_TANH,
       enumtype::kRNN_RELU>
       rnn_options_base_mode_t;
+#endif
 
   RNNOptionsBase(
       rnn_options_base_mode_t mode,
@@ -57,7 +73,11 @@ struct TORCH_API RNNOptionsBase {
 /// 64).num_layers(3).dropout(0.2).nonlinearity(torch::kTanh));
 /// ```
 struct TORCH_API RNNOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kTanh, enumtype::kReLU> nonlinearity_t;
+#else
   typedef std::variant<enumtype::kTanh, enumtype::kReLU> nonlinearity_t;
+#endif
 
   RNNOptions(int64_t input_size, int64_t hidden_size);
 
@@ -180,7 +200,11 @@ struct TORCH_API RNNCellOptionsBase {
 /// 10).bias(false).nonlinearity(torch::kReLU));
 /// ```
 struct TORCH_API RNNCellOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kTanh, enumtype::kReLU> nonlinearity_t;
+#else
   typedef std::variant<enumtype::kTanh, enumtype::kReLU> nonlinearity_t;
+#endif
 
   RNNCellOptions(int64_t input_size, int64_t hidden_size);
 
diff --git a/torch/csrc/api/include/torch/nn/options/transformerlayer.h b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
index cbd6af26a1..84e6221588 100644
--- a/torch/csrc/api/include/torch/nn/options/transformerlayer.h
+++ b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
@@ -5,13 +5,29 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
+#if defined(__APPLE__) && defined(__MACH__)
+using activation_t = c10::variant<
+    enumtype::kReLU,
+    enumtype::kGELU,
+    std::function<Tensor(const Tensor&)>>;
+#else
 using activation_t = std::variant<
     enumtype::kReLU,
     enumtype::kGELU,
     std::function<Tensor(const Tensor&)>>;
+#endif
 
 /// Options for the `TransformerEncoderLayer`
 ///
diff --git a/torch/csrc/api/include/torch/nn/options/upsampling.h b/torch/csrc/api/include/torch/nn/options/upsampling.h
index d03e5f2345..122df40912 100644
--- a/torch/csrc/api/include/torch/nn/options/upsampling.h
+++ b/torch/csrc/api/include/torch/nn/options/upsampling.h
@@ -8,6 +8,12 @@
 
 #include <vector>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 
@@ -27,6 +33,15 @@ struct TORCH_API UpsampleOptions {
 
   /// the upsampling algorithm: one of "nearest", "linear", "bilinear",
   /// "bicubic" and "trilinear". Default: "nearest"
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<
+      enumtype::kNearest,
+      enumtype::kLinear,
+      enumtype::kBilinear,
+      enumtype::kBicubic,
+      enumtype::kTrilinear>
+      mode_t;
+#else
   typedef std::variant<
       enumtype::kNearest,
       enumtype::kLinear,
@@ -34,6 +49,7 @@ struct TORCH_API UpsampleOptions {
       enumtype::kBicubic,
       enumtype::kTrilinear>
       mode_t;
+#endif
   TORCH_ARG(mode_t, mode) = torch::kNearest;
 
   /// if "True", the corner pixels of the input and output tensors are
@@ -54,6 +70,17 @@ namespace functional {
 /// F::InterpolateFuncOptions().size(std::vector<int64_t>({4})).mode(torch::kNearest));
 /// ```
 struct TORCH_API InterpolateFuncOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<
+      enumtype::kNearest,
+      enumtype::kLinear,
+      enumtype::kBilinear,
+      enumtype::kBicubic,
+      enumtype::kTrilinear,
+      enumtype::kArea,
+      enumtype::kNearestExact>
+      mode_t;
+#else
   typedef std::variant<
       enumtype::kNearest,
       enumtype::kLinear,
@@ -63,6 +90,7 @@ struct TORCH_API InterpolateFuncOptions {
       enumtype::kArea,
       enumtype::kNearestExact>
       mode_t;
+#endif
 
   /// output spatial sizes.
   TORCH_ARG(c10::optional<std::vector<int64_t>>, size) = c10::nullopt;
diff --git a/torch/csrc/api/include/torch/nn/options/vision.h b/torch/csrc/api/include/torch/nn/options/vision.h
index 814f4b6684..15ce0d0268 100644
--- a/torch/csrc/api/include/torch/nn/options/vision.h
+++ b/torch/csrc/api/include/torch/nn/options/vision.h
@@ -5,6 +5,12 @@
 #include <torch/enum.h>
 #include <torch/types.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace nn {
 namespace functional {
@@ -18,10 +24,17 @@ namespace functional {
 /// F::GridSampleFuncOptions().mode(torch::kBilinear).padding_mode(torch::kZeros).align_corners(true));
 /// ```
 struct TORCH_API GridSampleFuncOptions {
+#if defined(__APPLE__) && defined(__MACH__)
+  typedef c10::variant<enumtype::kBilinear, enumtype::kNearest> mode_t;
+  typedef c10::
+      variant<enumtype::kZeros, enumtype::kBorder, enumtype::kReflection>
+          padding_mode_t;
+#else
   typedef std::variant<enumtype::kBilinear, enumtype::kNearest> mode_t;
   typedef std::
       variant<enumtype::kZeros, enumtype::kBorder, enumtype::kReflection>
           padding_mode_t;
+#endif
 
   /// interpolation mode to calculate output values. Default: Bilinear
   TORCH_ARG(mode_t, mode) = torch::kBilinear;
diff --git a/torch/csrc/api/src/nn/modules/conv.cpp b/torch/csrc/api/src/nn/modules/conv.cpp
index 20be11f221..b1a9ddb116 100644
--- a/torch/csrc/api/src/nn/modules/conv.cpp
+++ b/torch/csrc/api/src/nn/modules/conv.cpp
@@ -15,6 +15,17 @@
 #include <utility>
 #include <vector>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace F = torch::nn::functional;
 
 static F::PadFuncOptions::mode_t _get_pad_mode_from_conv_padding_mode(
diff --git a/torch/csrc/autograd/autograd_not_implemented_fallback.cpp b/torch/csrc/autograd/autograd_not_implemented_fallback.cpp
index 469c482a2d..5fe7d4651c 100644
--- a/torch/csrc/autograd/autograd_not_implemented_fallback.cpp
+++ b/torch/csrc/autograd/autograd_not_implemented_fallback.cpp
@@ -13,7 +13,15 @@
 #include <torch/csrc/autograd/functions/basic_ops.h>
 #include <torch/csrc/autograd/functions/utils.h>
 
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/Optional.h>
+namespace std {
+  using c10::optional;
+}//namespace
+#else
 #include <optional>
+#endif
 #include <utility>
 #include <vector>
 
diff --git a/torch/csrc/autograd/function.h b/torch/csrc/autograd/function.h
index af6f7a77b6..c49fe37927 100644
--- a/torch/csrc/autograd/function.h
+++ b/torch/csrc/autograd/function.h
@@ -199,7 +199,11 @@ struct TORCH_API Node : std::enable_shared_from_this<Node> {
       bool is_tensor_subclass,
       bool is_nested) noexcept {
     uint32_t input_nr = input_metadata_.size();
+#if defined(__APPLE__) && defined(__MACH__)
+    auto meta_shape = MetadataShape{c10::in_place_type<SymIntSmallVec>, shape};
+#else
     auto meta_shape = MetadataShape{std::in_place_type<SymIntSmallVec>, shape};
+#endif
     input_metadata_.emplace_back(
         options, meta_shape, is_tensor_subclass, is_nested);
     return input_nr;
diff --git a/torch/csrc/autograd/input_metadata.cpp b/torch/csrc/autograd/input_metadata.cpp
index 723303fe70..ecc15297c2 100644
--- a/torch/csrc/autograd/input_metadata.cpp
+++ b/torch/csrc/autograd/input_metadata.cpp
@@ -3,6 +3,20 @@
 // TODO: we may be able to move some imports from input_metadata.h to here, but
 // it seems that function.h transitively depends on some of them.
 
+
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::holds_alternative;
+  using ::c10::get;
+  // https://stackoverflow.com/questions/56843413/stdbyte-is-not-member-of-std
+  // enum class byte : unsigned char {};
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace autograd {
 
@@ -11,9 +25,17 @@ namespace {
 MetadataShape compute_variant_shape(const at::Tensor& input) {
   if (input.is_nested() && !input.unsafeGetTensorImpl()->is_python_dispatch()) {
     auto nested_size = input._nested_tensor_size();
+#if defined(__APPLE__) && defined(__MACH__)
+    return MetadataShape{c10::in_place_type<at::Tensor>, nested_size};
+#else
     return MetadataShape{std::in_place_type<at::Tensor>, nested_size};
+#endif
   }
+#if defined(__APPLE__) && defined(__MACH__)
+  return MetadataShape{c10::in_place_type<SymIntSmallVec>, input.sym_sizes()};
+#else
   return MetadataShape{std::in_place_type<SymIntSmallVec>, input.sym_sizes()};
+#endif
 }
 
 bool is_python_dispatch(const at::Tensor& tensor) {
diff --git a/torch/csrc/autograd/profiler_kineto.cpp b/torch/csrc/autograd/profiler_kineto.cpp
index 12fba7fa4d..3bb25ecc0e 100644
--- a/torch/csrc/autograd/profiler_kineto.cpp
+++ b/torch/csrc/autograd/profiler_kineto.cpp
@@ -28,6 +28,18 @@
 #include <stdexcept>
 #include <utility>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get;
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 #ifdef USE_KINETO
 #include <libkineto.h>
 #include <time_since_epoch.h>
@@ -100,6 +112,27 @@ auto parseArgData(
   std::vector<c10::IValue> concrete_inputs_list;
 
   for (const auto& i : c10::irange(input_shapes.size())) {
+#if defined(__APPLE__) && defined(__MACH__)
+    c10::visit(
+        c10::overloaded(
+            [&](const TensorMetadata& t) {
+              shapes[i] = t.sizes_;
+              shapes_for_kineto_event[i] = t.sizes_;
+              dtypes[i] = std::string(scalarTypeToTypeMeta(t.dtype_).name());
+            },
+            [&](const std::vector<TensorMetadata>& l) {
+              std::vector<std::vector<int64_t>> shape;
+              shape.reserve(l.size());
+              for (const auto& t : l) {
+                shape.emplace_back(t.sizes_);
+              }
+              shapes[i] = shape;
+              dtypes[i] = "TensorList";
+            },
+            [&](const c10::IValue& val) { dtypes[i] = "Scalar"; },
+            [&](const auto&) {}),
+        input_shapes[i]);
+#else
     std::visit(
         c10::overloaded(
             [&](const TensorMetadata& t) {
@@ -119,6 +152,7 @@ auto parseArgData(
             [&](const c10::IValue& val) { dtypes[i] = "Scalar"; },
             [&](const auto&) {}),
         input_shapes[i]);
+#endif
   }
 
   // If we recorded concrete inputs, then parse them
@@ -127,6 +161,21 @@ auto parseArgData(
     concrete_inputs_list.resize(input_shapes.size());
 
     for (const auto& i : c10::irange(input_shapes.size())) {
+#if defined(__APPLE__) && defined(__MACH__)
+      c10::visit(
+          c10::overloaded(
+              [&](const c10::IValue& val) { concrete_inputs_list[i] = val; },
+              [&](const auto&) {}),
+          input_shapes[i]);
+      c10::visit(
+          c10::overloaded(
+              [&](const c10::IValue& val) {
+                concrete_inputs_list[i] = val;
+                dtypes[i] = "ScalarList";
+              },
+              [&](const auto&) {}),
+          concrete_inputs[i]);
+#else
       std::visit(
           c10::overloaded(
               [&](const c10::IValue& val) { concrete_inputs_list[i] = val; },
@@ -140,6 +189,7 @@ auto parseArgData(
               },
               [&](const auto&) {}),
           concrete_inputs[i]);
+#endif
     }
   }
 
diff --git a/torch/csrc/distributed/c10d/GroupRegistry.cpp b/torch/csrc/distributed/c10d/GroupRegistry.cpp
index 18faff3f49..3b5be9aaeb 100644
--- a/torch/csrc/distributed/c10d/GroupRegistry.cpp
+++ b/torch/csrc/distributed/c10d/GroupRegistry.cpp
@@ -22,7 +22,11 @@ class GroupRegistry {
 
   c10::intrusive_ptr<c10d::ProcessGroup> resolve_group(
       const std::string& group_name) {
+#if defined(__APPLE__) && defined(__MACH__)
+    std::lock_guard read_lock(lock_);
+#else
     std::shared_lock read_lock(lock_);
+#endif
     auto it = registry_.find(group_name);
     TORCH_CHECK(
         it != registry_.end(),
@@ -40,7 +44,12 @@ class GroupRegistry {
 
  private:
   std::map<std::string, c10::weak_intrusive_ptr<c10d::ProcessGroup>> registry_;
+
+#if defined(__APPLE__) && defined(__MACH__)
+  std::mutex lock_;
+#else
   std::shared_mutex lock_;
+#endif
 };
 
 } // namespace
diff --git a/torch/csrc/distributed/c10d/ProcessGroupMPI.cpp b/torch/csrc/distributed/c10d/ProcessGroupMPI.cpp
index 939f120268..7772034457 100644
--- a/torch/csrc/distributed/c10d/ProcessGroupMPI.cpp
+++ b/torch/csrc/distributed/c10d/ProcessGroupMPI.cpp
@@ -9,7 +9,13 @@
 #include <c10/core/DeviceGuard.h>
 #include <c10/util/irange.h>
 
-#if defined(OPEN_MPI) && OPEN_MPI
+// #if defined(OPEN_MPI) && OPEN_MPI
+#ifndef OPEN_MPI
+#define OPEN_MPI 0
+#endif
+//Build flag USE_CUDA_MPI forces CUDA-Aware MPI support and removes run-time checks. 
+//USE_CUDA_MPI is meant for older MPI libraries that don't support MPIX_Query_cuda_support()
+#if (OPEN_MPI || (defined(MVAPICH2_NUMVERSION) && (MVAPICH2_NUMVERSION >= 20205300))) && !USE_CUDA_MPI
 #include <mpi-ext.h> // Needed for CUDA-aware check
 #endif
 
@@ -48,17 +54,20 @@ std::map<at::ScalarType, MPI_Datatype> mpiDatatype = {
 
 // Checking CUDA-aware MPI support, currently we only support CUDA aware
 // MPI ops through Open MPI
+// MPI ops through Open MPI and MVAPICH2-GDR
 bool cudaAwareMpiCheck() {
 // Run time check
-#if defined(MPIX_CUDA_AWARE_SUPPORT)
+#if !defined(USE_CUDA_MPI) && defined(MPIX_CUDA_AWARE_SUPPORT)
   if (MPIX_Query_cuda_support() == 1) {
     return true;
   } else {
     return false;
   }
-#else // !defined(MPIX_CUDA_AWARE_SUPPORT)
+#elif defined(USE_CUDA_MPI)
+  return true;
+#else // defined(USE_CUDA_MPI)
   return false;
-#endif // MPIX_CUDA_AWARE_SUPPORT
+#endif // MPIX_CUDA_AWARE_SUPPORT && !USE_CUDA_MPI
 }
 
 // Checking the input tensor's validity
diff --git a/torch/csrc/distributed/c10d/RankLocal.hpp b/torch/csrc/distributed/c10d/RankLocal.hpp
index 9b361172b2..b30e5bcbde 100644
--- a/torch/csrc/distributed/c10d/RankLocal.hpp
+++ b/torch/csrc/distributed/c10d/RankLocal.hpp
@@ -1,6 +1,9 @@
 
 #pragma once
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <mutex>
+#endif
 #include <shared_mutex>
 
 #include <torch/csrc/autograd/function.h>
@@ -31,6 +34,25 @@ class RankLocal {
     const auto node = torch::autograd::get_current_node();
     auto fwd_thread_id = node == nullptr ? at::RecordFunction::currentThreadId()
                                          : node->thread_id();
+#if defined(__APPLE__) && defined(__MACH__)
+    std::lock_guard lock(lock_);
+    {
+      auto it = thread_id_to_rank_local_.find(fwd_thread_id);
+      if (it != thread_id_to_rank_local_.end()) {
+        // Cache for non-autograd threads
+        if (node == nullptr) {
+          cached_ = &it->second;
+        }
+        return it->second;
+      }
+    }
+    auto [it, _] = thread_id_to_rank_local_.try_emplace(fwd_thread_id);
+    // Cache for non-autograd threads
+    if (node == nullptr) {
+      cached_ = &it->second;
+    }
+    return it->second;
+#else
     // Optimistically aquire the read lock first, since most likely we are in
     // an autograd thread and the object has already been constructed.
     {
@@ -52,13 +74,18 @@ class RankLocal {
       cached_ = &it->second;
     }
     return it->second;
+#endif
   }
 
  private:
   RankLocal(){};
   thread_local static T* cached_;
   static std::unordered_map<uint64_t, T> thread_id_to_rank_local_;
+#if defined(__APPLE__) && defined(__MACH__)
+  static std::mutex lock_;
+#else
   static std::shared_mutex lock_;
+#endif
 };
 
 template <typename T>
@@ -67,7 +94,12 @@ thread_local T* RankLocal<T>::cached_ = nullptr;
 template <typename T>
 std::unordered_map<uint64_t, T> RankLocal<T>::thread_id_to_rank_local_;
 
+#if defined(__APPLE__) && defined(__MACH__)
+template <typename T>
+std::mutex RankLocal<T>::lock_;
+#else
 template <typename T>
 std::shared_mutex RankLocal<T>::lock_;
+#endif
 
 } // namespace c10d
diff --git a/torch/csrc/jit/api/module.h b/torch/csrc/jit/api/module.h
index 6c49b695cb..08a9e5cb40 100644
--- a/torch/csrc/jit/api/module.h
+++ b/torch/csrc/jit/api/module.h
@@ -90,7 +90,9 @@ struct TORCH_API Module : public Object {
   Module() = default;
   Module(const Module&) = default;
   Module& operator=(const Module&) = default;
+#if !defined(__APPLE__) and !defined(__MACH__)
   Module(Module&&) noexcept = default;
+#endif
   Module& operator=(Module&&) noexcept = default;
   Module(
       c10::QualifiedName,
diff --git a/torch/csrc/jit/frontend/function_schema_parser.cpp b/torch/csrc/jit/frontend/function_schema_parser.cpp
index 4b681055bd..b1291c2d51 100644
--- a/torch/csrc/jit/frontend/function_schema_parser.cpp
+++ b/torch/csrc/jit/frontend/function_schema_parser.cpp
@@ -19,6 +19,16 @@ using c10::IValue;
 using c10::ListType;
 using c10::OperatorName;
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::holds_alternative;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch::jit {
 
 namespace {
diff --git a/torch/csrc/jit/frontend/function_schema_parser.h b/torch/csrc/jit/frontend/function_schema_parser.h
index a01ca7ad0b..d0bffbd0a7 100644
--- a/torch/csrc/jit/frontend/function_schema_parser.h
+++ b/torch/csrc/jit/frontend/function_schema_parser.h
@@ -3,7 +3,15 @@
 #include <ATen/core/function_schema.h>
 #include <c10/macros/Macros.h>
 #include <string>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::get;
+} // namespace std
+#else
 #include <variant>
+#endif
 
 namespace torch {
 namespace jit {
diff --git a/torch/csrc/jit/passes/symbolic_shape_analysis.cpp b/torch/csrc/jit/passes/symbolic_shape_analysis.cpp
index 96aa425b29..0030a061a8 100644
--- a/torch/csrc/jit/passes/symbolic_shape_analysis.cpp
+++ b/torch/csrc/jit/passes/symbolic_shape_analysis.cpp
@@ -42,6 +42,15 @@ but not limited to:
 
 static bool symbolic_shape_analysis_test_mode = false;
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace jit {
 
diff --git a/torch/csrc/jit/passes/symbolic_shape_analysis.h b/torch/csrc/jit/passes/symbolic_shape_analysis.h
index 824740792a..4701b8fa6a 100644
--- a/torch/csrc/jit/passes/symbolic_shape_analysis.h
+++ b/torch/csrc/jit/passes/symbolic_shape_analysis.h
@@ -4,7 +4,14 @@
 #include <torch/csrc/jit/ir/ir.h>
 #include <unordered_map>
 #include <utility>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+}// namespace std
+#else
 #include <variant>
+#endif
 
 namespace torch {
 namespace jit {
diff --git a/torch/csrc/jit/passes/symbolic_shape_cache.cpp b/torch/csrc/jit/passes/symbolic_shape_cache.cpp
index be8179f187..8851a5d991 100644
--- a/torch/csrc/jit/passes/symbolic_shape_cache.cpp
+++ b/torch/csrc/jit/passes/symbolic_shape_cache.cpp
@@ -4,6 +4,15 @@
 
 #include <utility>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 // SHAPE CACHING CODE
 namespace torch {
 namespace jit {
diff --git a/torch/csrc/jit/runtime/operator.h b/torch/csrc/jit/runtime/operator.h
index 681a5a8e34..38384e54e9 100644
--- a/torch/csrc/jit/runtime/operator.h
+++ b/torch/csrc/jit/runtime/operator.h
@@ -22,7 +22,15 @@
 #include <string>
 #include <unordered_map>
 #include <utility>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::get;
+} // namespace std
+#else
 #include <variant>
+#endif
 #include <vector>
 
 namespace torch::jit {
@@ -128,6 +136,21 @@ struct TORCH_API Operator {
             op_creator}) {}
 
   Operation getOperation(const Node* node = nullptr) const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(
+        c10::overloaded(
+            [](const C10Operator& op) { return op.op_; },
+            [node](const JitOnlyOperator& op) {
+              return c10::visit(
+                  c10::overloaded(
+                      [](const Operation& op) { return op; },
+                      [node](const OperationCreator& op_creator) {
+                        return op_creator(node);
+                      }),
+                  op.op_);
+            }),
+        op_);
+#else
     return std::visit(
         c10::overloaded(
             [](const C10Operator& op) { return op.op_; },
@@ -141,9 +164,26 @@ struct TORCH_API Operator {
                   op.op_);
             }),
         op_);
+#endif
   }
 
   Operation getOperationForDispatchKey(c10::DispatchKey dk) const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(
+        c10::overloaded(
+            [dk](const C10Operator& op) {
+              return Operation([op, dk](Stack& stack) {
+                op.handle_.callBoxedForDispatchKey(dk, stack);
+              });
+            },
+            [](const JitOnlyOperator& op) {
+              TORCH_CHECK(
+                  false,
+                  "calling a JIT operator for dispatch key is not supported");
+              return Operation(nullptr);
+            }),
+        op_);
+#else
     // TODO: some sort of caching mechanism?
     return std::visit(
         c10::overloaded(
@@ -159,9 +199,35 @@ struct TORCH_API Operator {
               return Operation(nullptr);
             }),
         op_);
+#endif
   }
 
   const FunctionSchema& schema() const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(
+        c10::overloaded(
+            [](const C10Operator& op) -> const FunctionSchema& {
+              return op.handle_.schema();
+            },
+            [](const JitOnlyOperator& op) -> const FunctionSchema& {
+              // we lazily parse schema initialized from strings so that
+              // we do less work during static operator registration
+              if (op.schema_.index() == 1) {
+                auto& unmaterializedSchema =
+                    std::get<UnparsedFunctionSchema>(op.schema_);
+                FunctionSchema schema =
+                    parseSchema(unmaterializedSchema.schema_string_);
+                if (unmaterializedSchema.alias_analysis_.has_value()) {
+                  // TODO What if it gets set later?
+                  schema.setAliasAnalysis(
+                      *unmaterializedSchema.alias_analysis_);
+                }
+                op.schema_ = std::move(schema);
+              }
+              return std::get<FunctionSchema>(op.schema_);
+            }),
+        op_);
+#else
     return std::visit(
         c10::overloaded(
             [](const C10Operator& op) -> const FunctionSchema& {
@@ -185,9 +251,23 @@ struct TORCH_API Operator {
               return std::get<FunctionSchema>(op.schema_);
             }),
         op_);
+#endif
   }
 
   c10::ArrayRef<at::Tag> getTags() const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(
+        c10::overloaded(
+            [](const C10Operator& op) { return op.handle_.getTags(); },
+            [](const JitOnlyOperator& op) {
+              // JitOnlyOperators don't have an c10::OperatorHandle or a way to
+              // specify tags. We're grandfathering them all into
+              // pt2_compliant_tag, but for anything else, please just stop
+              // using JitOnlyOperator.
+              return c10::ArrayRef<at::Tag>(kJitOnlyOperatorTags);
+            }),
+        op_);
+#else
     return std::visit(
         c10::overloaded(
             [](const C10Operator& op) { return op.handle_.getTags(); },
@@ -199,6 +279,7 @@ struct TORCH_API Operator {
               return c10::ArrayRef<at::Tag>(kJitOnlyOperatorTags);
             }),
         op_);
+#endif
   }
 
   bool isC10Op() const {
@@ -219,11 +300,19 @@ struct TORCH_API Operator {
   }
 
   bool hasOperation() const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(
+        c10::overloaded(
+            [](const C10Operator&) { return true; },
+            [](const JitOnlyOperator& op) { return op.op_.index() == 0; }),
+        op_);
+#else
     return std::visit(
         c10::overloaded(
             [](const C10Operator&) { return true; },
             [](const JitOnlyOperator& op) { return op.op_.index() == 0; }),
         op_);
+#endif
   }
 
  private:
diff --git a/torch/csrc/jit/tensorexpr/kernel.h b/torch/csrc/jit/tensorexpr/kernel.h
index 45658beb75..29ac967204 100644
--- a/torch/csrc/jit/tensorexpr/kernel.h
+++ b/torch/csrc/jit/tensorexpr/kernel.h
@@ -9,6 +9,15 @@
 #include <torch/csrc/jit/tensorexpr/lowerings.h>
 #include <torch/csrc/jit/tensorexpr/tensor.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace jit {
 namespace tensorexpr {
diff --git a/torch/csrc/jit/tensorexpr/lowerings.h b/torch/csrc/jit/tensorexpr/lowerings.h
index 6d8b2c433a..276596c931 100644
--- a/torch/csrc/jit/tensorexpr/lowerings.h
+++ b/torch/csrc/jit/tensorexpr/lowerings.h
@@ -8,6 +8,15 @@
 #include <torch/csrc/jit/tensorexpr/codegen.h>
 #include <torch/csrc/jit/tensorexpr/tensor.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::monostate;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace jit {
 namespace tensorexpr {
diff --git a/torch/csrc/jit/tensorexpr/operators/conv2d.cpp b/torch/csrc/jit/tensorexpr/operators/conv2d.cpp
index 3f29dad4c1..1650b836e8 100644
--- a/torch/csrc/jit/tensorexpr/operators/conv2d.cpp
+++ b/torch/csrc/jit/tensorexpr/operators/conv2d.cpp
@@ -5,6 +5,15 @@
 #include <torch/csrc/jit/tensorexpr/operators/misc.h>
 #include <torch/csrc/jit/tensorexpr/tensor.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::get_if;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace jit {
 namespace tensorexpr {
diff --git a/torch/csrc/profiler/collection.cpp b/torch/csrc/profiler/collection.cpp
index 4ebfe0a575..848386380d 100644
--- a/torch/csrc/profiler/collection.cpp
+++ b/torch/csrc/profiler/collection.cpp
@@ -11,6 +11,16 @@
 
 #include <fmt/format.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::holds_alternative;
+}// namespace std
+#else
+#include <variant>
+#endif
+
+
 #ifdef USE_KINETO
 #include <libkineto.h>
 #endif
diff --git a/torch/csrc/profiler/collection.h b/torch/csrc/profiler/collection.h
index 3678e04bfb..b6cbd27b32 100644
--- a/torch/csrc/profiler/collection.h
+++ b/torch/csrc/profiler/collection.h
@@ -5,7 +5,15 @@
 #include <mutex>
 #include <type_traits>
 #include <utility>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::variant;
+}// namespace std
+#else
 #include <variant>
+#endif
 
 #include <ATen/Context.h>
 #include <c10/core/Device.h>
@@ -354,12 +362,20 @@ struct TORCH_API Result : public std::enable_shared_from_this<Result> {
 
   template <typename T>
   decltype(auto) visit(T&& visitor) {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(std::forward<T>(visitor), extra_fields_);
+#else
     return std::visit(std::forward<T>(visitor), extra_fields_);
+#endif
   }
 
   template <typename T>
   decltype(auto) visit(T&& visitor) const {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit(std::forward<T>(visitor), extra_fields_);
+#else
     return std::visit(std::forward<T>(visitor), extra_fields_);
+#endif
   }
 
   template <typename T, typename Fn>
diff --git a/torch/csrc/profiler/data_flow.cpp b/torch/csrc/profiler/data_flow.cpp
index e719835d7c..1f5e24798d 100644
--- a/torch/csrc/profiler/data_flow.cpp
+++ b/torch/csrc/profiler/data_flow.cpp
@@ -3,6 +3,12 @@
 #include <c10/util/overloaded.h>
 #include <torch/csrc/profiler/collection.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#else
+#include <variant>
+#endif
+
 namespace torch {
 namespace profiler {
 namespace impl {
@@ -77,7 +83,11 @@ void calculateUniqueTensorIDs(
       result->visit(c10::overloaded(
           [&](ExtraFields<EventType::TorchOp>& torch_op) {
             for (auto& i : torch_op.inputs_) {
+#if defined(__APPLE__) && defined(__MACH__)
+              c10::visit(raw_tensors, i);
+#else
               std::visit(raw_tensors, i);
+#endif
             }
           },
           [&](ExtraFields<EventType::PyCall>& py_call) {
diff --git a/torch/csrc/profiler/util.cpp b/torch/csrc/profiler/util.cpp
index 2183a32f7d..656cdf532f 100644
--- a/torch/csrc/profiler/util.cpp
+++ b/torch/csrc/profiler/util.cpp
@@ -6,6 +6,15 @@
 #include <c10/util/irange.h>
 #include <fmt/format.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::holds_alternative;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 #ifdef USE_KINETO
 #include <libkineto.h>
 #endif
diff --git a/torch/csrc/profiler/util.h b/torch/csrc/profiler/util.h
index 4b565c691c..c35da5a16d 100644
--- a/torch/csrc/profiler/util.h
+++ b/torch/csrc/profiler/util.h
@@ -14,6 +14,17 @@
 #include <torch/csrc/Export.h>
 #include <torch/csrc/jit/frontend/source_range.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+  using ::c10::holds_alternative;
+  using ::c10::get;
+}// namespace std
+#else
+#include <variant>
+#endif
+
 // TODO: replace with pytorch/rfcs#43 when it is ready.
 #define SOFT_ASSERT(cond, ...)                         \
   [&]() -> bool {                                      \
@@ -60,8 +71,13 @@ TORCH_API void logSoftAssert(
     const char* cond,
     const std::string& args);
 
+#if defined(__APPLE__) && defined(__MACH__)
+using shape =
+    c10::variant<std::vector<int64_t>, std::vector<std::vector<int64_t>>>;
+#else
 using shape =
     std::variant<std::vector<int64_t>, std::vector<std::vector<int64_t>>>;
+#endif
 constexpr int TENSOR_LIST_DISPLAY_LENGTH_LIMIT = 30;
 
 std::string getNvtxStr(
diff --git a/torch/library.h b/torch/library.h
index 535bd7640f..e74b409bcc 100644
--- a/torch/library.h
+++ b/torch/library.h
@@ -68,6 +68,14 @@
 #include <ATen/core/enum_tag.h>
 #include <ATen/core/op_registration/op_registration.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+namespace std {
+  // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+  using ::c10::holds_alternative;
+}
+#endif
+
 namespace torch {
 
 #if defined C10_MOBILE
diff --git a/torch/utils/cpp_extension.py b/torch/utils/cpp_extension.py
index d2b2e16902..b490d262a4 100644
--- a/torch/utils/cpp_extension.py
+++ b/torch/utils/cpp_extension.py
@@ -564,7 +564,8 @@ class BuildExtension(build_ext):
             # overriding the option if the user explicitly passed it.
             cpp_format_prefix = '/{}:' if self.compiler.compiler_type == 'msvc' else '-{}='
             cpp_flag_prefix = cpp_format_prefix.format('std')
-            cpp_flag = cpp_flag_prefix + 'c++17'
+            import platform
+            cpp_flag = cpp_flag_prefix + 'c++17' if not platform.platform().startswith('macOS-10.13.6') else cpp_flag_prefix + 'c++14'
             if not any(flag.startswith(cpp_flag_prefix) for flag in cflags):
                 cflags.append(cpp_flag)
 
@@ -2177,6 +2178,9 @@ def _write_ninja_file_to_build_library(path,
     common_cflags += [f"{x}" for x in _get_pybind11_abi_build_flags()]
 
     common_cflags += [f'-I{include}' for include in user_includes]
+    print(f"ORLANDO system_includes: {system_includes}")
+    if '/usr/local/cuda/include' not in system_includes:
+        system_includes.append('/usr/local/cuda/include')
     common_cflags += [f'-isystem {include}' for include in system_includes]
 
     common_cflags += [f"{x}" for x in _get_glibcxx_abi_build_flags()]
@@ -2305,12 +2309,22 @@ def _write_ninja_file(path,
             else:
                 nvcc = _join_cuda_home('bin', 'nvcc')
         config.append(f'nvcc = {nvcc}')
+        
+    def replace_std17_with_std14(options):
+            options = [c for c in options if c != "-std=c++17"]
+            if options.find("-std=c++14") == -1:
+                options.append("-std=c++14")
+            return options
 
     if IS_HIP_EXTENSION:
         post_cflags = COMMON_HIP_FLAGS + post_cflags
     flags = [f'cflags = {" ".join(cflags)}']
+    # orlando: customized for cuda version, filtering -std=c++17
+    post_cflags = replace_std17_with_std14(post_cflags)
     flags.append(f'post_cflags = {" ".join(post_cflags)}')
     if with_cuda:
+        # orlando: customized for cuda version, filtering -std=c++17
+        cuda_post_cflags = replace_std17_with_std14(cuda_post_cflags)
         flags.append(f'cuda_cflags = {" ".join(cuda_cflags)}')
         flags.append(f'cuda_post_cflags = {" ".join(cuda_post_cflags)}')
     flags.append(f'cuda_dlink_post_cflags = {" ".join(cuda_dlink_post_cflags)}')
-- 
2.17.2 (Apple Git-113)


From 4a527314a989740f47bd372965a05ec0e4a1013f Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Mon, 12 Feb 2024 21:37:28 -0800
Subject: [PATCH 02/14] orlando - for updates of txt and cmakelists and refined
 cpp, cuh

---
 BUILD.bazel                                   |   3 +
 aten/src/ATen/CMakeLists.txt                  |   2 +-
 aten/src/ATen/ConjugateFallback.cpp           |   4 +-
 aten/src/ATen/NestedTensorImpl.h              |   4 +-
 aten/src/ATen/ParallelNative.h                |   4 +-
 aten/src/ATen/ScalarOps.h                     |   8 +-
 aten/src/ATen/SequenceNumber.cpp              |   4 +-
 aten/src/ATen/SequenceNumber.h                |   4 +-
 aten/src/ATen/TensorIndexing.h                |   4 +-
 aten/src/ATen/TensorNames.h                   |   4 +-
 aten/src/ATen/TracerMode.h                    |   4 +-
 aten/src/ATen/core/DistributionsHelper.h      |  23 ++
 aten/src/ATen/core/TransformationHelper.h     |  18 ++
 aten/src/ATen/core/boxing/impl/boxing.h       |   2 +-
 aten/src/ATen/core/ivalue.h                   |  27 ++
 aten/src/ATen/core/ivalue_inl.h               |  67 ++++-
 aten/src/ATen/cpu/vec/vec256/vec256_int.h     |  16 +-
 aten/src/ATen/cpu/vec/vec_base.h              |  16 +-
 aten/src/ATen/cuda/AsmUtils.cuh               |   4 +-
 aten/src/ATen/cuda/CUDABlas.cpp               |  70 ++----
 aten/src/ATen/cuda/CUDABlas.h                 |   4 +-
 aten/src/ATen/cuda/CUDAContext.cpp            |   4 +-
 aten/src/ATen/cuda/CUDADataType.h             |   4 +-
 aten/src/ATen/cuda/CUDADevice.h               |   4 +-
 aten/src/ATen/cuda/CUDAEvent.h                |   4 +-
 aten/src/ATen/cuda/CUDAGeneratorImpl.cpp      |   4 +-
 aten/src/ATen/cuda/CUDAGeneratorImpl.h        |   4 +-
 aten/src/ATen/cuda/CUDAGraph.cpp              |   4 +-
 aten/src/ATen/cuda/CUDAGraphsUtils.cuh        |   4 +-
 aten/src/ATen/cuda/CUDASparseBlas.cpp         |   4 +-
 aten/src/ATen/cuda/CUDASparseBlas.h           |   4 +-
 aten/src/ATen/cuda/CUDASparseDescriptors.cpp  |   4 +-
 aten/src/ATen/cuda/CUDASparseDescriptors.h    |   4 +-
 aten/src/ATen/cuda/CUDAUtils.h                |   4 +-
 aten/src/ATen/cuda/CachingHostAllocator.h     |   4 +-
 aten/src/ATen/cuda/CuSparseHandlePool.cpp     |   4 +-
 aten/src/ATen/cuda/EmptyTensor.cpp            |   4 +-
 aten/src/ATen/cuda/Exceptions.cpp             |   4 +-
 aten/src/ATen/cuda/PeerToPeerAccess.cpp       |   4 +-
 aten/src/ATen/cuda/PeerToPeerAccess.h         |   4 +-
 aten/src/ATen/cuda/PinnedMemoryAllocator.cpp  |   4 +-
 aten/src/ATen/cuda/PinnedMemoryAllocator.h    |   4 +-
 aten/src/ATen/cuda/ScanUtils.cuh              |   4 +-
 aten/src/ATen/cuda/ThrustAllocator.h          |   4 +-
 aten/src/ATen/cuda/cub-RadixSortKeys.cu       |   4 +-
 aten/src/ATen/cuda/detail/CUDAHooks.h         |   4 +-
 .../ATen/cuda/detail/DeviceThreadHandles.h    |   4 +-
 aten/src/ATen/cuda/detail/KernelUtils.h       |   4 +-
 aten/src/ATen/cuda/detail/LazyNVRTC.h         |   4 +-
 aten/src/ATen/cuda/detail/UnpackRaw.cuh       |   4 +-
 aten/src/ATen/cuda/jiterator.h                |   8 +-
 aten/src/ATen/cuda/jiterator_impl.h           |  32 ++-
 aten/src/ATen/cuda/llvm_basic.cpp             |   4 +-
 aten/src/ATen/cuda/llvm_complex.cpp           |   4 +-
 aten/src/ATen/cuda/llvm_jit_strings.h         |   4 +-
 aten/src/ATen/metal/Context.cpp               |   8 +-
 aten/src/ATen/native/Activation.h             |   4 +-
 aten/src/ATen/native/AdaptivePooling.h        |   4 +-
 aten/src/ATen/native/BatchLinearAlgebra.h     |   4 +-
 .../ATen/native/BatchLinearAlgebraKernel.cpp  |   4 +-
 aten/src/ATen/native/BinaryOps.h              |   4 +-
 aten/src/ATen/native/BucketizationUtils.h     |   4 +-
 aten/src/ATen/native/ComplexHelper.h          |   4 +-
 .../src/ATen/native/CompositeRandomAccessor.h |   4 +-
 .../native/CompositeRandomAccessorCommon.h    |   4 +-
 aten/src/ATen/native/ConvUtils.h              |   4 +-
 aten/src/ATen/native/ConvolutionMM3d.h        |   4 +-
 .../src/ATen/native/DilatedConvolutionUtils.h |   4 +-
 aten/src/ATen/native/DistributionTemplates.h  |   4 +-
 aten/src/ATen/native/EmbeddingBag.cpp         |   4 +-
 aten/src/ATen/native/EmbeddingBag.h           |   4 +-
 aten/src/ATen/native/ForeachOpsKernels.cpp    |   4 +-
 aten/src/ATen/native/ForeachUtils.h           |   4 +-
 aten/src/ATen/native/FractionalMaxPooling.h   |   4 +-
 aten/src/ATen/native/GridSampler.h            |   4 +-
 aten/src/ATen/native/GridSamplerUtils.h       |   4 +-
 aten/src/ATen/native/Histogram.h              |   4 +-
 aten/src/ATen/native/IndexKernel.h            |   4 +-
 aten/src/ATen/native/IndexingUtils.h          |   4 +-
 aten/src/ATen/native/Lerp.h                   |   4 +-
 aten/src/ATen/native/LinearAlgebra.h          |   4 +-
 aten/src/ATen/native/LinearAlgebraUtils.h     |   4 +-
 aten/src/ATen/native/LossMulti.h              |   4 +-
 aten/src/ATen/native/MathBitsFallback.h       |   4 +-
 aten/src/ATen/native/MaxPooling.h             |   4 +-
 aten/src/ATen/native/NonEmptyUtils.h          |   4 +-
 aten/src/ATen/native/NonSymbolicBC.h          |   4 +-
 aten/src/ATen/native/Normalization.h          |   4 +-
 aten/src/ATen/native/Padding.h                |   4 +-
 aten/src/ATen/native/Pool.h                   |   4 +-
 aten/src/ATen/native/RNN.h                    |   4 +-
 aten/src/ATen/native/ReduceAllOps.h           |   4 +-
 aten/src/ATen/native/ReduceOps.h              |   4 +-
 aten/src/ATen/native/ReduceOpsUtils.h         |   8 +-
 aten/src/ATen/native/ReductionType.h          |   4 +-
 aten/src/ATen/native/Repeat.h                 |   4 +-
 aten/src/ATen/native/Resize.h                 |   4 +-
 aten/src/ATen/native/ResizeCommon.h           |   4 +-
 aten/src/ATen/native/ScatterGatherChecks.h    |   4 +-
 aten/src/ATen/native/SobolEngineOpsUtils.h    |   4 +-
 aten/src/ATen/native/Sorting.h                |   4 +-
 aten/src/ATen/native/SortingUtils.h           |   4 +-
 aten/src/ATen/native/SparseTensorUtils.h      |   4 +-
 aten/src/ATen/native/SpectralOpsUtils.h       |   4 +-
 aten/src/ATen/native/StridedRandomAccessor.h  |   4 +-
 aten/src/ATen/native/TensorAdvancedIndexing.h |   4 +-
 .../ATen/native/TensorAdvancedIndexingUtils.h |   4 +-
 aten/src/ATen/native/TensorCompare.h          |   4 +-
 aten/src/ATen/native/TensorDimApply.h         |   4 +-
 aten/src/ATen/native/TensorFactories.h        |   4 +-
 .../native/TensorIteratorDynamicCasting.h     |   2 +-
 aten/src/ATen/native/TensorProperties.h       |   4 +-
 aten/src/ATen/native/TensorShape.h            |   4 +-
 aten/src/ATen/native/TensorTransformations.h  |   4 +-
 aten/src/ATen/native/TopKImpl.h               |   4 +-
 aten/src/ATen/native/TransposeType.h          |   4 +-
 aten/src/ATen/native/TriangularOpsUtils.h     |   4 +-
 aten/src/ATen/native/TypeProperties.h         |   4 +-
 aten/src/ATen/native/UnaryOps.h               |   4 +-
 aten/src/ATen/native/Unfold2d.h               |   4 +-
 aten/src/ATen/native/Unfold3d.h               |   4 +-
 aten/src/ATen/native/UnfoldBackward.h         |   4 +-
 aten/src/ATen/native/UpSample.h               |   4 +-
 aten/src/ATen/native/batch_norm.h             |   4 +-
 aten/src/ATen/native/cpu/Activation.cpp       |   4 +-
 .../ATen/native/cpu/AdaptiveAvgPoolKernel.cpp |   8 +-
 .../ATen/native/cpu/AdaptiveMaxPoolKernel.cpp |   8 +-
 aten/src/ATen/native/cpu/AvgPoolKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/BinaryOpsKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/BlasKernel.cpp       |   4 +-
 aten/src/ATen/native/cpu/CatKernel.cpp        |   4 +-
 .../ATen/native/cpu/ChannelShuffleKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/ComplexKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/CopyKernel.cpp       |   4 +-
 aten/src/ATen/native/cpu/CrossKernel.cpp      |   4 +-
 .../ATen/native/cpu/DepthwiseConvKernel.cpp   |   4 +-
 .../src/ATen/native/cpu/DistanceOpsKernel.cpp |   4 +-
 .../ATen/native/cpu/DistributionKernels.cpp   |   4 +-
 aten/src/ATen/native/cpu/FillKernel.cpp       |   4 +-
 .../ATen/native/cpu/FlashAttentionKernel.cpp  |   4 +-
 .../cpu/FunctionOfAMatrixUtilsKernel.cpp      |   4 +-
 .../src/ATen/native/cpu/GridSamplerKernel.cpp |   4 +-
 aten/src/ATen/native/cpu/HistogramKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/IndexKernel.cpp      |   4 +-
 .../ATen/native/cpu/LinearAlgebraKernel.cpp   |   4 +-
 aten/src/ATen/native/cpu/MaxPoolKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/MaxPooling.cpp       |   4 +-
 aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp  |   4 +-
 .../src/ATen/native/cpu/MultinomialKernel.cpp |   4 +-
 .../native/cpu/NativeMultiheadAttnKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/PaddingKernel.cpp    |   4 +-
 .../ATen/native/cpu/PixelShuffleKernel.cpp    |   4 +-
 .../ATen/native/cpu/PointwiseOpsKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/PowKernel.cpp        |   4 +-
 .../ATen/native/cpu/RangeFactoriesKernel.cpp  |   4 +-
 .../ATen/native/cpu/ReduceAllOpsKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/ReduceOpsKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/ReduceUtils.h        |   4 +-
 aten/src/ATen/native/cpu/RenormKernel.cpp     |   4 +-
 .../ATen/native/cpu/SampledAddmmKernel.cpp    |   4 +-
 .../ATen/native/cpu/ScatterGatherKernel.cpp   |   4 +-
 aten/src/ATen/native/cpu/SoftMaxKernel.cpp    |  24 +-
 aten/src/ATen/native/cpu/SortingKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/SparseFactories.cpp  |   4 +-
 aten/src/ATen/native/cpu/SpmmReduceKernel.h   |   4 +-
 aten/src/ATen/native/cpu/StackKernel.cpp      |   4 +-
 aten/src/ATen/native/cpu/SumKernel.cpp        |   4 +-
 .../ATen/native/cpu/TensorCompareKernel.cpp   |   4 +-
 aten/src/ATen/native/cpu/UnaryOpsKernel.cpp   |   4 +-
 aten/src/ATen/native/cpu/Unfold2d.cpp         |   4 +-
 .../ATen/native/cpu/UnfoldBackwardKernel.cpp  |   4 +-
 aten/src/ATen/native/cpu/UpSampleKernel.cpp   |   4 +-
 .../ATen/native/cpu/UpSampleMoreKernel.cpp    |   4 +-
 aten/src/ATen/native/cpu/WeightNormKernel.cpp |   4 +-
 aten/src/ATen/native/cpu/airy_ai.cpp          |   4 +-
 .../src/ATen/native/cpu/batch_norm_kernel.cpp |  28 +--
 .../src/ATen/native/cpu/group_norm_kernel.cpp |   4 +-
 .../src/ATen/native/cpu/layer_norm_kernel.cpp |   4 +-
 .../native/cpu/scaled_modified_bessel_k0.cpp  |   4 +-
 .../native/cpu/scaled_modified_bessel_k1.cpp  |   4 +-
 .../ATen/native/cpu/spherical_bessel_j0.cpp   |   4 +-
 aten/src/ATen/native/cuda/AbsKernel.cu        |   4 +-
 aten/src/ATen/native/cuda/Activation.cpp      |   4 +-
 .../ATen/native/cuda/ActivationEluKernel.cu   |   4 +-
 .../ATen/native/cuda/ActivationGeluKernel.cu  |   4 +-
 .../ATen/native/cuda/ActivationGluKernel.cu   |   4 +-
 .../native/cuda/ActivationHardshrinkKernel.cu |   4 +-
 .../cuda/ActivationHardsigmoidKernel.cu       |   4 +-
 .../native/cuda/ActivationHardswishKernel.cu  |   4 +-
 .../native/cuda/ActivationHardtanhKernel.cu   |   4 +-
 .../native/cuda/ActivationLeakyReluKernel.cu  |   4 +-
 .../native/cuda/ActivationLogSigmoidKernel.cu |   4 +-
 .../ATen/native/cuda/ActivationMishKernel.cu  |   4 +-
 .../ATen/native/cuda/ActivationPreluKernel.cu |   4 +-
 .../ATen/native/cuda/ActivationSiluKernel.cu  |   4 +-
 .../native/cuda/ActivationSoftplusKernel.cu   |   4 +-
 .../native/cuda/ActivationSoftshrinkKernel.cu |   4 +-
 .../native/cuda/ActivationThresholdKernel.cu  |   4 +-
 .../native/cuda/AdaptiveAveragePooling.cu     |   4 +-
 .../native/cuda/AdaptiveAveragePooling3d.cu   |   4 +-
 .../ATen/native/cuda/AdaptiveMaxPooling2d.cu  |   4 +-
 .../ATen/native/cuda/AdaptiveMaxPooling3d.cu  |   4 +-
 aten/src/ATen/native/cuda/AmpKernels.cu       |   4 +-
 aten/src/ATen/native/cuda/AveragePool2d.cu    |   4 +-
 aten/src/ATen/native/cuda/AveragePool3d.cu    |   4 +-
 .../native/cuda/BinaryBitwiseOpsKernels.cu    |   4 +-
 .../ATen/native/cuda/BinaryDivFloorKernel.cu  |   4 +-
 .../ATen/native/cuda/BinaryDivTrueKernel.cu   |   4 +-
 .../ATen/native/cuda/BinaryDivTruncKernel.cu  |   4 +-
 .../native/cuda/BinaryGeometricKernels.cu     |   4 +-
 .../native/cuda/BinaryLogicalOpsKernels.cu    |   4 +-
 .../cuda/BinaryMiscBackwardOpsKernels.cu      |   4 +-
 .../ATen/native/cuda/BinaryMiscOpsKernels.cu  |   4 +-
 aten/src/ATen/native/cuda/BinaryMulKernel.cu  |   4 +-
 .../ATen/native/cuda/BinaryRemainderKernel.cu |   4 +-
 .../ATen/native/cuda/BinaryShiftOpsKernels.cu |  12 +-
 aten/src/ATen/native/cuda/Blas.cpp            |   6 +-
 aten/src/ATen/native/cuda/Bucketization.cu    |   4 +-
 aten/src/ATen/native/cuda/CUDAScalar.cu       |   4 +-
 aten/src/ATen/native/cuda/Col2Im.cu           |   4 +-
 aten/src/ATen/native/cuda/CompareEQKernel.cu  |   4 +-
 aten/src/ATen/native/cuda/CompareKernels.cu   |   4 +-
 aten/src/ATen/native/cuda/ComplexKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/ConvolutionMM2d.cu  |   4 +-
 aten/src/ATen/native/cuda/Copy.cu             |   4 +-
 aten/src/ATen/native/cuda/CopysignKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/CrossKernel.cu      |   4 +-
 aten/src/ATen/native/cuda/CumminmaxKernel.cu  |   4 +-
 aten/src/ATen/native/cuda/CumprodKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/CumsumKernel.cu     |   4 +-
 aten/src/ATen/native/cuda/DepthwiseConv2d.cu  |   4 +-
 aten/src/ATen/native/cuda/DepthwiseConv3d.cu  |   4 +-
 aten/src/ATen/native/cuda/DilatedMaxPool2d.cu |   4 +-
 aten/src/ATen/native/cuda/DilatedMaxPool3d.cu |   4 +-
 aten/src/ATen/native/cuda/DistanceKernel.cu   |   4 +-
 .../ATen/native/cuda/DistributionBernoulli.cu |   4 +-
 .../native/cuda/DistributionCauchyKernel.cu   |   4 +-
 .../cuda/DistributionExponentialKernel.cu     |   4 +-
 .../cuda/DistributionGeometricKernel.cu       |   4 +-
 .../cuda/DistributionLogNormalKernel.cu       |   4 +-
 .../ATen/native/cuda/DistributionNormal.cu    |   4 +-
 .../native/cuda/DistributionRandomKernel.cu   |   4 +-
 .../ATen/native/cuda/DistributionUniform.cu   |   4 +-
 aten/src/ATen/native/cuda/Distributions.cpp   |   4 +-
 aten/src/ATen/native/cuda/Distributions.cu    |   4 +-
 aten/src/ATen/native/cuda/Dropout.cu          |   4 +-
 aten/src/ATen/native/cuda/Embedding.cu        |   4 +-
 .../native/cuda/EmbeddingBackwardKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/EmbeddingBag.cu     |   4 +-
 aten/src/ATen/native/cuda/Equal.cpp           |   4 +-
 aten/src/ATen/native/cuda/FillKernel.cu       |   4 +-
 .../ATen/native/cuda/FlattenIndicesKernel.cu  |   4 +-
 .../ATen/native/cuda/ForeachBinaryOpList.cu   |   4 +-
 .../ATen/native/cuda/ForeachBinaryOpScalar.cu |   4 +-
 .../native/cuda/ForeachBinaryOpScalarList.cu  |   4 +-
 .../cuda/ForeachBinaryOpScalarTensor.cu       |   4 +-
 aten/src/ATen/native/cuda/ForeachFunctors.cuh |   4 +-
 .../native/cuda/ForeachMinMaxFunctors.cuh     |   4 +-
 .../ATen/native/cuda/ForeachPointwiseOp.cu    |   4 +-
 aten/src/ATen/native/cuda/ForeachReduceOp.cu  |   4 +-
 aten/src/ATen/native/cuda/ForeachTernaryOp.cu |   4 +-
 aten/src/ATen/native/cuda/ForeachUnaryOp.cu   |   4 +-
 .../ATen/native/cuda/FractionalMaxPool2d.cu   |   4 +-
 .../ATen/native/cuda/FractionalMaxPool3d.cu   |   4 +-
 .../cuda/FunctionOfAMatrixUtilsKernel.cu      |   4 +-
 aten/src/ATen/native/cuda/FusedAdamKernel.cu  |   4 +-
 aten/src/ATen/native/cuda/GcdLcmKernel.cu     |   4 +-
 aten/src/ATen/native/cuda/GridSampler.cpp     |   4 +-
 aten/src/ATen/native/cuda/GridSampler.cu      |   4 +-
 aten/src/ATen/native/cuda/IGammaKernel.cu     |   4 +-
 aten/src/ATen/native/cuda/Im2Col.cu           |   4 +-
 aten/src/ATen/native/cuda/IndexKernel.cpp     |   4 +-
 aten/src/ATen/native/cuda/IndexKernel.cu      |   8 +-
 aten/src/ATen/native/cuda/Indexing.cu         |   4 +-
 aten/src/ATen/native/cuda/KernelUtils.cuh     |   6 +-
 .../ATen/native/cuda/LegacyThrustHelpers.cu   |   4 +-
 aten/src/ATen/native/cuda/Lerp.cu             |   4 +-
 aten/src/ATen/native/cuda/LinearAlgebra.cu    |   4 +-
 .../ATen/native/cuda/LinearAlgebraStubs.cpp   |   4 +-
 aten/src/ATen/native/cuda/LogAddExpKernel.cu  |   4 +-
 .../ATen/native/cuda/LogcumsumexpKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/Loops.cuh           |   4 +-
 aten/src/ATen/native/cuda/Loss.cu             |   4 +-
 aten/src/ATen/native/cuda/LossCTC.cu          |   4 +-
 .../native/cuda/MaxMinElementwiseKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/MaxUnpooling.cu     |   4 +-
 .../native/cuda/MultiLabelMarginCriterion.cu  |   4 +-
 aten/src/ATen/native/cuda/MultiMarginLoss.cu  |   4 +-
 .../src/ATen/native/cuda/MultiTensorApply.cuh |   4 +-
 .../src/ATen/native/cuda/MultinomialKernel.cu |  14 +-
 aten/src/ATen/native/cuda/NLLLoss2d.cu        |   4 +-
 .../cuda/NaiveConvolutionTranspose2d.cu       |   4 +-
 .../cuda/NaiveConvolutionTranspose3d.cu       |   4 +-
 .../native/cuda/NaiveDilatedConvolution.cu    |   4 +-
 aten/src/ATen/native/cuda/Nonzero.cu          |   4 +-
 aten/src/ATen/native/cuda/Normalization.cu    |   4 +-
 .../ATen/native/cuda/PointwiseOpsKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/PowKernel.cu        |   4 +-
 aten/src/ATen/native/cuda/RNN.cu              |   4 +-
 aten/src/ATen/native/cuda/Randperm.cu         |   4 +-
 aten/src/ATen/native/cuda/RangeFactories.cu   |  12 +-
 aten/src/ATen/native/cuda/RecordStream.cu     |   4 +-
 aten/src/ATen/native/cuda/Reduce.cu           |   4 +-
 .../ATen/native/cuda/ReduceAMinMaxKernel.cu   |   4 +-
 .../ATen/native/cuda/ReduceArgMaxKernel.cu    |   4 +-
 .../ATen/native/cuda/ReduceArgMinKernel.cu    |   4 +-
 .../src/ATen/native/cuda/ReduceLogicKernel.cu |   4 +-
 .../ATen/native/cuda/ReduceMaxValuesKernel.cu |   4 +-
 .../ATen/native/cuda/ReduceMinValuesKernel.cu |   4 +-
 .../ATen/native/cuda/ReduceMomentKernel.cu    |   4 +-
 aten/src/ATen/native/cuda/ReduceNormKernel.cu |   4 +-
 aten/src/ATen/native/cuda/ReduceOps.cpp       |   4 +-
 .../ATen/native/cuda/ReduceSumProdKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/ReflectionPad.cu    |   4 +-
 aten/src/ATen/native/cuda/RenormKernel.cu     |   4 +-
 aten/src/ATen/native/cuda/Repeat.cu           |   4 +-
 .../ATen/native/cuda/ReplicationPadding.cu    |   4 +-
 aten/src/ATen/native/cuda/Resize.cpp          |   4 +-
 aten/src/ATen/native/cuda/RreluWithNoise.cu   |   4 +-
 aten/src/ATen/native/cuda/ScanKernels.cpp     |   4 +-
 .../ATen/native/cuda/ScatterGatherKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/SegmentReduce.cu    |   4 +-
 aten/src/ATen/native/cuda/Shape.cu            |   4 +-
 aten/src/ATen/native/cuda/SoftMax.cu          |   4 +-
 aten/src/ATen/native/cuda/Sort.cpp            |   4 +-
 aten/src/ATen/native/cuda/Sort.cu             |  12 +-
 aten/src/ATen/native/cuda/SortImpl.cu         |   4 +-
 aten/src/ATen/native/cuda/SortStable.cu       |   4 +-
 aten/src/ATen/native/cuda/Sorting.cpp         |   4 +-
 aten/src/ATen/native/cuda/Sorting.cu          |   4 +-
 .../cuda/SparseBinaryOpIntersectionKernel.cu  |   4 +-
 aten/src/ATen/native/cuda/SparseMM.cu         |   4 +-
 aten/src/ATen/native/cuda/SpectralOps.cpp     |   4 +-
 aten/src/ATen/native/cuda/SpectralOps.cu      |   4 +-
 aten/src/ATen/native/cuda/StepKernel.cu       |   4 +-
 aten/src/ATen/native/cuda/TensorCompare.cpp   |   4 +-
 aten/src/ATen/native/cuda/TensorCompare.cu    |   4 +-
 aten/src/ATen/native/cuda/TensorFactories.cu  |   4 +-
 .../src/ATen/native/cuda/TensorModeKernel.cpp |   4 +-
 aten/src/ATen/native/cuda/TensorModeKernel.cu |   4 +-
 aten/src/ATen/native/cuda/TensorShapeCUDA.cpp |   4 +-
 aten/src/ATen/native/cuda/TensorTopK.cpp      |   4 +-
 aten/src/ATen/native/cuda/TensorTopK.cu       |   6 +-
 .../ATen/native/cuda/TensorTransformations.cu |   4 +-
 aten/src/ATen/native/cuda/TriangularOps.cu    |   4 +-
 .../ATen/native/cuda/UnaryComplexKernels.cu   |   4 +-
 .../ATen/native/cuda/UnaryFractionKernels.cu  |   4 +-
 .../src/ATen/native/cuda/UnaryGammaKernels.cu |   4 +-
 .../native/cuda/UnaryGeometricAcosKernel.cu   |   4 +-
 .../native/cuda/UnaryGeometricAcoshKernel.cu  |   4 +-
 .../native/cuda/UnaryGeometricAsinKernel.cu   |   4 +-
 .../native/cuda/UnaryGeometricAsinhKernel.cu  |   4 +-
 .../native/cuda/UnaryGeometricAtanKernel.cu   |   4 +-
 .../native/cuda/UnaryGeometricAtanhKernel.cu  |   4 +-
 .../native/cuda/UnaryGeometricCosKernel.cu    |   4 +-
 .../native/cuda/UnaryGeometricCoshKernel.cu   |   4 +-
 .../native/cuda/UnaryGeometricSinKernel.cu    |   4 +-
 .../native/cuda/UnaryGeometricSinhKernel.cu   |   4 +-
 .../native/cuda/UnaryGeometricTanKernel.cu    |   4 +-
 .../native/cuda/UnaryGeometricTanhKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/UnaryLogKernels.cu  |   4 +-
 aten/src/ATen/native/cuda/UnaryOpsKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/UnarySignKernels.cu |   4 +-
 .../ATen/native/cuda/UnarySpecialOpsKernel.cu |   4 +-
 .../ATen/native/cuda/UnfoldBackwardKernel.cu  |   4 +-
 aten/src/ATen/native/cuda/Unique.cu           |   4 +-
 aten/src/ATen/native/cuda/UniqueCub.cu        |   4 +-
 .../src/ATen/native/cuda/UpSampleBicubic2d.cu |   4 +-
 .../ATen/native/cuda/UpSampleBilinear2d.cu    |   4 +-
 aten/src/ATen/native/cuda/UpSampleLinear1d.cu |   4 +-
 .../src/ATen/native/cuda/UpSampleNearest1d.cu |   4 +-
 .../src/ATen/native/cuda/UpSampleNearest2d.cu |   4 +-
 .../src/ATen/native/cuda/UpSampleNearest3d.cu |   4 +-
 .../ATen/native/cuda/UpSampleTrilinear3d.cu   |   4 +-
 .../cuda/ValidateCompressedIndicesKernel.cu   |   4 +-
 aten/src/ATen/native/cuda/WeightNorm.cu       |   4 +-
 aten/src/ATen/native/cuda/ZetaKernel.cu       |   4 +-
 aten/src/ATen/native/cuda/airy_ai.cu          |   4 +-
 aten/src/ATen/native/cuda/bessel_j0.cu        |   4 +-
 aten/src/ATen/native/cuda/bessel_j1.cu        |   4 +-
 aten/src/ATen/native/cuda/bessel_y0.cu        |   4 +-
 aten/src/ATen/native/cuda/bessel_y1.cu        |   4 +-
 .../native/cuda/chebyshev_polynomial_t.cu     |   4 +-
 .../native/cuda/chebyshev_polynomial_u.cu     |   4 +-
 .../native/cuda/chebyshev_polynomial_v.cu     |   4 +-
 .../native/cuda/chebyshev_polynomial_w.cu     |   4 +-
 .../native/cuda/fused_adam_amsgrad_impl.cu    |   4 +-
 aten/src/ATen/native/cuda/fused_adam_impl.cu  |   4 +-
 .../src/ATen/native/cuda/group_norm_kernel.cu |   4 +-
 .../ATen/native/cuda/hermite_polynomial_h.cu  |   4 +-
 .../ATen/native/cuda/hermite_polynomial_he.cu |   4 +-
 aten/src/ATen/native/cuda/int4mm.cu           |   4 +-
 aten/src/ATen/native/cuda/jit_utils.cpp       |   4 +-
 .../ATen/native/cuda/laguerre_polynomial_l.cu |   4 +-
 .../src/ATen/native/cuda/layer_norm_kernel.cu |   4 +-
 .../ATen/native/cuda/legendre_polynomial_p.cu |   4 +-
 .../native/cuda/linalg/BatchLinearAlgebra.cpp |   4 +-
 .../cuda/linalg/BatchLinearAlgebraLib.cpp     |   4 +-
 .../cuda/linalg/BatchLinearAlgebraLibBlas.cpp |   4 +-
 .../ATen/native/cuda/modified_bessel_i0.cu    |   4 +-
 .../ATen/native/cuda/modified_bessel_i1.cu    |   4 +-
 .../ATen/native/cuda/modified_bessel_k0.cu    |   4 +-
 .../ATen/native/cuda/modified_bessel_k1.cu    |   4 +-
 .../native/cuda/scaled_modified_bessel_k0.cu  |   4 +-
 .../native/cuda/scaled_modified_bessel_k1.cu  |   4 +-
 .../cuda/shifted_chebyshev_polynomial_t.cu    |   4 +-
 .../cuda/shifted_chebyshev_polynomial_u.cu    |   4 +-
 .../cuda/shifted_chebyshev_polynomial_v.cu    |   4 +-
 .../cuda/shifted_chebyshev_polynomial_w.cu    |   4 +-
 .../ATen/native/cuda/spherical_bessel_j0.cu   |   4 +-
 aten/src/ATen/native/im2col.h                 |   4 +-
 aten/src/ATen/native/im2col_shape_check.h     |   4 +-
 aten/src/ATen/native/layer_norm.h             |   4 +-
 .../ATen/native/mkldnn/IDeepRegistration.cpp  |   4 +-
 aten/src/ATen/native/mkldnn/RNN.cpp           |   8 +-
 aten/src/ATen/native/mps/OperationUtils.h     |   4 +-
 aten/src/ATen/native/mps/OperationUtils.mm    |   4 +-
 aten/src/ATen/native/mps/TensorFactory.cpp    |   4 +-
 .../ATen/native/mps/operations/Activation.mm  |   4 +-
 .../native/mps/operations/AdaptivePooling.mm  |   4 +-
 .../ATen/native/mps/operations/BinaryKernel.h |   4 +-
 .../native/mps/operations/BinaryKernel.mm     |   4 +-
 .../ATen/native/mps/operations/BinaryOps.mm   |   4 +-
 .../ATen/native/mps/operations/BitwiseOps.mm  |   4 +-
 aten/src/ATen/native/mps/operations/Blas.mm   |   4 +-
 .../native/mps/operations/Bucketization.mm    |   4 +-
 .../ATen/native/mps/operations/ConstantOps.mm |   4 +-
 .../ATen/native/mps/operations/Convolution.mm |   4 +-
 aten/src/ATen/native/mps/operations/Copy.mm   |   4 +-
 .../ATen/native/mps/operations/CrossKernel.mm |   4 +-
 .../native/mps/operations/Distributions.mm    |   4 +-
 aten/src/ATen/native/mps/operations/Eye.mm    |   4 +-
 aten/src/ATen/native/mps/operations/Gamma.mm  |   4 +-
 .../ATen/native/mps/operations/GridSampler.mm |   4 +-
 .../native/mps/operations/HistogramKernel.mm  |   4 +-
 .../ATen/native/mps/operations/Indexing.mm    |   2 +-
 .../src/ATen/native/mps/operations/Inverse.mm |   2 +-
 aten/src/ATen/native/mps/operations/Lerp.mm   |   4 +-
 aten/src/ATen/native/mps/operations/Linear.mm |   4 +-
 .../native/mps/operations/LinearAlgebra.mm    |   4 +-
 .../src/ATen/native/mps/operations/LossOps.mm |   4 +-
 .../native/mps/operations/Normalization.mm    |   4 +-
 aten/src/ATen/native/mps/operations/Pad.mm    |   4 +-
 .../native/mps/operations/PixelShuffle.mm     |   4 +-
 .../native/mps/operations/PointwiseOps.mm     |   4 +-
 .../src/ATen/native/mps/operations/Pooling.mm |   4 +-
 .../native/mps/operations/RangeFactories.mm   |   4 +-
 .../ATen/native/mps/operations/ReduceOps.mm   |   4 +-
 .../native/mps/operations/RenormKernel.mm     |   4 +-
 aten/src/ATen/native/mps/operations/Repeat.mm |   4 +-
 aten/src/ATen/native/mps/operations/RnnOps.mm |   4 +-
 aten/src/ATen/native/mps/operations/Scalar.mm |   4 +-
 .../native/mps/operations/ScatterGather.mm    |   4 +-
 aten/src/ATen/native/mps/operations/Shape.mm  |   4 +-
 .../src/ATen/native/mps/operations/SoftMax.mm |   4 +-
 aten/src/ATen/native/mps/operations/Sort.mm   |   4 +-
 .../ATen/native/mps/operations/SummaryOps.mm  |   4 +-
 .../native/mps/operations/TensorCompare.mm    |   4 +-
 .../native/mps/operations/TriangularOps.mm    |   4 +-
 .../ATen/native/mps/operations/UnaryKernel.mm |   4 +-
 .../ATen/native/mps/operations/UnaryOps.mm    |   4 +-
 aten/src/ATen/native/mps/operations/Unique.mm |   4 +-
 .../ATen/native/mps/operations/UpSample.mm    |   4 +-
 aten/src/ATen/native/mps/operations/View.mm   |   4 +-
 .../ATen/native/mps/operations/WeightNorm.mm  |   4 +-
 aten/src/ATen/native/quantized/ConvUtils.h    |   4 +-
 aten/src/ATen/native/quantized/cpu/qconv.cpp  |   4 +-
 .../ATen/native/sparse/FlattenIndicesCommon.h |   4 +-
 .../native/sparse/FlattenIndicesKernel.cpp    |   4 +-
 aten/src/ATen/native/sparse/ParamUtils.cpp    |   4 +-
 aten/src/ATen/native/sparse/SoftMax.cpp       |   4 +-
 .../SparseBinaryOpIntersectionKernel.cpp      |   4 +-
 aten/src/ATen/native/sparse/SparseBlas.cpp    |   4 +-
 .../src/ATen/native/sparse/SparseBlasImpl.cpp |   4 +-
 .../ATen/native/sparse/SparseCsrTensor.cpp    |   4 +-
 .../ATen/native/sparse/SparseFactories.cpp    |   4 +-
 aten/src/ATen/native/sparse/SparseMatMul.cpp  |   4 +-
 aten/src/ATen/native/sparse/SparseTensor.cpp  |   4 +-
 .../ATen/native/sparse/SparseTensorMath.cpp   |   4 +-
 .../src/ATen/native/sparse/SparseUnaryOps.cpp |   4 +-
 .../ValidateCompressedIndicesKernel.cpp       |   4 +-
 .../native/sparse/cuda/SparseCUDABlas.cpp     |   8 +-
 .../sparse/cuda/SparseSemiStructuredLinear.cu | 137 +++++-----
 .../ATen/native/sparse/cuda/cuSPARSELtOps.cpp |   8 +-
 .../native/transformers/cuda/attention.cu     |  78 ++++++
 aten/src/ATen/native/utils/ParamsHash.h       |  21 +-
 aten/src/ATen/native/vol2col.h                |   4 +-
 .../ATen/native/xnnpack/AveragePooling.cpp    |   4 +-
 .../ATen/native/xnnpack/ChannelShuffle.cpp    |   4 +-
 aten/src/ATen/native/xnnpack/Common.h         |   8 +-
 aten/src/ATen/native/xnnpack/Convolution.cpp  |   4 +-
 aten/src/ATen/native/xnnpack/Convolution.h    |   4 +-
 aten/src/ATen/native/xnnpack/Engine.h         |   4 +-
 aten/src/ATen/native/xnnpack/Init.cpp         |   4 +-
 aten/src/ATen/native/xnnpack/Linear.cpp       |   4 +-
 aten/src/ATen/native/xnnpack/Linear.h         |   4 +-
 aten/src/ATen/native/xnnpack/MaxPooling.cpp   |   4 +-
 aten/src/ATen/native/xnnpack/OpContext.cpp    |   4 +-
 aten/src/ATen/native/xnnpack/OpContext.h      |   4 +-
 aten/src/ATen/native/xnnpack/Pooling.h        |   4 +-
 .../native/xnnpack/RegisterOpContextClass.cpp |   4 +-
 aten/src/ATen/native/xnnpack/Shim.cpp         |   4 +-
 aten/src/ATen/test/rng_test.h                 |   8 +
 aten/src/ATen/test/vec_test_all_types.h       |   3 +
 c10/util/C++17.h                              | 235 +++++++++++++++++-
 c10/util/FunctionRef.h                        |  14 ++
 c10/util/safe_numerics.h                      |   2 +-
 caffe2/CMakeLists.txt                         |  11 +-
 caffe2/serialize/inline_container_test.cc     |   9 +-
 migration_note.md                             |  24 +-
 test/cpp/jit/test_flatbuffer.cpp              |   6 +-
 .../open_registration_extension.cpp           |   4 +-
 third_party/cutlass                           |   2 +-
 third_party/pocketfft                         |   2 +-
 torch/csrc/Exceptions.cpp                     |   4 +
 torch/csrc/Generator.cpp                      |  20 ++
 torch/csrc/PyInterpreter.cpp                  |   2 +-
 torch/csrc/api/include/torch/all.h            |   5 +-
 torch/csrc/autograd/profiler_python.cpp       |   4 +
 torch/csrc/dynamo/guards.cpp                  |  38 +--
 torch/csrc/jit/runtime/static/ops.cpp         |   4 +-
 torch/csrc/jit/runtime/static/ops.h           |   4 +-
 torch/csrc/monitor/python_init.cpp            |  20 +-
 torch/csrc/profiler/collection.h              |   2 +-
 torch/csrc/profiler/containers.h              |   6 +-
 torch/csrc/profiler/python/init.cpp           |  15 ++
 torch/csrc/utils/python_raii.h                |   7 +-
 527 files changed, 1809 insertions(+), 1228 deletions(-)

diff --git a/BUILD.bazel b/BUILD.bazel
index eaab9fcafb..805d407417 100644
--- a/BUILD.bazel
+++ b/BUILD.bazel
@@ -1570,7 +1570,10 @@ cc_library(
         ] + torch_cuda_headers,
     ) + GENERATED_AUTOGRAD_CPP + [":version_h"],
     includes = [
+        # kineto
         "third_party/kineto/libkineto/include",
+        # cutlass
+        # "third_party/cutlass/include",
         "torch/csrc",
         "torch/csrc/api/include",
         "torch/csrc/distributed",
diff --git a/aten/src/ATen/CMakeLists.txt b/aten/src/ATen/CMakeLists.txt
index ebbb0e4f95..4f38c504f6 100644
--- a/aten/src/ATen/CMakeLists.txt
+++ b/aten/src/ATen/CMakeLists.txt
@@ -454,7 +454,7 @@ endif()
 
 if(USE_CUDA AND NOT USE_ROCM)
   list(APPEND ATen_CUDA_INCLUDE ${CMAKE_CURRENT_SOURCE_DIR}/../../../third_party/cutlass/include)
-  list(APPEND ATen_CUDA_INCLUDE /usr/local/cuda/include)
+  # list(APPEND ATen_CUDA_INCLUDE /usr/local/cuda/include)
   if($ENV{ATEN_STATIC_CUDA})
     list(APPEND ATen_CUDA_DEPENDENCY_LIBS
       ${CUDA_LIBRARIES}
diff --git a/aten/src/ATen/ConjugateFallback.cpp b/aten/src/ATen/ConjugateFallback.cpp
index ff24c1aad7..a874c582b2 100644
--- a/aten/src/ATen/ConjugateFallback.cpp
+++ b/aten/src/ATen/ConjugateFallback.cpp
@@ -1,7 +1,7 @@
 #include <ATen/native/MathBitsFallback.h>
 #include <ATen/native/MathBitFallThroughLists.h>
 
-namespace at::native {
+namespace at{ namespace native {
 struct ConjFallback : MathOpFallback {
   ConjFallback() : MathOpFallback(DispatchKey::Conjugate, "conjugate") {}
   bool is_bit_set(const Tensor& tensor) override {
@@ -62,4 +62,4 @@ TORCH_LIBRARY_IMPL(aten, Conjugate, m) {
   TORCH_VIEW_FNS_NATIVE_FN_REGISTRATION(m)
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/NestedTensorImpl.h b/aten/src/ATen/NestedTensorImpl.h
index 11d7e2f165..70bf87c44e 100644
--- a/aten/src/ATen/NestedTensorImpl.h
+++ b/aten/src/ATen/NestedTensorImpl.h
@@ -10,7 +10,7 @@
 #include <c10/util/Metaprogramming.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 struct NestedTensorImpl;
 inline bool nested_tensor_impl_is_contiguous(const NestedTensorImpl* nt);
 int64_t get_numel_from_nested_size_tensor(const at::Tensor& tensor);
@@ -278,4 +278,4 @@ inline const at::Tensor& get_nested_sizes(const at::Tensor& tensor) {
   return get_nested_tensor_impl(tensor)->get_nested_sizes();
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/ParallelNative.h b/aten/src/ATen/ParallelNative.h
index 8df093a990..654327f4e7 100644
--- a/aten/src/ATen/ParallelNative.h
+++ b/aten/src/ATen/ParallelNative.h
@@ -8,7 +8,7 @@
 
 #define INTRA_OP_PARALLEL
 
-namespace at::internal {
+namespace at{ namespace internal {
 
 TORCH_API void invoke_parallel(
     const int64_t begin,
@@ -16,4 +16,4 @@ TORCH_API void invoke_parallel(
     const int64_t grain_size,
     const std::function<void(int64_t, int64_t)>& f);
 
-} // namespace at::internal
+}} // namespace at::internal
diff --git a/aten/src/ATen/ScalarOps.h b/aten/src/ATen/ScalarOps.h
index 9b0c2d1247..f7d28305da 100644
--- a/aten/src/ATen/ScalarOps.h
+++ b/aten/src/ATen/ScalarOps.h
@@ -9,7 +9,7 @@
 #include <ATen/ops/scalar_tensor.h>
 #endif
 
-namespace at::detail {
+namespace at{ namespace detail {
 // When filling a number to 1-element CPU tensor, we want to skip
 // everything but manipulate data ptr directly.
 // Ideally this fast pass should be implemented in TensorIterator,
@@ -20,7 +20,7 @@ TORCH_API Tensor scalar_tensor_static(
     const Scalar& s,
     c10::optional<ScalarType> dtype_opt,
     c10::optional<Device> device_opt);
-} // namespace at::detail
+}} // namespace at::detail
 
 // This is in the c10 namespace because we use ADL to find the functions in it.
 namespace c10 {
@@ -58,7 +58,7 @@ inline at::Tensor scalar_to_tensor(
 
 } // namespace c10
 
-namespace at::native {
+namespace at{ namespace native {
 
 inline Tensor wrapped_scalar_tensor(
     const Scalar& scalar,
@@ -68,4 +68,4 @@ inline Tensor wrapped_scalar_tensor(
   return tensor;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/SequenceNumber.cpp b/aten/src/ATen/SequenceNumber.cpp
index 26423f393a..0b7a1827e1 100644
--- a/aten/src/ATen/SequenceNumber.cpp
+++ b/aten/src/ATen/SequenceNumber.cpp
@@ -1,6 +1,6 @@
 #include <ATen/SequenceNumber.h>
 
-namespace at::sequence_number {
+namespace at{ namespace sequence_number {
 
 namespace {
 thread_local uint64_t sequence_nr_ = 0;
@@ -14,4 +14,4 @@ uint64_t get_and_increment() {
   return sequence_nr_++;
 }
 
-} // namespace at::sequence_number
+}} // namespace at::sequence_number
diff --git a/aten/src/ATen/SequenceNumber.h b/aten/src/ATen/SequenceNumber.h
index 41b7b97cf6..0a65a73f0d 100644
--- a/aten/src/ATen/SequenceNumber.h
+++ b/aten/src/ATen/SequenceNumber.h
@@ -5,9 +5,9 @@
 
 // A simple thread local enumeration, used to link forward and backward pass
 // ops and is used by autograd and observers framework
-namespace at::sequence_number {
+namespace at{ namespace sequence_number {
 
 TORCH_API uint64_t peek();
 TORCH_API uint64_t get_and_increment();
 
-} // namespace at::sequence_number
+}} // namespace at::sequence_number
diff --git a/aten/src/ATen/TensorIndexing.h b/aten/src/ATen/TensorIndexing.h
index 6f5fd03a95..3e21870b3a 100644
--- a/aten/src/ATen/TensorIndexing.h
+++ b/aten/src/ATen/TensorIndexing.h
@@ -22,7 +22,7 @@
 
 #include <utility>
 
-namespace at::indexing {
+namespace at{ namespace indexing {
 
 const int64_t INDEX_MIN = c10::SymInt::min_representable_int();
 const int64_t INDEX_MAX = -(INDEX_MIN + 1);
@@ -728,4 +728,4 @@ static inline void set_item(
   return;
 }
 
-} // namespace at::indexing
+}} // namespace at::indexing
diff --git a/aten/src/ATen/TensorNames.h b/aten/src/ATen/TensorNames.h
index 4ec3d06486..c337991396 100644
--- a/aten/src/ATen/TensorNames.h
+++ b/aten/src/ATen/TensorNames.h
@@ -2,7 +2,7 @@
 
 #include <ATen/WrapDimUtils.h>
 
-namespace at::namedinference {
+namespace at{ namespace namedinference {
 
 // TensorName and TensorNames are wrappers around Dimname and DimnameList
 // that contain helper functions to make writing name inference rules easier.
@@ -72,4 +72,4 @@ struct TORCH_API TensorNames {
   TensorNameVec names_;
 };
 
-} // namespace at::namedinference
+}} // namespace at::namedinference
diff --git a/aten/src/ATen/TracerMode.h b/aten/src/ATen/TracerMode.h
index 59bf0bdd2b..9ff7f2362e 100644
--- a/aten/src/ATen/TracerMode.h
+++ b/aten/src/ATen/TracerMode.h
@@ -111,7 +111,7 @@
 // TODO: move this from `at::` to `jit::torch::` after
 // `aten/src/ATen/cpp_custom_type_hack.h` is removed.
 
-namespace at::tracer::impl {
+namespace at{ namespace tracer{ namespace impl {
 
 static inline bool is_dispatch_enabled() {
   return c10::impl::tls_is_dispatch_key_included(at::DispatchKey::Tracer) &&
@@ -129,4 +129,4 @@ struct NoTracerDispatchMode {
   c10::impl::ExcludeDispatchKeyGuard guard_{at::DispatchKey::Tracer};
 };
 
-} // namespace at::tracer::impl
+}}} // namespace at::tracer::impl
diff --git a/aten/src/ATen/core/DistributionsHelper.h b/aten/src/ATen/core/DistributionsHelper.h
index 8b399510e9..3b43aca0d7 100644
--- a/aten/src/ATen/core/DistributionsHelper.h
+++ b/aten/src/ATen/core/DistributionsHelper.h
@@ -78,6 +78,16 @@ struct uniform_int_full_range_distribution {
 template <typename T>
 struct uniform_int_distribution {
 
+#if defined(__APPLE__) && defined(__MACH__)
+  template <typename RNG>
+  C10_HOST_DEVICE inline T operator()(RNG generator) {
+    if constexpr (std::is_same<T, double>::value || std::is_same<T, int64_t>::value) {
+      return transformation::uniform_int<T>(generator->random64());
+    } else {
+      return transformation::uniform_int<T>(generator->random());
+    }
+  }
+#else
   template <typename RNG>
   C10_HOST_DEVICE inline T operator()(RNG generator) {
     if constexpr (std::is_same_v<T, double> || std::is_same_v<T, int64_t>) {
@@ -86,6 +96,7 @@ struct uniform_int_distribution {
       return transformation::uniform_int<T>(generator->random());
     }
   }
+#endif
 
 };
 
@@ -104,7 +115,11 @@ struct uniform_real_distribution {
 
   template <typename RNG>
   C10_HOST_DEVICE inline dist_acctype<T> operator()(RNG generator){
+#if defined(__APPLE__) && defined(__MACH__)
+    if constexpr (std::is_same<T, double>::value) {
+#else
     if constexpr (std::is_same_v<T, double>) {
+#endif
       return transformation::uniform_real<T>(generator->random64(), from_, to_);
     } else {
       return transformation::uniform_real<T>(generator->random(), from_, to_);
@@ -196,7 +211,11 @@ struct normal_distribution {
   C10_HOST_DEVICE inline dist_acctype<T> operator()(RNG generator){
     dist_acctype<T> ret;
     // return cached values if available
+#if defined(__APPLE__) && defined(__MACH__)
+    if constexpr (std::is_same<T, double>::value) {
+#else
     if constexpr (std::is_same_v<T, double>) {
+#endif
       if (maybe_get_next_double_normal_sample(generator, &ret)) {
         return transformation::normal(ret, mean, stdv);
       }
@@ -211,7 +230,11 @@ struct normal_distribution {
     const dist_acctype<T> u2 = uniform(generator);
     const dist_acctype<T> r = ::sqrt(static_cast<T>(-2.0) * ::log1p(-u2));
     const dist_acctype<T> theta = static_cast<T>(2.0) * c10::pi<T> * u1;
+#if defined(__APPLE__) && defined(__MACH__)
+    if constexpr (std::is_same<T, double>::value) {
+#else
     if constexpr (std::is_same_v<T, double>) {
+#endif
       maybe_set_next_double_normal_sample(generator, r * ::sin(theta));
     } else {
       maybe_set_next_float_normal_sample(generator, r * ::sin(theta));
diff --git a/aten/src/ATen/core/TransformationHelper.h b/aten/src/ATen/core/TransformationHelper.h
index 1061a732dd..72673053ca 100644
--- a/aten/src/ATen/core/TransformationHelper.h
+++ b/aten/src/ATen/core/TransformationHelper.h
@@ -53,6 +53,23 @@ C10_HOST_DEVICE inline T uniform_int_full_range(V val) {
  * In order to prevent compiler warnings reported in GitHub issue 46391, T can't be float or double
  * in this overloaded version
  */
+#if defined(__APPLE__) && defined(__MACH__)
+template <typename T, typename V>
+C10_HOST_DEVICE inline typename std::enable_if<!(std::is_floating_point<T>::value), T>::type uniform_int(V val) {
+  if constexpr (std::is_same<T, bool>::value) {
+    return static_cast<bool>(val & 1);
+  } else if constexpr (std::is_same<T, int64_t>::value) {
+    return static_cast<T>(val % (static_cast<uint64_t>(std::numeric_limits<T>::max()) + 1));
+  } else if constexpr (std::is_same<T, at::Half>::value || std::is_same<T, at::BFloat16>::value) {
+    return static_cast<T>(val % static_cast<uint64_t>((1ULL << std::numeric_limits<T>::digits) + 1));
+  } else if constexpr (std::is_integral<T>::value) {
+    return static_cast<T>(val % (static_cast<uint64_t>(std::numeric_limits<T>::max()) + 1));
+  } else {
+    assert(false);
+    return 0;
+  }
+}
+#else
 template <typename T, typename V>
 C10_HOST_DEVICE inline typename std::enable_if<!(std::is_floating_point<T>::value), T>::type uniform_int(V val) {
   if constexpr (std::is_same_v<T, bool>) {
@@ -68,6 +85,7 @@ C10_HOST_DEVICE inline typename std::enable_if<!(std::is_floating_point<T>::valu
     return 0;
   }
 }
+#endif
 
 /**
  * An overloaded transformation function for `torch.Tensor.random_()`, when used without specifying `from` and `to`,
diff --git a/aten/src/ATen/core/boxing/impl/boxing.h b/aten/src/ATen/core/boxing/impl/boxing.h
index efc6857092..e06e1adf89 100644
--- a/aten/src/ATen/core/boxing/impl/boxing.h
+++ b/aten/src/ATen/core/boxing/impl/boxing.h
@@ -226,7 +226,7 @@ struct BoxedKernelWrapper<
     torch::jit::Stack stack = boxArgs<Args...>(std::forward<Args>(args)...);
     boxed_kernel_func.callBoxed(opHandle, dispatchKeySet, &stack);
 
-    if constexpr (!std::is_same_v<void, Result>) {
+    if constexpr (!std::is_same<void, Result>::value) {
         // op has pushed one or more values onto the stack.
         return PopResult<Result>::call(stack);
     } else {
diff --git a/aten/src/ATen/core/ivalue.h b/aten/src/ATen/core/ivalue.h
index 57812446d0..2cae1ba243 100644
--- a/aten/src/ATen/core/ivalue.h
+++ b/aten/src/ATen/core/ivalue.h
@@ -505,6 +505,16 @@ struct TORCH_API IValue final {
   // Tuple
   IValue(c10::intrusive_ptr<ivalue::Tuple> v);
 
+#if defined(__APPLE__) && defined(__MACH__)
+  template <
+      typename... Args,
+      std::enable_if_t<
+          !guts::disjunction<
+              std::is_lvalue_reference<Args>...,
+              guts::negation<std::is_constructible<IValue, Args>>...>::value,
+          std::nullptr_t> = nullptr>
+  IValue(const std::tuple<Args...>& t);
+#else
   template <
       typename... Args,
       std::enable_if_t<
@@ -513,6 +523,21 @@ struct TORCH_API IValue final {
               std::negation<std::is_constructible<IValue, Args>>...>::value,
           std::nullptr_t> = nullptr>
   IValue(const std::tuple<Args...>& t);
+#endif
+
+#if defined(__APPLE__) && defined(__MACH__)
+  template <
+      typename... Args,
+      std::enable_if_t<
+          !guts::disjunction<
+              std::is_lvalue_reference<Args>...,
+              guts::negation<std::is_constructible<IValue, Args>>...>::value,
+          std::nullptr_t> = nullptr>
+  IValue(std::tuple<Args...>&& t);
+  bool isTuple() const {
+    return Tag::Tuple == tag;
+  }
+#else
   template <
       typename... Args,
       std::enable_if_t<
@@ -524,6 +549,8 @@ struct TORCH_API IValue final {
   bool isTuple() const {
     return Tag::Tuple == tag;
   }
+#endif
+
   c10::intrusive_ptr<ivalue::Tuple> toTuple() &&;
   c10::intrusive_ptr<ivalue::Tuple> toTuple() const&;
   C10_NODISCARD ivalue::Tuple& toTupleRef() const;
diff --git a/aten/src/ATen/core/ivalue_inl.h b/aten/src/ATen/core/ivalue_inl.h
index d59d33219d..f801a27829 100644
--- a/aten/src/ATen/core/ivalue_inl.h
+++ b/aten/src/ATen/core/ivalue_inl.h
@@ -1066,10 +1066,31 @@ struct C10_EXPORT ivalue::Future final : c10::intrusive_ptr_target {
         "std::tuple<IValue, std::vector<Storage>>(Future&)");
 #endif
     auto childFut = createInstance(::std::move(type));
+#if defined(__APPLE__) && defined(__MACH__)
     addCallback([childFut,
                  cb = std::move(callback)](Future& parentFut) mutable {
       try {
-        if constexpr (::std::is_convertible_v<typename c10::invoke_result_t<T &&, Future&>, IValueWithStorages>) {
+        c10::guts::if_constexpr<std::is_convertible<
+            typename c10::invoke_result_t<T &&, Future&>,
+            IValueWithStorages>::value>(
+            [&](auto identity) {
+              IValue value;
+              std::vector<WeakStorage> storages;
+              std::tie(value, storages) = identity(cb)(parentFut);
+              childFut->markCompleted(std::move(value), std::move(storages));
+            },
+            [&](auto identity) {
+              childFut->markCompleted(identity(cb)(parentFut));
+            });
+      } catch (std::exception&) {
+        childFut->setError(std::current_exception());
+      }
+    });
+#else
+    addCallback([childFut,
+                 cb = std::move(callback)](Future& parentFut) mutable {
+      try {
+        if constexpr (::std::is_convertible<typename c10::invoke_result_t<T &&, Future&>, IValueWithStorages>::value) {
           auto [ivalue, storages] = cb(parentFut);
           childFut->markCompleted(::std::move(ivalue), ::std::move(storages));
         } else {
@@ -1079,6 +1100,7 @@ struct C10_EXPORT ivalue::Future final : c10::intrusive_ptr_target {
         childFut->setError(std::current_exception());
       }
     });
+#endif
     return childFut;
   }
 
@@ -1932,6 +1954,21 @@ Tuple generic_to_tuple_impl(
 }
 } // namespace detail
 
+#if defined(__APPLE__) && defined(__MACH__)
+template <
+    typename... Args,
+    typename Indices = std::make_index_sequence<sizeof...(Args)>,
+    std::enable_if_t<
+        !guts::disjunction<
+            std::is_lvalue_reference<Args>...,
+            guts::negation<std::is_constructible<IValue, Args>>...>::value,
+        std::nullptr_t> = nullptr>
+std::tuple<Args...> generic_to(const IValue& ivalue, _fake_type<std::tuple<Args...>>) {
+  const auto& vals = ivalue.toTupleRef().elements();
+  TORCH_CHECK(vals.size() == sizeof...(Args));
+  return detail::generic_to_tuple_impl<std::tuple<Args...>>(vals, Indices{});
+}
+#else
 template <
     typename... Args,
     typename Indices = std::make_index_sequence<sizeof...(Args)>,
@@ -1945,6 +1982,7 @@ std::tuple<Args...> generic_to(const IValue& ivalue, _fake_type<std::tuple<Args.
   TORCH_CHECK(vals.size() == sizeof...(Args));
   return detail::generic_to_tuple_impl<std::tuple<Args...>>(vals, Indices{});
 }
+#endif
 
 template <typename T>
 inline T IValue::to() && {
@@ -2113,6 +2151,19 @@ inline IValue::IValue(c10::intrusive_ptr<ivalue::Tuple> v)
     : tag(Tag::Tuple) {
   payload.u.as_intrusive_ptr = null_to_undefined_tensor(v.release());
 }
+
+#if defined(__APPLE__) && defined(__MACH__)
+template <
+    typename... Args,
+    std::enable_if_t<
+        !guts::disjunction<
+            std::is_lvalue_reference<Args>...,
+            guts::negation<std::is_constructible<IValue, Args>>...>::value,
+        std::nullptr_t>>
+inline IValue::IValue(const std::tuple<Args...>& t)
+    : IValue(c10::guts::apply(c10::ivalue::Tuple::create<const Args&...>, t)) {
+}
+#else
 template <
     typename... Args,
     std::enable_if_t<
@@ -2123,7 +2174,20 @@ template <
 inline IValue::IValue(const std::tuple<Args...>& t)
     : IValue(c10::guts::apply(c10::ivalue::Tuple::create<const Args&...>, t)) {
 }
+#endif
 
+#if defined(__APPLE__) && defined(__MACH__)
+template <
+    typename... Args,
+    std::enable_if_t<
+        !guts::disjunction<
+            std::is_lvalue_reference<Args>...,
+            guts::negation<std::is_constructible<IValue, Args>>...>::value,
+        std::nullptr_t>>
+inline IValue::IValue(std::tuple<Args...>&& t)
+    : IValue(c10::guts::apply(c10::ivalue::Tuple::create<Args&&...>, std::move(t))) {
+}
+#else
 template <
     typename... Args,
     std::enable_if_t<
@@ -2134,6 +2198,7 @@ template <
 inline IValue::IValue(std::tuple<Args...>&& t)
     : IValue(c10::guts::apply(c10::ivalue::Tuple::create<Args&&...>, std::move(t))) {
 }
+#endif
 
 inline IValue::IValue(c10::intrusive_ptr<ivalue::ConstantString> v)
     : tag(Tag::String) {
diff --git a/aten/src/ATen/cpu/vec/vec256/vec256_int.h b/aten/src/ATen/cpu/vec/vec256/vec256_int.h
index b45da34456..e73cf91ef2 100644
--- a/aten/src/ATen/cpu/vec/vec256/vec256_int.h
+++ b/aten/src/ATen/cpu/vec/vec256/vec256_int.h
@@ -8,14 +8,6 @@
 #include <c10/macros/Macros.h>
 #include <c10/util/irange.h>
 
-#if defined(__APPLE__) and defined(__MACH__)
-#include <type_traits>
-// namespace std{
-//   template <class T, class U>
-//   inline constexpr bool is_same_v = is_same<T, U>::value;
-// }
-#endif
-
 namespace at::vec {
 inline namespace CPU_CAPABILITY {
 
@@ -1419,7 +1411,7 @@ Vectorized<T> inline shift_256_8(const Vectorized<T>& a, const Vectorized<T>& b)
   if (left_shift)
     c0 = _mm256_sllv_epi32(a0, b0);
   else
-    if constexpr (std::is_same_v<T, int8_t>)
+    if constexpr (std::is_same<T, int8_t>::value)
       c0 = _mm256_srav_epi32(a0, b0);
     else
       c0 = _mm256_srlv_epi32(a0, b0);
@@ -1433,7 +1425,7 @@ Vectorized<T> inline shift_256_8(const Vectorized<T>& a, const Vectorized<T>& b)
   if (left_shift)
     c1 = _mm256_sllv_epi32(a1, b1);
   else
-    if constexpr (std::is_same_v<T, int8_t>)
+    if constexpr (std::is_same<T, int8_t>::value)
       c1 = _mm256_srav_epi32(a1, b1);
     else
       c1 = _mm256_srlv_epi32(a1, b1);
@@ -1447,7 +1439,7 @@ Vectorized<T> inline shift_256_8(const Vectorized<T>& a, const Vectorized<T>& b)
   if (left_shift)
     c2 = _mm256_sllv_epi32(a2, b2);
   else
-    if constexpr (std::is_same_v<T, int8_t>)
+    if constexpr (std::is_same<T, int8_t>::value)
       c2 = _mm256_srav_epi32(a2, b2);
     else
       c2 = _mm256_srlv_epi32(a2, b2);
@@ -1461,7 +1453,7 @@ Vectorized<T> inline shift_256_8(const Vectorized<T>& a, const Vectorized<T>& b)
   if (left_shift)
     c3 = _mm256_sllv_epi32(a3, b3);
   else
-    if constexpr (std::is_same_v<T, int8_t>)
+    if constexpr (std::is_same<T, int8_t>::value)
       c3 = _mm256_srav_epi32(a3, b3);
     else
       c3 = _mm256_srlv_epi32(a3, b3);
diff --git a/aten/src/ATen/cpu/vec/vec_base.h b/aten/src/ATen/cpu/vec/vec_base.h
index 7a1280f60b..71aba0b561 100644
--- a/aten/src/ATen/cpu/vec/vec_base.h
+++ b/aten/src/ATen/cpu/vec/vec_base.h
@@ -38,12 +38,14 @@
 #include <c10/util/irange.h>
 #include <c10/util/Load.h>
 
-// #if defined(__APPLE__) and defined(__MACH__)
-// namespace std{
-//   template< class T >
-//   inline constexpr bool is_signed_v = is_signed<T>::value;
-// }
-// #endif
+#if defined(__APPLE__) and defined(__MACH__)
+namespace std{
+  // template< class T >
+  // inline constexpr bool is_signed_v = is_signed<T>::value;
+  // template <class T, class U>
+  // inline constexpr bool is_same_v = is_same<T, U>::value;
+}
+#endif
 
 // These macros helped us unify vec_base.h
 #ifdef CPU_CAPABILITY_AVX512
@@ -846,7 +848,7 @@ template <class T> Vectorized<T> inline operator<<(const Vectorized<T> &a, const
 
 template <class T> Vectorized<T> inline operator>>(const Vectorized<T> &a, const Vectorized<T> &b) {
   // right shift value to retain sign bit for signed and no bits for unsigned
-  constexpr T max_shift = sizeof(T) * CHAR_BIT - std::is_signed_v<T>;
+  constexpr T max_shift = sizeof(T) * CHAR_BIT - std::is_signed<T>::value;
   Vectorized<T> c;
   for (int i = 0; i != Vectorized<T>::size(); i++) {
     T shift = b[i];
diff --git a/aten/src/ATen/cuda/AsmUtils.cuh b/aten/src/ATen/cuda/AsmUtils.cuh
index 8bd897e64c..9840c3c084 100644
--- a/aten/src/ATen/cuda/AsmUtils.cuh
+++ b/aten/src/ATen/cuda/AsmUtils.cuh
@@ -3,7 +3,7 @@
 
 // Collection of direct PTX functions
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 template <typename T>
 struct Bitfield {};
@@ -146,4 +146,4 @@ __device__ __forceinline__ unsigned getLaneMaskGe() {
 }
 #endif
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDABlas.cpp b/aten/src/ATen/cuda/CUDABlas.cpp
index 5cabfce927..a161786074 100644
--- a/aten/src/ATen/cuda/CUDABlas.cpp
+++ b/aten/src/ATen/cuda/CUDABlas.cpp
@@ -345,15 +345,23 @@ void bgemm<at::BFloat16>(CUDABLAS_BGEMM_ARGTYPES(at::BFloat16)) {
   const float falpha = alpha;
   const float fbeta = beta;
   _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
-#endif
-
-#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
-  TORCH_CUDABLAS_CHECK(cublasGemmStridedBatchedEx(handle,
-                                  opa, opb, (int)m, (int)n, (int)k,
-                                  (void*)&falpha, a, CUDA_R_16BF, (int)lda, stridea,
-                                  b, CUDA_R_16BF, (int)ldb, strideb,
-                                  (void*)&fbeta, c, CUDA_R_16BF, (int)ldc, stridec,
-                                  (int)num_batches, CUDA_R_32F, CUBLAS_GEMM_DEFAULT_TENSOR_OP));
+#elif !defined(USE_ROCM) && CUDA_VERSION >= 11000
+    TORCH_CUDABLAS_CHECK(cublasGemmStridedBatchedExFix(handle,
+                                    opa, opb, (int)m, (int)n, (int)k,
+                                    (void*)&falpha, a, CUDA_R_16BF, (int)lda, stridea,
+                                    b, CUDA_R_16BF, (int)ldb, strideb,
+                                    (void*)&fbeta, c, CUDA_R_16BF, (int)ldc, stridec,
+                                    (int)num_batches, CUDA_R_32F, CUBLAS_GEMM_DEFAULT_TENSOR_OP));
+#elif defined(ROCM_VERSION) && ROCM_VERSION >= 21000
+    TORCH_CUDABLAS_CHECK(rocblas_gemm_strided_batched_ex(handle, opa, opb, (int)m, (int)n, (int)k,
+                                   (void*)&falpha, a, rocblas_datatype_bf16_r, (int)lda, stridea,
+                                   b, rocblas_datatype_bf16_r, (int)ldb, strideb,
+                                   (void*)&fbeta, c, rocblas_datatype_bf16_r, (int)ldc, stridec,
+                                   c, rocblas_datatype_bf16_r, (int)ldc, stridec,
+                                   (int) num_batches, rocblas_datatype_f32_r, rocblas_gemm_algo_standard,
+                                   0, 0, NULL, NULL));
+#else
+  AT_ERROR("Cublas_bfdot requires CUDA 11.0+");
 #endif
 }
 
@@ -519,46 +527,7 @@ void gemm<at::Half>(CUDABLAS_GEMM_ARGTYPES(at::Half)) {
 #endif
 }
 
-#ifdef USE_ROCM
-template <>
-void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
-  cublasHandle_t handle = at::cuda::getCurrentCUDABlasHandle();
-  cublasOperation_t opa = _cublasOpFromChar(transa);
-  cublasOperation_t opb = _cublasOpFromChar(transb);
-  float falpha = alpha;
-  float fbeta = beta;
-  _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
-  GEMM_CHECK_ARGVALUES(at::BFloat16);
-  TORCH_CUDABLAS_CHECK(rocblas_gemm_ex(
-      handle,
-      opa,
-      opb,
-      m,
-      n,
-      k,
-      &falpha,
-      a,
-      rocblas_datatype_bf16_r,
-      lda,
-      b,
-      rocblas_datatype_bf16_r,
-      ldb,
-      &fbeta,
-      c,
-      rocblas_datatype_bf16_r,
-      ldc,
-      c,
-      rocblas_datatype_bf16_r,
-      ldc,
-      rocblas_datatype_f32_r,
-      rocblas_gemm_algo_standard,
-      0,
-      0));
-}
-#endif
-
-#if !defined(USE_ROCM) 
-// #if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
+#if !defined(USE_ROCM)
 template <>
 void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
   globalContext().alertCuBLASConfigNotDeterministic();
@@ -679,6 +648,8 @@ class CuBlasLtMatmulPreference : public CuBlasLtDescriptor<
 };
 } // namespace
 
+
+#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
 template <typename Dtype>
 void gemm_and_bias(
     bool transpose_mat1,
@@ -881,6 +852,7 @@ template void gemm_and_bias(
     at::BFloat16* result_ptr,
     int64_t result_ld,
     GEMMAndBiasActivationEpilogue activation);
+#endif
 
 void scaled_gemm(
     char transa,
diff --git a/aten/src/ATen/cuda/CUDABlas.h b/aten/src/ATen/cuda/CUDABlas.h
index 52acf9abb0..dad7f0d92b 100644
--- a/aten/src/ATen/cuda/CUDABlas.h
+++ b/aten/src/ATen/cuda/CUDABlas.h
@@ -16,7 +16,7 @@
 #include <ATen/cuda/CUDAContext.h>
 #include <ATen/OpMathType.h>
 
-namespace at::cuda::blas {
+namespace at{ namespace cuda{ namespace blas {
 
 // RAII guard that sets the CuBLAS pointer mode and restores it to
 // its previous value when the guard is destroyed
@@ -331,4 +331,4 @@ TORCH_CUDA_CU_API void gelsBatched<c10::complex<double>>(CUDABLAS_GELS_BATCHED_A
 template<>
 TORCH_CUDA_CU_API void gelsBatched<c10::complex<float>>(CUDABLAS_GELS_BATCHED_ARGTYPES(c10::complex<float>));
 
-} // namespace at::cuda::blas
+}}} // namespace at::cuda::blas
diff --git a/aten/src/ATen/cuda/CUDAContext.cpp b/aten/src/ATen/cuda/CUDAContext.cpp
index 946bbf7749..d1a230d5da 100644
--- a/aten/src/ATen/cuda/CUDAContext.cpp
+++ b/aten/src/ATen/cuda/CUDAContext.cpp
@@ -7,7 +7,7 @@
 #include <deque>
 #include <vector>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 namespace {
 
@@ -66,4 +66,4 @@ Allocator* getCUDADeviceAllocator() {
   return c10::cuda::CUDACachingAllocator::get();
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDADataType.h b/aten/src/ATen/cuda/CUDADataType.h
index a984c06763..c9c9d27d47 100644
--- a/aten/src/ATen/cuda/CUDADataType.h
+++ b/aten/src/ATen/cuda/CUDADataType.h
@@ -5,7 +5,7 @@
 #include <cuda.h>
 #include <library_types.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 template <typename scalar_t>
 cudaDataType getCudaDataType() {
@@ -98,4 +98,4 @@ inline cudaDataType ScalarTypeToCudaDataType(const c10::ScalarType& scalar_type)
   }
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDADevice.h b/aten/src/ATen/cuda/CUDADevice.h
index ba9a5eb849..80a04f171e 100644
--- a/aten/src/ATen/cuda/CUDADevice.h
+++ b/aten/src/ATen/cuda/CUDADevice.h
@@ -5,7 +5,7 @@
 #include <cuda.h>
 #include <cuda_runtime.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 inline Device getDeviceFromPtr(void* ptr) {
   cudaPointerAttributes attr{};
@@ -20,4 +20,4 @@ inline Device getDeviceFromPtr(void* ptr) {
   return {c10::DeviceType::CUDA, static_cast<DeviceIndex>(attr.device)};
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDAEvent.h b/aten/src/ATen/cuda/CUDAEvent.h
index ca68787214..6e13277f09 100644
--- a/aten/src/ATen/cuda/CUDAEvent.h
+++ b/aten/src/ATen/cuda/CUDAEvent.h
@@ -13,7 +13,7 @@
 #include <cstdint>
 #include <utility>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 /*
 * CUDAEvents are movable not copyable wrappers around CUDA's events.
@@ -205,4 +205,4 @@ private:
   }
 };
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDAGeneratorImpl.cpp b/aten/src/ATen/cuda/CUDAGeneratorImpl.cpp
index b8004ec7e7..ce1d29e95d 100644
--- a/aten/src/ATen/cuda/CUDAGeneratorImpl.cpp
+++ b/aten/src/ATen/cuda/CUDAGeneratorImpl.cpp
@@ -7,7 +7,7 @@
 #include <ATen/Utils.h>
 
 namespace at {
-namespace cuda::detail {
+namespace cuda{ namespace detail {
 
 namespace {
 
@@ -75,7 +75,7 @@ Generator createCUDAGenerator(DeviceIndex device_index) {
   return gen;
 }
 
-} // namespace cuda::detail
+}} // namespace cuda::detail
 
 /**
  * Note [Why enforce RNG offset % 4 == 0?]
diff --git a/aten/src/ATen/cuda/CUDAGeneratorImpl.h b/aten/src/ATen/cuda/CUDAGeneratorImpl.h
index 2fe8a6f6c8..3897183a09 100644
--- a/aten/src/ATen/cuda/CUDAGeneratorImpl.h
+++ b/aten/src/ATen/cuda/CUDAGeneratorImpl.h
@@ -128,11 +128,11 @@ private:
   std::atomic_flag no_reset_rnn_state_;
 };
 
-namespace cuda::detail {
+namespace cuda{ namespace detail {
 
 TORCH_CUDA_CPP_API const Generator& getDefaultCUDAGenerator(
     DeviceIndex device_index = -1);
 TORCH_CUDA_CPP_API Generator createCUDAGenerator(DeviceIndex device_index = -1);
 
-} // namespace cuda::detail
+}} // namespace cuda::detail
 } // namespace at
diff --git a/aten/src/ATen/cuda/CUDAGraph.cpp b/aten/src/ATen/cuda/CUDAGraph.cpp
index 3ea84cc2b6..b0d95ffa67 100644
--- a/aten/src/ATen/cuda/CUDAGraph.cpp
+++ b/aten/src/ATen/cuda/CUDAGraph.cpp
@@ -8,7 +8,7 @@
 #include <chrono>
 #include <thread>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 static bool _cuda_graphs_debug = false;
 constexpr int kSynchronizeBusyWaitMillis = 10;
@@ -353,4 +353,4 @@ CUDAGraph::~CUDAGraph() {
   reset();
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDAGraphsUtils.cuh b/aten/src/ATen/cuda/CUDAGraphsUtils.cuh
index f3e27a7b15..e151a9b5ef 100644
--- a/aten/src/ATen/cuda/CUDAGraphsUtils.cuh
+++ b/aten/src/ATen/cuda/CUDAGraphsUtils.cuh
@@ -12,7 +12,7 @@
 // c10/cuda/CUDAGraphsC10Utils.h has utils used by both c10 and aten.
 // This file adds utils used by aten only.
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 using CaptureId_t = c10::cuda::CaptureId_t;
 using CaptureStatus = c10::cuda::CaptureStatus;
@@ -54,4 +54,4 @@ inline void errorIfCapturingCudnnBenchmark(std::string version_specific) {
               "in which case capturing them is generally prohibited.");
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CUDASparseBlas.cpp b/aten/src/ATen/cuda/CUDASparseBlas.cpp
index 302189c5c5..9e279450ed 100644
--- a/aten/src/ATen/cuda/CUDASparseBlas.cpp
+++ b/aten/src/ATen/cuda/CUDASparseBlas.cpp
@@ -4,7 +4,7 @@
 
 #include <ATen/cuda/CUDASparseBlas.h>
 
-namespace at::cuda::sparse {
+namespace at{ namespace cuda{ namespace sparse {
 
 template <>
 void csrgeam2_bufferSizeExt<float>(
@@ -886,4 +886,4 @@ void bsrsm2_solve<c10::complex<double>>(
 
 #endif // AT_USE_HIPSPARSE_TRIANGULAR_SOLVE
 
-} // namespace at::cuda::sparse
+}}} // namespace at::cuda::sparse
diff --git a/aten/src/ATen/cuda/CUDASparseBlas.h b/aten/src/ATen/cuda/CUDASparseBlas.h
index c99d42c9a7..6e8646208e 100644
--- a/aten/src/ATen/cuda/CUDASparseBlas.h
+++ b/aten/src/ATen/cuda/CUDASparseBlas.h
@@ -12,7 +12,7 @@
 #include <ATen/cuda/CUDAContext.h>
 #include <ATen/cuda/CUDASparse.h>
 
-namespace at::cuda::sparse {
+namespace at{ namespace cuda{ namespace sparse {
 
 #define CUSPARSE_CSRGEAM2_BUFFERSIZE_ARGTYPES(scalar_t)             \
   cusparseHandle_t handle, int m, int n, const scalar_t *alpha,     \
@@ -315,4 +315,4 @@ void bsrsm2_solve<c10::complex<double>>(
 
 #endif // AT_USE_HIPSPARSE_TRIANGULAR_SOLVE
 
-} // namespace at::cuda::sparse
+}}} // namespace at::cuda::sparse
diff --git a/aten/src/ATen/cuda/CUDASparseDescriptors.cpp b/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
index 0fde6028bc..7da16511f5 100644
--- a/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
+++ b/aten/src/ATen/cuda/CUDASparseDescriptors.cpp
@@ -5,7 +5,7 @@
 #include <ATen/native/LinearAlgebraUtils.h>
 #include <ATen/native/cuda/MiscUtils.h>
 
-namespace at::cuda::sparse {
+namespace at{ namespace cuda{ namespace sparse {
 
 #if AT_USE_CUSPARSE_GENERIC_API() || AT_USE_HIPSPARSE_GENERIC_API()
 
@@ -206,4 +206,4 @@ CuSparseSpMatCsrDescriptor::CuSparseSpMatCsrDescriptor(const Tensor& input, int6
 
 #endif // AT_USE_CUSPARSE_GENERIC_API() || AT_USE_HIPSPARSE_GENERIC_API()
 
-} // namespace at::cuda::sparse
+}}} // namespace at::cuda::sparse
diff --git a/aten/src/ATen/cuda/CUDASparseDescriptors.h b/aten/src/ATen/cuda/CUDASparseDescriptors.h
index 5e18b34002..a67b3acd62 100644
--- a/aten/src/ATen/cuda/CUDASparseDescriptors.h
+++ b/aten/src/ATen/cuda/CUDASparseDescriptors.h
@@ -10,7 +10,7 @@
 #include <type_traits>
 #endif
 
-namespace at::cuda::sparse {
+namespace at{ namespace cuda{ namespace sparse {
 
 template <typename T, cusparseStatus_t (*destructor)(T*)>
 struct CuSparseDescriptorDeleter {
@@ -264,4 +264,4 @@ class TORCH_CUDA_CPP_API CuSparseSpGEMMDescriptor
 
 #endif // AT_USE_CUSPARSE_GENERIC_API() || AT_USE_HIPSPARSE_GENERIC_API()
 
-} // namespace at::cuda::sparse
+}}} // namespace at::cuda::sparse
diff --git a/aten/src/ATen/cuda/CUDAUtils.h b/aten/src/ATen/cuda/CUDAUtils.h
index d5f65dd6a5..b5b88feb3f 100644
--- a/aten/src/ATen/cuda/CUDAUtils.h
+++ b/aten/src/ATen/cuda/CUDAUtils.h
@@ -2,7 +2,7 @@
 
 #include <ATen/cuda/CUDAContext.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 // Check if every tensor in a list of tensors matches the current
 // device.
@@ -17,4 +17,4 @@ inline bool check_device(ArrayRef<Tensor> ts) {
   return true;
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CachingHostAllocator.h b/aten/src/ATen/cuda/CachingHostAllocator.h
index 65ad7f7d16..a0d7c069b2 100644
--- a/aten/src/ATen/cuda/CachingHostAllocator.h
+++ b/aten/src/ATen/cuda/CachingHostAllocator.h
@@ -3,7 +3,7 @@
 #include <c10/core/Allocator.h>
 #include <c10/cuda/CUDAStream.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 //
 // A caching allocator for CUDA host allocations (pinned memory).
@@ -34,4 +34,4 @@ inline TORCH_CUDA_CPP_API at::DataPtr HostAlloc(size_t size) {
   return getCachingHostAllocator()->allocate(size);
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/CuSparseHandlePool.cpp b/aten/src/ATen/cuda/CuSparseHandlePool.cpp
index 1a57044138..3e1825052d 100644
--- a/aten/src/ATen/cuda/CuSparseHandlePool.cpp
+++ b/aten/src/ATen/cuda/CuSparseHandlePool.cpp
@@ -1,7 +1,7 @@
 #include <ATen/cuda/CUDAContext.h>
 #include <ATen/cuda/detail/DeviceThreadHandles.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 namespace {
 
 void createCusparseHandle(cusparseHandle_t *handle) {
@@ -43,4 +43,4 @@ cusparseHandle_t getCurrentCUDASparseHandle() {
   return handle;
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/EmptyTensor.cpp b/aten/src/ATen/cuda/EmptyTensor.cpp
index a3cd55f4b2..eb927edd74 100644
--- a/aten/src/ATen/cuda/EmptyTensor.cpp
+++ b/aten/src/ATen/cuda/EmptyTensor.cpp
@@ -3,7 +3,7 @@
 #include <ATen/cuda/CUDAContext.h>
 #include <ATen/EmptyTensor.h>
 
-namespace at::detail {
+namespace at{ namespace detail {
 
 TensorBase empty_cuda(
     IntArrayRef size,
@@ -87,4 +87,4 @@ TensorBase empty_strided_cuda(
       options.pinned_memory_opt());
 }
 
-}  // namespace at::detail
+}}  // namespace at::detail
diff --git a/aten/src/ATen/cuda/Exceptions.cpp b/aten/src/ATen/cuda/Exceptions.cpp
index 2836f4ce12..576d31cc43 100644
--- a/aten/src/ATen/cuda/Exceptions.cpp
+++ b/aten/src/ATen/cuda/Exceptions.cpp
@@ -3,7 +3,7 @@
 
 #include <ATen/cuda/Exceptions.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 namespace blas {
 
 C10_EXPORT const char* _cublasGetErrorEnum(cublasStatus_t error) {
@@ -64,4 +64,4 @@ C10_EXPORT const char* cusolverGetErrorMessage(cusolverStatus_t status) {
 } // namespace solver
 #endif
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/PeerToPeerAccess.cpp b/aten/src/ATen/cuda/PeerToPeerAccess.cpp
index 65c9252209..1dafb21191 100644
--- a/aten/src/ATen/cuda/PeerToPeerAccess.cpp
+++ b/aten/src/ATen/cuda/PeerToPeerAccess.cpp
@@ -9,7 +9,7 @@
 
 #include <vector>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 static std::vector<int8_t> p2pAccessEnabled_;
 static int64_t num_devices_ = -1;
@@ -58,4 +58,4 @@ bool get_p2p_access(int dev, int dev_to_access) {
   return cache;
 }
 
-}  // namespace at::cuda::detail
+}}  // namespace at::cuda::detail
diff --git a/aten/src/ATen/cuda/PeerToPeerAccess.h b/aten/src/ATen/cuda/PeerToPeerAccess.h
index 1abf1dcfc1..79a5e319d3 100644
--- a/aten/src/ATen/cuda/PeerToPeerAccess.h
+++ b/aten/src/ATen/cuda/PeerToPeerAccess.h
@@ -1,11 +1,11 @@
 #include <c10/macros/Macros.h>
 #include <cstdint>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 namespace detail {
 void init_p2p_access_cache(int64_t num_devices);
 }
 
 TORCH_CUDA_CPP_API bool get_p2p_access(int source_dev, int dest_dev);
 
-}  // namespace at::cuda
+}}  // namespace at::cuda
diff --git a/aten/src/ATen/cuda/PinnedMemoryAllocator.cpp b/aten/src/ATen/cuda/PinnedMemoryAllocator.cpp
index 973027cd87..b3f6d52907 100644
--- a/aten/src/ATen/cuda/PinnedMemoryAllocator.cpp
+++ b/aten/src/ATen/cuda/PinnedMemoryAllocator.cpp
@@ -6,7 +6,7 @@
 #include <ATen/ATen.h>
 #include <ATen/CPUFunctions.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 bool is_pinned_cuda(const Tensor& self, c10::optional<Device> device) {
   TORCH_INTERNAL_ASSERT_DEBUG_ONLY(!device.has_value() || device->is_cuda());
@@ -29,4 +29,4 @@ Tensor _pin_memory_cuda(const Tensor& self, c10::optional<Device> device) {
 }
 
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/cuda/PinnedMemoryAllocator.h b/aten/src/ATen/cuda/PinnedMemoryAllocator.h
index 854f5d8dd1..05210924ab 100644
--- a/aten/src/ATen/cuda/PinnedMemoryAllocator.h
+++ b/aten/src/ATen/cuda/PinnedMemoryAllocator.h
@@ -3,9 +3,9 @@
 #include <c10/core/Allocator.h>
 #include <ATen/cuda/CachingHostAllocator.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 inline TORCH_CUDA_CPP_API at::Allocator* getPinnedMemoryAllocator() {
   return getCachingHostAllocator();
 }
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/ScanUtils.cuh b/aten/src/ATen/cuda/ScanUtils.cuh
index fd8b9e91d4..6f108beb9f 100644
--- a/aten/src/ATen/cuda/ScanUtils.cuh
+++ b/aten/src/ATen/cuda/ScanUtils.cuh
@@ -7,7 +7,7 @@
 
 // Collection of in-kernel scan / prefix sum utilities
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 // Inclusive prefix sum for binary vars using intra-warp voting +
 // shared memory
@@ -75,4 +75,4 @@ __device__ void exclusiveBinaryPrefixScan(T* smem, bool in, T* out, T* carry, Bi
   }
 }
 
-}  // namespace at::cuda
+}}  // namespace at::cuda
diff --git a/aten/src/ATen/cuda/ThrustAllocator.h b/aten/src/ATen/cuda/ThrustAllocator.h
index 85783c3035..de1d295752 100644
--- a/aten/src/ATen/cuda/ThrustAllocator.h
+++ b/aten/src/ATen/cuda/ThrustAllocator.h
@@ -3,7 +3,7 @@
 #include <cstddef>
 #include <c10/cuda/CUDACachingAllocator.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 /// Allocator for Thrust to re-route its internal device allocations
 /// to the THC allocator
@@ -20,4 +20,4 @@ public:
   }
 };
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/cub-RadixSortKeys.cu b/aten/src/ATen/cuda/cub-RadixSortKeys.cu
index cf88c8aa0c..5171bf98d8 100644
--- a/aten/src/ATen/cuda/cub-RadixSortKeys.cu
+++ b/aten/src/ATen/cuda/cub-RadixSortKeys.cu
@@ -2,7 +2,7 @@
 #include <ATen/cuda/CUDAConfig.h>
 #include <ATen/cuda/cub.cuh>
 
-namespace at::cuda::cub {
+namespace at{ namespace cuda{ namespace cub {
 
 template <typename key_t>
 void radix_sort_keys(
@@ -52,4 +52,4 @@ void radix_sort_keys(
 
 AT_FORALL_SCALAR_TYPES_AND2(Bool, Half, AT_INSTATIATE_CUB_TEMPLATES)
 
-} // namespace at::cuda::cub
+}}} // namespace at::cuda::cub
diff --git a/aten/src/ATen/cuda/detail/CUDAHooks.h b/aten/src/ATen/cuda/detail/CUDAHooks.h
index dddeab1e26..9df496b977 100644
--- a/aten/src/ATen/cuda/detail/CUDAHooks.h
+++ b/aten/src/ATen/cuda/detail/CUDAHooks.h
@@ -8,7 +8,7 @@
 // TODO: No need to have this whole header, we can just put it all in
 // the cpp file
 
-namespace at::cuda::detail {
+namespace at{ namespace cuda{ namespace detail {
 
 // Set the callback to initialize Magma, which is set by
 // torch_cuda_cu. This indirection is required so magma_init is called
@@ -51,4 +51,4 @@ struct CUDAHooks : public at::CUDAHooksInterface {
   void deviceSynchronize(DeviceIndex device_index) const override;
 };
 
-} // at::cuda::detail
+}}} // at::cuda::detail
diff --git a/aten/src/ATen/cuda/detail/DeviceThreadHandles.h b/aten/src/ATen/cuda/detail/DeviceThreadHandles.h
index 1eb0e245ef..efe7652e47 100644
--- a/aten/src/ATen/cuda/detail/DeviceThreadHandles.h
+++ b/aten/src/ATen/cuda/detail/DeviceThreadHandles.h
@@ -23,7 +23,7 @@
 
 #include <c10/util/Exception.h>
 
-namespace at::cuda { namespace {
+namespace at{ namespace cuda { namespace {
 
 template <typename Handle_t, void Create(Handle_t *), void Destroy(Handle_t)>
 struct DeviceThreadHandlePool : public std::enable_shared_from_this<DeviceThreadHandlePool<Handle_t, Create, Destroy>> {
@@ -148,4 +148,4 @@ struct DeviceThreadHandlePool : public std::enable_shared_from_this<DeviceThread
     }
 };
 
-}}  // namespace at::cuda::detail::<anonymous>
+}}}  // namespace at::cuda::detail::<anonymous>
diff --git a/aten/src/ATen/cuda/detail/KernelUtils.h b/aten/src/ATen/cuda/detail/KernelUtils.h
index 61f576368c..91801b61d2 100644
--- a/aten/src/ATen/cuda/detail/KernelUtils.h
+++ b/aten/src/ATen/cuda/detail/KernelUtils.h
@@ -3,7 +3,7 @@
 #include <limits>
 #include <c10/util/Exception.h>
 
-namespace at::cuda::detail {
+namespace at{ namespace cuda{ namespace detail {
 
 // CUDA: grid stride looping
 //
@@ -34,4 +34,4 @@ inline int GET_BLOCKS(const int64_t N, const int64_t max_threads_per_block=CUDA_
   return static_cast<int>(block_num);
 }
 
-}  // namespace at::cuda::detail
+}}}  // namespace at::cuda::detail
diff --git a/aten/src/ATen/cuda/detail/LazyNVRTC.h b/aten/src/ATen/cuda/detail/LazyNVRTC.h
index 95e52c9437..15ec513082 100644
--- a/aten/src/ATen/cuda/detail/LazyNVRTC.h
+++ b/aten/src/ATen/cuda/detail/LazyNVRTC.h
@@ -1,6 +1,6 @@
 #pragma once
 #include <ATen/detail/CUDAHooksInterface.h>
-namespace at::cuda {
+namespace at{ namespace cuda {
 // Forward-declares at::cuda::NVRTC
 struct NVRTC;
 
@@ -8,4 +8,4 @@ namespace detail {
 extern NVRTC lazyNVRTC;
 } // namespace detail
 
-}  // namespace at::cuda
+}}  // namespace at::cuda
diff --git a/aten/src/ATen/cuda/detail/UnpackRaw.cuh b/aten/src/ATen/cuda/detail/UnpackRaw.cuh
index 70cd222a48..accf0b8d86 100644
--- a/aten/src/ATen/cuda/detail/UnpackRaw.cuh
+++ b/aten/src/ATen/cuda/detail/UnpackRaw.cuh
@@ -2,7 +2,7 @@
 // Eager mode clients should not include this file directly, instead,
 // they should #include <ATen/cuda/PhiloxUtils.cuh>, which has a #pragma once.
 
-namespace at::cuda::philox {
+namespace at{ namespace cuda{ namespace philox {
 
 // In-kernel call to retrieve philox seed and offset from a PhiloxCudaState instance whether
 // that instance was created with graph capture underway or not.
@@ -25,4 +25,4 @@ unpack(at::PhiloxCudaState arg) {
   }
 }
 
-} // namespace at::cuda::philox
+}}} // namespace at::cuda::philox
diff --git a/aten/src/ATen/cuda/jiterator.h b/aten/src/ATen/cuda/jiterator.h
index a7a440cd7b..83a4b31b8f 100644
--- a/aten/src/ATen/cuda/jiterator.h
+++ b/aten/src/ATen/cuda/jiterator.h
@@ -10,7 +10,7 @@
 #include <string>
 #include <vector>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 TORCH_CUDA_CPP_API c10::SmallVector<at::Tensor> CompileAndLaunchKernel(
   const std::string& code_string,
@@ -20,11 +20,11 @@ TORCH_CUDA_CPP_API c10::SmallVector<at::Tensor> CompileAndLaunchKernel(
   const c10::SmallVector<at::Scalar>& extra_args,
   bool return_by_ref);
 
-} // namespace at::cuda
+}} // namespace at::cuda
 
 #else
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 TORCH_CUDA_CPP_API c10::SmallVector<at::Tensor> CompileAndLaunchKernel(
   const std::string& code_string,
@@ -35,6 +35,6 @@ TORCH_CUDA_CPP_API c10::SmallVector<at::Tensor> CompileAndLaunchKernel(
   bool return_by_ref) {
     TORCH_CHECK(false, "Jiterator is not supported");
   }
-} // namespace at::cuda
+}} // namespace at::cuda
 
 #endif // AT_USE_JITERATOR()
diff --git a/aten/src/ATen/cuda/jiterator_impl.h b/aten/src/ATen/cuda/jiterator_impl.h
index eef073fbd8..fc717c26b6 100644
--- a/aten/src/ATen/cuda/jiterator_impl.h
+++ b/aten/src/ATen/cuda/jiterator_impl.h
@@ -13,7 +13,7 @@
 #include <variant>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 
 #define AT_FOR_8_CASES(_)  \
@@ -113,7 +113,11 @@ struct OffsetCalculatorVariant {
   }
 
   void* data_ptr() {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#else
     return std::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#endif
   }
 
  private:
@@ -142,15 +146,27 @@ struct ArrayVariant {
         TORCH_CHECK(false, "ArrayVariant is not implemented for ntensors = ", ntensors);
     }
 
+#if defined(__APPLE__) && defined(__MACH__)
+    c10::visit([&](auto& a) {
+      for (auto i = 0; i < ntensors; ++i) {
+        a[i] = (char*)iter.data_ptr(i);
+      }
+    }, array);
+#else
     std::visit([&](auto& a) {
       for (auto i = 0; i < ntensors; ++i) {
         a[i] = (char*)iter.data_ptr(i);
       }
     }, array);
+#endif
   }
 
   void* data_ptr() {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit([](auto & a){ return static_cast<void*>(&a); }, array);
+#else
     return std::visit([](auto & a){ return static_cast<void*>(&a); }, array);
+#endif
   }
 
 private:
@@ -178,7 +194,11 @@ struct TrivialOffsetCalculatorVariant {
   }
 
   void* data_ptr() {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit([](auto & v){ return static_cast<void*>(&v); }, v);
+#else
     return std::visit([](auto & v){ return static_cast<void*>(&v); }, v);
+#endif
   }
 
 private:
@@ -207,7 +227,11 @@ struct LoadWithCastVariant {
   }
 
   void* data_ptr() {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#else
     return std::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#endif
   }
 
 private:
@@ -236,14 +260,18 @@ struct StoreWithCastVariant {
   }
 
   void* data_ptr() {
+#if defined(__APPLE__) && defined(__MACH__)
+    return c10::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#else
     return std::visit([](auto & v){ return static_cast<void*>(v.get()); }, v);
+#endif
   }
 
 private:
   StoreWithCastPtr v;
 };
 
-} // namespace at::native
+}} // namespace at::native
 
 
 #endif // AT_USE_JITERATOR()
diff --git a/aten/src/ATen/cuda/llvm_basic.cpp b/aten/src/ATen/cuda/llvm_basic.cpp
index dcd6678e67..84af5ab96d 100644
--- a/aten/src/ATen/cuda/llvm_basic.cpp
+++ b/aten/src/ATen/cuda/llvm_basic.cpp
@@ -12,7 +12,7 @@
 #include <string>
 #include <ATen/cuda/llvm_jit_strings.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 // copy-pasted from some llvm files:
 // - https://github.com/llvm/llvm-project/blob/main/libcxx/include/type_traits
@@ -320,4 +320,4 @@ const std::string &get_cmath_string() {
     return cmath;
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/llvm_complex.cpp b/aten/src/ATen/cuda/llvm_complex.cpp
index 9caea9d69f..09302538f4 100644
--- a/aten/src/ATen/cuda/llvm_complex.cpp
+++ b/aten/src/ATen/cuda/llvm_complex.cpp
@@ -14,7 +14,7 @@
 #include <ATen/cuda/llvm_jit_strings.h>
 
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 const std::string complex_body = R"ESCAPE(
 
@@ -1176,4 +1176,4 @@ const std::string &get_complex_math_string() {
   return complex_math;
 }
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/cuda/llvm_jit_strings.h b/aten/src/ATen/cuda/llvm_jit_strings.h
index aba40d4f42..d54694721a 100644
--- a/aten/src/ATen/cuda/llvm_jit_strings.h
+++ b/aten/src/ATen/cuda/llvm_jit_strings.h
@@ -3,7 +3,7 @@
 #include <string>
 #include <c10/macros/Export.h>
 
-namespace at::cuda {
+namespace at{ namespace cuda {
 
 TORCH_CUDA_CPP_API const std::string &get_traits_string();
 TORCH_CUDA_CPP_API const std::string &get_cmath_string();
@@ -11,4 +11,4 @@ TORCH_CUDA_CPP_API const std::string &get_complex_body_string();
 TORCH_CUDA_CPP_API const std::string &get_complex_half_body_string();
 TORCH_CUDA_CPP_API const std::string &get_complex_math_string();
 
-} // namespace at::cuda
+}} // namespace at::cuda
diff --git a/aten/src/ATen/metal/Context.cpp b/aten/src/ATen/metal/Context.cpp
index f9b745387d..dd040d3e2c 100644
--- a/aten/src/ATen/metal/Context.cpp
+++ b/aten/src/ATen/metal/Context.cpp
@@ -3,7 +3,7 @@
 #include <ATen/Tensor.h>
 #include <ATen/metal/Context.h>
 
-namespace at::metal {
+namespace at{ namespace metal {
 
 std::atomic<const MetalInterface*> g_metal_impl_registry;
 
@@ -18,12 +18,12 @@ at::Tensor& metal_copy_(at::Tensor& self, const at::Tensor& src) {
   }
   AT_ERROR("Metal backend was not linked to the build");
 }
-} // namespace at::metal
+}} // namespace at::metal
 
-namespace at::native {
+namespace at{ namespace native {
 bool is_metal_available() {
   auto p = at::metal::g_metal_impl_registry.load();
   return p ? p->is_metal_available() : false;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Activation.h b/aten/src/ATen/native/Activation.h
index dca6a39a09..20430b3f7c 100644
--- a/aten/src/ATen/native/Activation.h
+++ b/aten/src/ATen/native/Activation.h
@@ -14,7 +14,7 @@ struct TensorIteratorBase;
 class TensorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 // These constants control the approximation behavior of gelu function.
 enum class GeluType {
@@ -95,4 +95,4 @@ DECLARE_DISPATCH(activation_backward_fn, mish_backward_stub);
 DECLARE_DISPATCH(activation_fn, prelu_stub);
 DECLARE_DISPATCH(activation_backward_fn, prelu_backward_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/AdaptivePooling.h b/aten/src/ATen/native/AdaptivePooling.h
index d342d218e4..0d63919a4c 100644
--- a/aten/src/ATen/native/AdaptivePooling.h
+++ b/aten/src/ATen/native/AdaptivePooling.h
@@ -6,7 +6,7 @@
 #include <c10/util/irange.h>
 #include <cmath>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using adaptive_avg_pooling_fn = void(*)(Tensor& output, const Tensor& input, IntArrayRef output_size);
 using adaptive_avg_pooling_backward_fn = void(*)(Tensor& grad_input, const Tensor& grad_output);
@@ -36,4 +36,4 @@ static inline void adaptive_pool_empty_output_check(const Tensor& gradOutput_, c
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/BatchLinearAlgebra.h b/aten/src/ATen/native/BatchLinearAlgebra.h
index efbe7ce1b9..e12790fe92 100644
--- a/aten/src/ATen/native/BatchLinearAlgebra.h
+++ b/aten/src/ATen/native/BatchLinearAlgebra.h
@@ -16,7 +16,7 @@ enum class TransposeType;
 
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 enum class LapackLstsqDriverType : int64_t { Gels, Gelsd, Gelsy, Gelss};
 
@@ -318,4 +318,4 @@ using ldl_solve_fn = void (*)(
     bool /*upper*/,
     bool /*hermitian*/);
 DECLARE_DISPATCH(ldl_solve_fn, ldl_solve_stub);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/BatchLinearAlgebraKernel.cpp b/aten/src/ATen/native/BatchLinearAlgebraKernel.cpp
index 8a04a66f38..9ed85bffa3 100644
--- a/aten/src/ATen/native/BatchLinearAlgebraKernel.cpp
+++ b/aten/src/ATen/native/BatchLinearAlgebraKernel.cpp
@@ -16,7 +16,7 @@
 #include <ATen/ops/empty.h>
 #include <ATen/ops/empty_strided.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 /*
@@ -1223,4 +1223,4 @@ REGISTER_AVX512_DISPATCH(unpack_pivots_stub, &unpack_pivots_cpu_kernel);
 REGISTER_AVX2_DISPATCH(unpack_pivots_stub, &unpack_pivots_cpu_kernel);
 REGISTER_VSX_DISPATCH(unpack_pivots_stub, &unpack_pivots_cpu_kernel);
 REGISTER_ZVECTOR_DISPATCH(unpack_pivots_stub, &unpack_pivots_cpu_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/BinaryOps.h b/aten/src/ATen/native/BinaryOps.h
index 6781c10015..29abe2b64e 100644
--- a/aten/src/ATen/native/BinaryOps.h
+++ b/aten/src/ATen/native/BinaryOps.h
@@ -21,7 +21,7 @@ struct TensorIterator;
 struct TensorIteratorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 inline void alpha_check(const ScalarType dtype, const Scalar& alpha) {
   TORCH_CHECK(! alpha.isBoolean() || dtype == ScalarType::Bool,
@@ -126,4 +126,4 @@ DECLARE_DISPATCH(structured_binary_fn, shifted_chebyshev_polynomial_u_stub);
 DECLARE_DISPATCH(structured_binary_fn, shifted_chebyshev_polynomial_v_stub);
 DECLARE_DISPATCH(structured_binary_fn, shifted_chebyshev_polynomial_w_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/BucketizationUtils.h b/aten/src/ATen/native/BucketizationUtils.h
index 59d459bd9c..885750e786 100644
--- a/aten/src/ATen/native/BucketizationUtils.h
+++ b/aten/src/ATen/native/BucketizationUtils.h
@@ -10,7 +10,7 @@
 #include <ATen/ops/result_type.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // original values given by raw_*. If an original value is not contiguous, will make a contiguous copy to
 // the corresponding trimmed_* value. Additionally, if the dtypes of the boundary and input tensor do not
@@ -170,4 +170,4 @@ inline void searchsorted_pre_check(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ComplexHelper.h b/aten/src/ATen/native/ComplexHelper.h
index 7e4a1b7508..2afef5df11 100644
--- a/aten/src/ATen/native/ComplexHelper.h
+++ b/aten/src/ATen/native/ComplexHelper.h
@@ -15,7 +15,7 @@
 // WARNING: this header contains non-inline functions and should be only
 // included from ONE cpp file
 
-namespace at::native {
+namespace at{ namespace native {
 
 // View tensor with new dtype, storage offset, sizes and strides
 inline Tensor view_tensor(
@@ -94,4 +94,4 @@ Tensor view_as_complex(const Tensor& self) {
   return view_tensor(self, complex_type, new_storage_offset, new_sizes, new_strides);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/CompositeRandomAccessor.h b/aten/src/ATen/native/CompositeRandomAccessor.h
index 970b7da5cb..1d330f7116 100644
--- a/aten/src/ATen/native/CompositeRandomAccessor.h
+++ b/aten/src/ATen/native/CompositeRandomAccessor.h
@@ -2,7 +2,7 @@
 
 #include <ATen/native/CompositeRandomAccessorCommon.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 struct TupleInfoCPU {
   template <typename ...Types>
@@ -31,4 +31,4 @@ auto get(references_holder<Values, References> rh) -> decltype(std::get<N>(rh.da
   return std::get<N>(rh.data());
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/CompositeRandomAccessorCommon.h b/aten/src/ATen/native/CompositeRandomAccessorCommon.h
index 919647992c..31078ed36e 100644
--- a/aten/src/ATen/native/CompositeRandomAccessorCommon.h
+++ b/aten/src/ATen/native/CompositeRandomAccessorCommon.h
@@ -2,7 +2,7 @@
 
 #pragma once
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -260,4 +260,4 @@ protected:
   ValueAccessor values;
 };
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ConvUtils.h b/aten/src/ATen/native/ConvUtils.h
index 5d2691b976..e9638aac09 100644
--- a/aten/src/ATen/native/ConvUtils.h
+++ b/aten/src/ATen/native/ConvUtils.h
@@ -6,7 +6,7 @@
 #include <c10/util/env.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using conv_depthwise2d_backward_fn = std::tuple<at::Tensor,at::Tensor>(*)(
     const at::Tensor&, const at::Tensor&, const at::Tensor&, at::IntArrayRef, at::IntArrayRef,
@@ -443,4 +443,4 @@ static inline bool xpu_conv_use_channels_last(const at::Tensor& input, const at:
   return can_use_xpu_channels_last_2d || can_use_xpu_channels_last_3d;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ConvolutionMM3d.h b/aten/src/ATen/native/ConvolutionMM3d.h
index 3de6763015..99a59baebe 100644
--- a/aten/src/ATen/native/ConvolutionMM3d.h
+++ b/aten/src/ATen/native/ConvolutionMM3d.h
@@ -1,6 +1,6 @@
 #include <ATen/core/Tensor.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 std::tuple<Tensor, Tensor, Tensor> slow_conv3d_backward_cpu(
     const Tensor& grad_output,
@@ -11,4 +11,4 @@ std::tuple<Tensor, Tensor, Tensor> slow_conv3d_backward_cpu(
     IntArrayRef padding,
     std::array<bool, 3> output_mask);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/DilatedConvolutionUtils.h b/aten/src/ATen/native/DilatedConvolutionUtils.h
index cd58002037..1bcd0de33a 100644
--- a/aten/src/ATen/native/DilatedConvolutionUtils.h
+++ b/aten/src/ATen/native/DilatedConvolutionUtils.h
@@ -19,7 +19,7 @@
       " but got input to be of shape ",              \
       T.sizes())
 
-namespace at::native::internal {
+namespace at{ namespace native { namespace internal {
 namespace {
 inline bool all_positive(IntArrayRef& arr) {
   return std::all_of(
@@ -226,4 +226,4 @@ void slow_conv_dilated_shape_check(
   }
 }
 
-} // namespace at::native::internal
+}}} // namespace at::native::internal
diff --git a/aten/src/ATen/native/DistributionTemplates.h b/aten/src/ATen/native/DistributionTemplates.h
index f6823021d6..3fbcb34ade 100644
--- a/aten/src/ATen/native/DistributionTemplates.h
+++ b/aten/src/ATen/native/DistributionTemplates.h
@@ -22,7 +22,7 @@
 #include <ATen/ops/view_as_real.h>
 #endif
 
-namespace at::native::templates {
+namespace at{ namespace native { namespace templates {
 
 // ==================================================== Random ========================================================
 
@@ -382,4 +382,4 @@ Tensor& bernoulli_out_impl(Tensor& result, const Tensor& self, c10::optional<Gen
 #undef CHECK_OUT_OF_BOUNDS
 #undef WARN_OUT_OF_BOUNDS
 
-} // namespace at::native::templates
+}}} // namespace at::native::templates
diff --git a/aten/src/ATen/native/EmbeddingBag.cpp b/aten/src/ATen/native/EmbeddingBag.cpp
index cceb8baf9b..0e42b4030a 100644
--- a/aten/src/ATen/native/EmbeddingBag.cpp
+++ b/aten/src/ATen/native/EmbeddingBag.cpp
@@ -234,7 +234,7 @@ index_select_add(
       offsets_data = offsets_include_last.data();
     }
 #if defined(USE_FBGEMM)
-    constexpr bool isbf16 = std::is_same_v<data_t, at::Half> ? false : true;
+    constexpr bool isbf16 = std::is_same<data_t, at::Half>::value ? false : true;
     auto kernel_16bit_index_t = fbgemm_kernel_cache
         ? fbgemm_kernel_cache
               ->getCallback</* has_weight */ false, index_t, uint16_t>(ddim)
@@ -608,7 +608,7 @@ index_select_scale_add(
     auto* scale_data_fp32 = scale_fp32.mutable_data_ptr<float>();
 
 #if defined(USE_FBGEMM)
-    constexpr bool isbf16 = std::is_same_v<data_t, at::Half> ? false : true;
+    constexpr bool isbf16 = std::is_same<data_t, at::Half>::value ? false : true;
     if constexpr (isbf16) {
       fbgemm::Bfloat16ToFloat_simd(
           reinterpret_cast<const fbgemm::bfloat16*>(scale_data),
diff --git a/aten/src/ATen/native/EmbeddingBag.h b/aten/src/ATen/native/EmbeddingBag.h
index c2e61f280b..d560f5529a 100644
--- a/aten/src/ATen/native/EmbeddingBag.h
+++ b/aten/src/ATen/native/EmbeddingBag.h
@@ -6,7 +6,7 @@
 #include <fbgemm/FbgemmEmbedding.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 void check_arguments(
     const Tensor& weight,
@@ -136,4 +136,4 @@ void _embedding_bag_cpu_out(
     const c10::optional<int64_t>& padding_idx,
     _EmbeddingBagKernelCache* fbgemm_kernel_cache = nullptr);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ForeachOpsKernels.cpp b/aten/src/ATen/native/ForeachOpsKernels.cpp
index 790c7a5e05..77c1597baa 100644
--- a/aten/src/ATen/native/ForeachOpsKernels.cpp
+++ b/aten/src/ATen/native/ForeachOpsKernels.cpp
@@ -60,7 +60,7 @@
 #include <ATen/ops/pow.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 #define FOREACH_BINARY_OP_TENSOR(OP)                            \
   void foreach_tensor_##OP##_tensor_kernel_slow_(               \
@@ -459,4 +459,4 @@ std::vector<Tensor> foreach_scalar_pow_list_kernel_slow(
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ForeachUtils.h b/aten/src/ATen/native/ForeachUtils.h
index 23c9b77159..9869a0b30d 100644
--- a/aten/src/ATen/native/ForeachUtils.h
+++ b/aten/src/ATen/native/ForeachUtils.h
@@ -17,7 +17,7 @@
 #include <unordered_map>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 // Check if tensor list has either a boolean tensor or a integer tensor
 inline bool has_integral_tensor(TensorList tensors, const bool includeBool) {
@@ -366,4 +366,4 @@ inline FlatMap _group_tensors_by_first_tensors_device_and_dtype(
 }
 
 } // namespace
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/FractionalMaxPooling.h b/aten/src/ATen/native/FractionalMaxPooling.h
index cb5438a03e..2bf1c407c7 100644
--- a/aten/src/ATen/native/FractionalMaxPooling.h
+++ b/aten/src/ATen/native/FractionalMaxPooling.h
@@ -3,7 +3,7 @@
 #include <ATen/TensorUtils.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template<typename scalar_t>
 static inline std::vector<int> generate_intervals(
@@ -77,4 +77,4 @@ static inline void fractional_max_pool_check_shape(
       "Expect _random_samples.size(2) equals to ", ndim, "; got ", D, ".");
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/GridSampler.h b/aten/src/ATen/native/GridSampler.h
index aaeb7331c3..e5a5568e2f 100644
--- a/aten/src/ATen/native/GridSampler.h
+++ b/aten/src/ATen/native/GridSampler.h
@@ -7,7 +7,7 @@
 
 #include <ATen/native/GridSamplerUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using detail::GridSamplerInterpolation;
 using detail::GridSamplerPadding;
@@ -295,4 +295,4 @@ static inline void get_cubic_coefficients_grad(
   coeffs[3] = (3 * A * x - 10 * A) * x + 8 * A;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/GridSamplerUtils.h b/aten/src/ATen/native/GridSamplerUtils.h
index eea21ddf5e..6b4787b1eb 100644
--- a/aten/src/ATen/native/GridSamplerUtils.h
+++ b/aten/src/ATen/native/GridSamplerUtils.h
@@ -6,7 +6,7 @@
 #include <ATen/native/TensorProperties.h>
 #include <ATen/native/CanUse32BitIndexMath.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace detail {
 
@@ -106,4 +106,4 @@ bool cond_cudnn_grid_sampler(
 
 } // anonymous namespace
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Histogram.h b/aten/src/ATen/native/Histogram.h
index cd19fa4691..b1f2752d6e 100644
--- a/aten/src/ATen/native/Histogram.h
+++ b/aten/src/ATen/native/Histogram.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using histogramdd_fn = void(*)(const Tensor&, const c10::optional<Tensor>&, bool, Tensor&, const TensorList&);
 using histogramdd_linear_fn = void(*)(const Tensor&, const c10::optional<Tensor>&, bool, Tensor&, const TensorList&, bool);
@@ -13,4 +13,4 @@ DECLARE_DISPATCH(histogramdd_fn, histogramdd_stub);
 DECLARE_DISPATCH(histogramdd_linear_fn, histogramdd_linear_stub);
 DECLARE_DISPATCH(histogram_select_outer_bin_edges_fn, histogram_select_outer_bin_edges_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/IndexKernel.h b/aten/src/ATen/native/IndexKernel.h
index 8b0a787f0e..449e065b51 100644
--- a/aten/src/ATen/native/IndexKernel.h
+++ b/aten/src/ATen/native/IndexKernel.h
@@ -13,7 +13,7 @@ namespace c10 {
 class Scalar;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using index_fn = void(*)(TensorIteratorBase &, IntArrayRef indexed_sizes, IntArrayRef indexed_strides);
 using index_fill_fn = void(*)(TensorIterator & iter, int64_t dim, int64_t self_dim_size, int64_t self_dim_stride, const Scalar& source);
@@ -38,4 +38,4 @@ DECLARE_DISPATCH(masked_select_fn, masked_select_serial_stub);
 DECLARE_DISPATCH(masked_select_fn, masked_select_stub);
 DECLARE_DISPATCH(masked_scatter_fn, masked_scatter_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/IndexingUtils.h b/aten/src/ATen/native/IndexingUtils.h
index 72b39eb326..cf0d8d4be5 100644
--- a/aten/src/ATen/native/IndexingUtils.h
+++ b/aten/src/ATen/native/IndexingUtils.h
@@ -5,7 +5,7 @@
 #include <ATen/core/IListRef.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 [[noreturn]]
 static void invalid_mask(const Tensor & self, int64_t idx, const Tensor & mask, int64_t maskIdx) {
@@ -157,4 +157,4 @@ struct AdvancedIndex {
 };
 
 
-} //namespace at::native
+}} //namespace at::native
diff --git a/aten/src/ATen/native/Lerp.h b/aten/src/ATen/native/Lerp.h
index 6db4f60b88..9d81581d2c 100644
--- a/aten/src/ATen/native/Lerp.h
+++ b/aten/src/ATen/native/Lerp.h
@@ -5,7 +5,7 @@
 #include <ATen/TensorIterator.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t>
 C10_HOST_DEVICE C10_ALWAYS_INLINE bool is_lerp_weight_small(scalar_t weight) {
@@ -43,4 +43,4 @@ using lerp_fn_tensor = void (*)(
 DECLARE_DISPATCH(lerp_fn_scalar, lerp_kernel_scalar_weight);
 DECLARE_DISPATCH(lerp_fn_tensor, lerp_kernel_tensor_weight);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/LinearAlgebra.h b/aten/src/ATen/native/LinearAlgebra.h
index 54d44b23a0..7a49e963a7 100644
--- a/aten/src/ATen/native/LinearAlgebra.h
+++ b/aten/src/ATen/native/LinearAlgebra.h
@@ -11,8 +11,8 @@ namespace at {
 struct TensorIterator;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using addr_fn = void (*)(TensorIterator &, const Scalar& beta, const Scalar& alpha);
 DECLARE_DISPATCH(addr_fn, addr_stub);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/LinearAlgebraUtils.h b/aten/src/ATen/native/LinearAlgebraUtils.h
index 141caa5236..61e6c8e419 100644
--- a/aten/src/ATen/native/LinearAlgebraUtils.h
+++ b/aten/src/ATen/native/LinearAlgebraUtils.h
@@ -25,7 +25,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static inline c10::MaybeOwned<Tensor> expect_resolved_conj(const Tensor& tensor) {
   if (tensor.is_conj()) {
@@ -621,4 +621,4 @@ static inline bool is_blas_compatible_row_major_order(const Tensor& input) {
       batch_stride_compatible;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/LossMulti.h b/aten/src/ATen/native/LossMulti.h
index f21269620f..62ace6a8c6 100644
--- a/aten/src/ATen/native/LossMulti.h
+++ b/aten/src/ATen/native/LossMulti.h
@@ -4,7 +4,7 @@
 #include <ATen/Dispatch.h>
 #include <ATen/TensorUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
   static C10_UNUSED void multilabel_margin_loss_shape_check(
     int64_t& nframe,
@@ -69,4 +69,4 @@ namespace {
 
 
 }  // anonymous namespace
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/MathBitsFallback.h b/aten/src/ATen/native/MathBitsFallback.h
index 584d07aeca..d6f5d3b014 100644
--- a/aten/src/ATen/native/MathBitsFallback.h
+++ b/aten/src/ATen/native/MathBitsFallback.h
@@ -14,7 +14,7 @@
 #include <utility>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 // This fallback should only be used for operations that are self inverse and have a corresponding tensor
 // bit (internally implemented using DispatchKey) to maintain the state on tensor using tensor bit.
 // Currently there are two tensor bits that trigger this fallback: conjugate bit and negative bit.
@@ -154,4 +154,4 @@ struct MathOpFallback {
   string op_name;
 };
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/MaxPooling.h b/aten/src/ATen/native/MaxPooling.h
index a0dda6dbcf..c611b49db3 100644
--- a/aten/src/ATen/native/MaxPooling.h
+++ b/aten/src/ATen/native/MaxPooling.h
@@ -4,7 +4,7 @@
 #include <ATen/Parallel.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // TODO(Heitor) Template by dimension
 struct PoolingParams1D {
@@ -39,4 +39,4 @@ using pooling_fn = void (*)(Tensor&, const Tensor&, const PoolingParams1D&);
 
 DECLARE_DISPATCH(pooling_fn, max_pool1d_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/NonEmptyUtils.h b/aten/src/ATen/native/NonEmptyUtils.h
index 3d18bc5e15..fd4d899630 100644
--- a/aten/src/ATen/native/NonEmptyUtils.h
+++ b/aten/src/ATen/native/NonEmptyUtils.h
@@ -2,7 +2,7 @@
 #include <algorithm>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 inline int64_t ensure_nonempty_dim(int64_t dim) {
   return std::max<int64_t>(dim, 1);
@@ -24,4 +24,4 @@ inline IdxVec ensure_nonempty_vec(IdxVec vec) {
   return vec;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/NonSymbolicBC.h b/aten/src/ATen/native/NonSymbolicBC.h
index 589822a4ee..04a49eb0df 100644
--- a/aten/src/ATen/native/NonSymbolicBC.h
+++ b/aten/src/ATen/native/NonSymbolicBC.h
@@ -3,7 +3,7 @@
 #include <c10/util/irange.h>
 #include <ATen/core/IListRef.h>
 
-namespace at::native {
+namespace at{ namespace native {
 // This file contains non-symbolic signatures for ops that we have sym-intified the signature of.
 // However, in certain cases (such as static runtime), we call the native versions of the ops directly.
 // In those cases, we will duplicate the signature here with non-symbolic ints, and also duplicate the C++ implementation.
@@ -23,4 +23,4 @@ TORCH_API at::Tensor trace_backward(const at::Tensor & grad, at::IntArrayRef siz
 TORCH_API at::Tensor index_select_backward(const at::Tensor & grad, at::IntArrayRef self_sizes, int64_t dim, const at::Tensor & index);
 TORCH_API at::Tensor select(const at::Tensor& self, int64_t dim, int64_t index);
 TORCH_API std::vector<Tensor> tensor_split(const Tensor& self, IntArrayRef indices, int64_t dim);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Normalization.h b/aten/src/ATen/native/Normalization.h
index 6cd4dcde37..ea1f15113f 100644
--- a/aten/src/ATen/native/Normalization.h
+++ b/aten/src/ATen/native/Normalization.h
@@ -3,9 +3,9 @@
 #include <ATen/TensorIterator.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using renorm_scale_factor_fn = void (*) (TensorIteratorBase& iter, double maxnorm);
 DECLARE_DISPATCH(renorm_scale_factor_fn, renorm_scale_factor_stub);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/Padding.h b/aten/src/ATen/native/Padding.h
index 0834361342..d428589584 100644
--- a/aten/src/ATen/native/Padding.h
+++ b/aten/src/ATen/native/Padding.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using padding_fn = void (*)(const Tensor&, const Tensor&, IntArrayRef);
 
@@ -59,4 +59,4 @@ static inline void check_valid_input(const Tensor& input, IntArrayRef padding) {
 
 } // namespace padding
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/Pool.h b/aten/src/ATen/native/Pool.h
index 33a733273a..6d2cbb48d7 100644
--- a/aten/src/ATen/native/Pool.h
+++ b/aten/src/ATen/native/Pool.h
@@ -8,7 +8,7 @@
 
 #pragma once
 
-namespace at::native {
+namespace at{ namespace native {
 
 using max_pool2d_fn = void(*)(const Tensor& output, const Tensor& indices, const Tensor& input,
     int kW, int kH, int dW, int dH, int padW, int padH, int dilationW, int dilationH);
@@ -337,4 +337,4 @@ avg_pool3d_backward_shape_check(
 
 } // anonymous namespace
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/RNN.h b/aten/src/ATen/native/RNN.h
index f3e54c2a40..ffb0f9d977 100644
--- a/aten/src/ATen/native/RNN.h
+++ b/aten/src/ATen/native/RNN.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using lstm_fn = void(*)(Tensor&, Tensor&, Tensor&, const Tensor&, TensorList, TensorList, bool, int64_t, double, bool, bool, bool);
 using rnn_fn = void(*)(Tensor&, Tensor&, const Tensor&, const Tensor&, TensorList, bool, int64_t, double, bool, bool, bool);
@@ -50,4 +50,4 @@ inline void check_attributes(const Tensor& input, const TensorList& params, cons
   for (const auto& p : params) check_tensors("parameter", p);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ReduceAllOps.h b/aten/src/ATen/native/ReduceAllOps.h
index b3ece0328f..09c68ee9bb 100644
--- a/aten/src/ATen/native/ReduceAllOps.h
+++ b/aten/src/ATen/native/ReduceAllOps.h
@@ -6,11 +6,11 @@ namespace at {
 class Tensor;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using reduce_all_fn = void (*)(Tensor & result, const Tensor & self);
 using reduce_min_max_fn = void (*)(Tensor & max_result, Tensor & min_result, const Tensor & self);
 DECLARE_DISPATCH(reduce_all_fn, min_all_stub);
 DECLARE_DISPATCH(reduce_all_fn, max_all_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ReduceOps.h b/aten/src/ATen/native/ReduceOps.h
index 604d6ae8a7..7a8666209b 100644
--- a/aten/src/ATen/native/ReduceOps.h
+++ b/aten/src/ATen/native/ReduceOps.h
@@ -13,7 +13,7 @@ struct TensorIterator;
 class Tensor;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using reduce_fn = void(*)(TensorIterator &);
 
@@ -53,4 +53,4 @@ TORCH_API std::tuple<Tensor&,Tensor&> var_mean_out(
     Tensor &result1, Tensor &result2, const Tensor &self, IntArrayRef dim,
     int64_t correction, bool keepdim);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ReduceOpsUtils.h b/aten/src/ATen/native/ReduceOpsUtils.h
index fca691c91c..5f67d5c745 100644
--- a/aten/src/ATen/native/ReduceOpsUtils.h
+++ b/aten/src/ATen/native/ReduceOpsUtils.h
@@ -16,7 +16,7 @@
 #include <ATen/ops/scalar_tensor.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Maximum and minimum possible scalar values, including infinities
 template <typename scalar_t>
@@ -344,9 +344,9 @@ inline ScalarType get_dtype_from_result(Tensor& result, c10::optional<ScalarType
 }
 
 
-} // namespace at::native
+}} // namespace at::native
 
-namespace at::meta {
+namespace at{ namespace meta {
 
 static C10_UNUSED DimVector get_reduction_shape(
     const Tensor& self,
@@ -445,4 +445,4 @@ static C10_UNUSED TensorIterator make_reduction_from_out_ty(
   return make_reduction(self, result, opt_dims, keepdim, in_dtype);
 }
 
-} // namespace at::meta
+}} // namespace at::meta
diff --git a/aten/src/ATen/native/ReductionType.h b/aten/src/ATen/native/ReductionType.h
index 2cbee8c622..dbebf91afd 100644
--- a/aten/src/ATen/native/ReductionType.h
+++ b/aten/src/ATen/native/ReductionType.h
@@ -2,7 +2,7 @@
 
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 enum class ReductionType {MAX, MEAN, MIN, SUM, PROD};
 
@@ -37,4 +37,4 @@ static inline ReductionType get_operator_enum(const c10::string_view reduce, boo
   }
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/Repeat.h b/aten/src/ATen/native/Repeat.h
index a90ed815f9..4f087050bb 100644
--- a/aten/src/ATen/native/Repeat.h
+++ b/aten/src/ATen/native/Repeat.h
@@ -10,7 +10,7 @@
 #include <ATen/ops/empty_like.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <
     typename index_t,
@@ -45,4 +45,4 @@ static inline Tensor repeat_interleave_common(
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Resize.h b/aten/src/ATen/native/Resize.h
index b752b91e04..9f281658e9 100644
--- a/aten/src/ATen/native/Resize.h
+++ b/aten/src/ATen/native/Resize.h
@@ -10,7 +10,7 @@
 #include <utility>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 // TODO: make all operations that resize given outputs use this function
 //   for consistency and maintainability.
@@ -169,4 +169,4 @@ inline void setStrided(
   self_->set_sizes_and_strides(size, stride, c10::make_optional(storage_offset));
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ResizeCommon.h b/aten/src/ATen/native/ResizeCommon.h
index 02d1e95c42..bf9dc7ee9b 100644
--- a/aten/src/ATen/native/ResizeCommon.h
+++ b/aten/src/ATen/native/ResizeCommon.h
@@ -11,7 +11,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T>
 inline T storage_size_for(ArrayRef<T> size, ArrayRef<T> stride) {
@@ -72,4 +72,4 @@ inline const Tensor& fill_resize_deterministic_(const Tensor& tensor, int64_t ol
   return tensor;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/ScatterGatherChecks.h b/aten/src/ATen/native/ScatterGatherChecks.h
index 829959c347..8cc6fbf030 100644
--- a/aten/src/ATen/native/ScatterGatherChecks.h
+++ b/aten/src/ATen/native/ScatterGatherChecks.h
@@ -5,7 +5,7 @@
 #include <ATen/native/ReduceOpsUtils.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -125,4 +125,4 @@ static C10_UNUSED void scatter_shape_check(
 
 } // anonymous namespace
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/SobolEngineOpsUtils.h b/aten/src/ATen/native/SobolEngineOpsUtils.h
index 17e42ebe84..2711ee3ba2 100644
--- a/aten/src/ATen/native/SobolEngineOpsUtils.h
+++ b/aten/src/ATen/native/SobolEngineOpsUtils.h
@@ -10,7 +10,7 @@
 #include <ATen/ops/pow.h>
 #endif
 
-namespace at::native::sobol_utils {
+namespace at{ namespace native{ namespace sobol_utils {
 
 /// Function to return the minimum of number of bits to represent the integer `n`
 inline int64_t bit_length(const int64_t n) {
@@ -52,4 +52,4 @@ constexpr float RECIPD = 1.0 / LARGEST_NUMBER;
 extern const int64_t poly[MAXDIM];
 extern const int64_t initsobolstate[MAXDIM][MAXDEG];
 
-} // namespace at::native::sobol_utils
+}}} // namespace at::native::sobol_utils
diff --git a/aten/src/ATen/native/Sorting.h b/aten/src/ATen/native/Sorting.h
index 1ab806645f..e7d56dcc2a 100644
--- a/aten/src/ATen/native/Sorting.h
+++ b/aten/src/ATen/native/Sorting.h
@@ -7,7 +7,7 @@ namespace at {
 class TensorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 enum class QUANTILE_INTERPOLATION_MODE : uint8_t {
   LINEAR,
@@ -25,4 +25,4 @@ DECLARE_DISPATCH(topk_fn, topk_stub);
 
 void _fill_indices(const TensorBase &indices, int64_t dim);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/SortingUtils.h b/aten/src/ATen/native/SortingUtils.h
index a0f9cfa8bf..2cb6d1ca39 100644
--- a/aten/src/ATen/native/SortingUtils.h
+++ b/aten/src/ATen/native/SortingUtils.h
@@ -10,7 +10,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // ensure we get good values and indices for kthvalue, mode
 // this will always be with the reducing dim as 1-d
@@ -85,4 +85,4 @@ inline void _allocate_or_resize_output_with_indices(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/SparseTensorUtils.h b/aten/src/ATen/native/SparseTensorUtils.h
index 35ed5daa38..213b26ad47 100644
--- a/aten/src/ATen/native/SparseTensorUtils.h
+++ b/aten/src/ATen/native/SparseTensorUtils.h
@@ -11,7 +11,7 @@
 #include <ATen/ops/tensor.h>
 #endif
 
-namespace at::sparse {
+namespace at{ namespace sparse {
 
 // Just for documentary purposes
 using SparseTensor = Tensor;
@@ -181,4 +181,4 @@ class TensorGeometryHolder<0> {
   geometry_holder_t t_strides;
 };
 
-} // namespace at::sparse
+}} // namespace at::sparse
diff --git a/aten/src/ATen/native/SpectralOpsUtils.h b/aten/src/ATen/native/SpectralOpsUtils.h
index 7d9852b8e7..ee7376d493 100644
--- a/aten/src/ATen/native/SpectralOpsUtils.h
+++ b/aten/src/ATen/native/SpectralOpsUtils.h
@@ -5,7 +5,7 @@
 #include <sstream>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Normalization types used in _fft_with_size
 enum class fft_norm_mode {
@@ -77,4 +77,4 @@ DECLARE_DISPATCH(fft_fill_with_conjugate_symmetry_fn, fft_fill_with_conjugate_sy
 // See NOTE [ Fourier Transform Conjugate Symmetry ]
 TORCH_API void _fft_fill_with_conjugate_symmetry_(const Tensor& self, IntArrayRef dims);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/StridedRandomAccessor.h b/aten/src/ATen/native/StridedRandomAccessor.h
index ad8f6d7b88..581e296219 100644
--- a/aten/src/ATen/native/StridedRandomAccessor.h
+++ b/aten/src/ATen/native/StridedRandomAccessor.h
@@ -1,6 +1,6 @@
 #pragma once
 
-namespace at::native {
+namespace at{ namespace native {
 
 // (Const)StridedRandomAccessor is a
 // (const) random access iterator defined over
@@ -298,4 +298,4 @@ public:
   // }
 };
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorAdvancedIndexing.h b/aten/src/ATen/native/TensorAdvancedIndexing.h
index c1464092a8..e0739f23e1 100644
--- a/aten/src/ATen/native/TensorAdvancedIndexing.h
+++ b/aten/src/ATen/native/TensorAdvancedIndexing.h
@@ -11,7 +11,7 @@ namespace at {
 struct TensorIterator;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using index_put_with_sort_fn = void(*)(Tensor &, const c10::List<c10::optional<Tensor>> &, const Tensor &, bool accumulate, bool unsafe);
 using index_put_with_sort_quantized_fn = void(*)(Tensor& self, const c10::List<c10::optional<Tensor>>& indices, const Tensor& value, double scale, int zero_point, bool unsafe);
@@ -46,4 +46,4 @@ DECLARE_DISPATCH(scatter_add_expanded_index_fn, scatter_add_expanded_index_stub)
 DECLARE_DISPATCH(scatter_reduce_expanded_index_fn, scatter_reduce_expanded_index_stub);
 DECLARE_DISPATCH(gather_expanded_index_fn, gather_expanded_index_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorAdvancedIndexingUtils.h b/aten/src/ATen/native/TensorAdvancedIndexingUtils.h
index 7b9d1446a0..4e915bb79f 100644
--- a/aten/src/ATen/native/TensorAdvancedIndexingUtils.h
+++ b/aten/src/ATen/native/TensorAdvancedIndexingUtils.h
@@ -3,7 +3,7 @@
 #include <ATen/native/IndexingUtils.h>
 #include <ATen/native/TensorIterator.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 static std::string shapes_as_str(TensorList tensors) {
   std::ostringstream os;
@@ -89,4 +89,4 @@ static AdvancedIndex make_info(Tensor self, IOptTensorListRef orig) {
   return AdvancedIndex(self, indices);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorCompare.h b/aten/src/ATen/native/TensorCompare.h
index b4dfa689b1..7e0884281c 100644
--- a/aten/src/ATen/native/TensorCompare.h
+++ b/aten/src/ATen/native/TensorCompare.h
@@ -12,7 +12,7 @@ struct TensorIterator;
 struct TensorIteratorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using reduce_minmax_fn =
     void (*)(Tensor&, Tensor&, const Tensor&, int64_t, bool);
@@ -46,4 +46,4 @@ DECLARE_DISPATCH(void (*)(TensorIteratorBase &, c10::Scalar), clamp_max_scalar_s
 using isin_default_fn = void (*)(const Tensor&, const Tensor&, bool, const Tensor&);
 DECLARE_DISPATCH(isin_default_fn, isin_default_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorDimApply.h b/aten/src/ATen/native/TensorDimApply.h
index 65d90f6fda..8157a36f2d 100644
--- a/aten/src/ATen/native/TensorDimApply.h
+++ b/aten/src/ATen/native/TensorDimApply.h
@@ -2,7 +2,7 @@
 #include <ATen/core/Tensor.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 //input tensors are non-zero dim and non-empty
 template<typename T1, typename T2, typename Function>
 
@@ -52,4 +52,4 @@ void tensor_dim_apply3(const Tensor& self, Tensor& values, Tensor& indices, int6
     }
   }
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorFactories.h b/aten/src/ATen/native/TensorFactories.h
index fbb3a11eb0..77c4ade3e6 100644
--- a/aten/src/ATen/native/TensorFactories.h
+++ b/aten/src/ATen/native/TensorFactories.h
@@ -12,7 +12,7 @@
 #include <ATen/ops/scalar_tensor.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 // Different combinations of row, col, and offset can lead to two cases:
 //
 // Case 1 - Trapezoid (Triangle as a special case): row + offset <= col
@@ -137,4 +137,4 @@ using binary_fn = void (*)(TensorIterator&);
 DECLARE_DISPATCH(binary_fn, complex_stub);
 DECLARE_DISPATCH(binary_fn, polar_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorIteratorDynamicCasting.h b/aten/src/ATen/native/TensorIteratorDynamicCasting.h
index 5143e84683..c9c818d975 100644
--- a/aten/src/ATen/native/TensorIteratorDynamicCasting.h
+++ b/aten/src/ATen/native/TensorIteratorDynamicCasting.h
@@ -42,7 +42,7 @@ struct needs_dynamic_casting<func_t, 0> {
 
     // we could assert output numbers are correct here, but checks
     // (including arity) are currently pushed outside of this struct.
-    if constexpr (std::is_void_v<cpp_type>) {
+    if constexpr (std::is_void<cpp_type>::value) {
       return false;
     } else {
       return iter.dtype(0) != c10::CppTypeToScalarType<cpp_type>::value;
diff --git a/aten/src/ATen/native/TensorProperties.h b/aten/src/ATen/native/TensorProperties.h
index 87aca85fb3..8c9231be3a 100644
--- a/aten/src/ATen/native/TensorProperties.h
+++ b/aten/src/ATen/native/TensorProperties.h
@@ -5,8 +5,8 @@ namespace at {
 class TensorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 TORCH_API bool cudnn_is_acceptable(const TensorBase& self);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorShape.h b/aten/src/ATen/native/TensorShape.h
index 1c84abb822..77b0b50208 100644
--- a/aten/src/ATen/native/TensorShape.h
+++ b/aten/src/ATen/native/TensorShape.h
@@ -3,7 +3,7 @@
 #include <c10/util/irange.h>
 #include <ATen/core/IListRef.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 TORCH_API at::Tensor clone_preserve_strides(const at::Tensor& self);
 
@@ -55,4 +55,4 @@ inline int64_t get_num_splits(const Tensor& self, int64_t split_size, int64_t di
   return num_splits;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TensorTransformations.h b/aten/src/ATen/native/TensorTransformations.h
index f69c27edb9..458fc940fd 100644
--- a/aten/src/ATen/native/TensorTransformations.h
+++ b/aten/src/ATen/native/TensorTransformations.h
@@ -8,7 +8,7 @@
 
 #include <c10/util/Exception.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static inline Tensor roll_common(const Tensor& self, IntArrayRef shifts, IntArrayRef dims) {
   TORCH_CHECK(!shifts.empty(), "`shifts` required");
@@ -27,4 +27,4 @@ static inline Tensor roll_common(const Tensor& self, IntArrayRef shifts, IntArra
   return at::roll(first_dim_rolled, tail_shifts, tail_dims);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/TopKImpl.h b/aten/src/ATen/native/TopKImpl.h
index a9790e892c..8fc1c0d54a 100644
--- a/aten/src/ATen/native/TopKImpl.h
+++ b/aten/src/ATen/native/TopKImpl.h
@@ -2,7 +2,7 @@
 #include <ATen/core/TensorAccessor.h>
 #include <ATen/NumericUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #ifdef CPU_CAPABILITY
 inline namespace CPU_CAPABILITY {
@@ -95,4 +95,4 @@ void topk_impl_loop(
 }
 
 } // namespace CPU_CAPABILITY
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/TransposeType.h b/aten/src/ATen/native/TransposeType.h
index 603bf6fee6..9ed2e47fd3 100644
--- a/aten/src/ATen/native/TransposeType.h
+++ b/aten/src/ATen/native/TransposeType.h
@@ -1,7 +1,7 @@
 #pragma once
 #include <c10/util/Exception.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Used as an interface between the different BLAS-like libraries
 enum class TransposeType {
@@ -20,4 +20,4 @@ static inline char to_blas(TransposeType trans) {
   TORCH_INTERNAL_ASSERT(false, "Invalid transpose type");
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/TriangularOpsUtils.h b/aten/src/ATen/native/TriangularOpsUtils.h
index cc56fa6457..4b167f19ef 100644
--- a/aten/src/ATen/native/TriangularOpsUtils.h
+++ b/aten/src/ATen/native/TriangularOpsUtils.h
@@ -1,7 +1,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/LinearAlgebraUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 /*
  * Given batches of matrices with arbitrary batch dim,
@@ -54,4 +54,4 @@ static inline std::tuple<bool, Tensor> checkTrilTriuBatchContiguous(const Tensor
   return std::make_tuple(true, tensor);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/TypeProperties.h b/aten/src/ATen/native/TypeProperties.h
index 2d4845c758..b6feb2cf78 100644
--- a/aten/src/ATen/native/TypeProperties.h
+++ b/aten/src/ATen/native/TypeProperties.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/core/IListRef.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 struct ResultTypeState {
   c10::ScalarType dimResult = ScalarType::Undefined;
@@ -17,4 +17,4 @@ TORCH_API ScalarType result_type(const ResultTypeState& state);
 
 TORCH_API ScalarType result_type(ITensorListRef tensors);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/UnaryOps.h b/aten/src/ATen/native/UnaryOps.h
index 91d4d84d46..b00f183f6e 100644
--- a/aten/src/ATen/native/UnaryOps.h
+++ b/aten/src/ATen/native/UnaryOps.h
@@ -11,7 +11,7 @@ class TensorBase;
 struct TensorIteratorBase;
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 using unary_fn = void(*)(TensorIteratorBase&);
 using unary_fn_with_scalar = void(*)(TensorIteratorBase&, const Scalar& a);
@@ -127,4 +127,4 @@ DECLARE_DISPATCH(void (*)(TensorIteratorBase&, int64_t), round_decimals_stub);
 // clone
 // contiguous
 // zero
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Unfold2d.h b/aten/src/ATen/native/Unfold2d.h
index 98d628f7bf..6b09df280c 100644
--- a/aten/src/ATen/native/Unfold2d.h
+++ b/aten/src/ATen/native/Unfold2d.h
@@ -4,7 +4,7 @@
 #include <c10/core/ScalarType.h>
 #include <cstdint>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using unfold2d_fn = void (*)(
     ScalarType dtype,
@@ -27,4 +27,4 @@ using unfold2d_fn = void (*)(
 DECLARE_DISPATCH(unfold2d_fn, unfolded2d_copy_stub);
 DECLARE_DISPATCH(unfold2d_fn, unfolded2d_acc_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/Unfold3d.h b/aten/src/ATen/native/Unfold3d.h
index 90ead9d1f7..3d8ac9a88f 100644
--- a/aten/src/ATen/native/Unfold3d.h
+++ b/aten/src/ATen/native/Unfold3d.h
@@ -2,7 +2,7 @@
 
 #include <c10/core/ScalarType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void Unfold3dCopyCPU(
     ScalarType dtype,
@@ -46,4 +46,4 @@ void Unfold3dAccCPU(
     int64_t pad_w,
     void *dst);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/UnfoldBackward.h b/aten/src/ATen/native/UnfoldBackward.h
index 7ff39f84c6..7808d63ae6 100644
--- a/aten/src/ATen/native/UnfoldBackward.h
+++ b/aten/src/ATen/native/UnfoldBackward.h
@@ -11,7 +11,7 @@
 #include <ATen/ops/arange.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using unfold_backward_fn = void (*)(
   Tensor& grad_in,
@@ -109,4 +109,4 @@ static C10_UNUSED TensorIterator _make_unfold_backward_iter_over_grad_out(
 
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/UpSample.h b/aten/src/ATen/native/UpSample.h
index 95797cb538..0e8e28d4ba 100644
--- a/aten/src/ATen/native/UpSample.h
+++ b/aten/src/ATen/native/UpSample.h
@@ -45,7 +45,7 @@
  *     src_idx + 0.5 = scale * (dst_index + 0.5)
  */
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace upsample {
 
@@ -498,4 +498,4 @@ void inline apply_grad_input(float* buffer_ptr, BFloat16* gin, int64_t size) {
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/batch_norm.h b/aten/src/ATen/native/batch_norm.h
index cbddde86ad..ef4d59f082 100644
--- a/aten/src/ATen/native/batch_norm.h
+++ b/aten/src/ATen/native/batch_norm.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/DispatchStub.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using batch_norm_fn = void (*)(Tensor&, const Tensor&, const Tensor&,
     const Tensor&, const Tensor&, const Tensor&, const Tensor&, const Tensor&, bool, double);
@@ -30,4 +30,4 @@ static scalar_t* conditional_data_ptr(const Tensor& t) {
                      : nullptr;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/Activation.cpp b/aten/src/ATen/native/cpu/Activation.cpp
index 2a213632ca..1fa4b6ba50 100644
--- a/aten/src/ATen/native/cpu/Activation.cpp
+++ b/aten/src/ATen/native/cpu/Activation.cpp
@@ -21,7 +21,7 @@
 
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1461,4 +1461,4 @@ ALSO_REGISTER_AVX512_DISPATCH(silu_backward_stub, &silu_backward_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(mish_stub, &mish_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(mish_backward_stub, &mish_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/AdaptiveAvgPoolKernel.cpp b/aten/src/ATen/native/cpu/AdaptiveAvgPoolKernel.cpp
index b6ba000954..6efe9d41cd 100644
--- a/aten/src/ATen/native/cpu/AdaptiveAvgPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/AdaptiveAvgPoolKernel.cpp
@@ -10,7 +10,7 @@
 #include <c10/util/irange.h>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -68,7 +68,7 @@ void cpu_adaptive_avg_pool(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 cpu_adaptive_avg_pool_channels_last(
     Tensor& output_,
     const Tensor& input_,
@@ -155,7 +155,7 @@ cpu_adaptive_avg_pool_channels_last(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 cpu_adaptive_avg_pool_channels_last(
     Tensor& output_,
     const Tensor& input_,
@@ -414,4 +414,4 @@ void adapative_avg_pool2d_backward_kernel_impl(
 REGISTER_DISPATCH(adaptive_avg_pool2d_kernel, &adaptive_avg_pool2d_kernel_impl);
 REGISTER_DISPATCH(adaptive_avg_pool2d_backward_kernel, &adapative_avg_pool2d_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp b/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
index b83d4fa5f0..09ad778c51 100644
--- a/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/AdaptiveMaxPoolKernel.cpp
@@ -10,7 +10,7 @@
 #include <c10/util/irange.h>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -99,7 +99,7 @@ void cpu_adaptive_max_pool(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 cpu_adaptive_max_pool_channels_last(
     const Tensor& output_,
     const Tensor& indices_,
@@ -216,7 +216,7 @@ cpu_adaptive_max_pool_channels_last(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 cpu_adaptive_max_pool_channels_last(
     const Tensor& output_,
     const Tensor& indices_,
@@ -503,4 +503,4 @@ void adaptive_max_pool2d_backward_kernel_impl(
 REGISTER_DISPATCH(adaptive_max_pool2d_kernel, &adaptive_max_pool2d_kernel_impl);
 REGISTER_DISPATCH(adaptive_max_pool2d_backward_kernel, &adaptive_max_pool2d_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/AvgPoolKernel.cpp b/aten/src/ATen/native/cpu/AvgPoolKernel.cpp
index 704af6bd8c..7824207ab8 100644
--- a/aten/src/ATen/native/cpu/AvgPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/AvgPoolKernel.cpp
@@ -7,7 +7,7 @@
 #include <ATen/native/cpu/utils.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -549,4 +549,4 @@ void avg_pool2d_backward_kernel_impl(
 REGISTER_DISPATCH(avg_pool2d_kernel, &avg_pool2d_kernel_impl);
 REGISTER_DISPATCH(avg_pool2d_backward_kernel, &avg_pool2d_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/BinaryOpsKernel.cpp b/aten/src/ATen/native/cpu/BinaryOpsKernel.cpp
index 83dfbc0e3b..1ace784547 100644
--- a/aten/src/ATen/native/cpu/BinaryOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/BinaryOpsKernel.cpp
@@ -16,7 +16,7 @@
 #include <c10/util/TypeSafeSignMath.h>
 #include <c10/util/generic_math.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1441,4 +1441,4 @@ ALSO_REGISTER_AVX512_DISPATCH(hypot_stub, &hypot_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(igamma_stub, &igamma_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(igammac_stub, &igammac_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/BlasKernel.cpp b/aten/src/ATen/native/cpu/BlasKernel.cpp
index d0761584f0..291346ad6f 100644
--- a/aten/src/ATen/native/cpu/BlasKernel.cpp
+++ b/aten/src/ATen/native/cpu/BlasKernel.cpp
@@ -4,7 +4,7 @@
 #include <c10/util/irange.h>
 #include <c10/util/Unroll.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace cpublas {
 namespace {
 
@@ -335,4 +335,4 @@ REGISTER_DISPATCH(cpublas::gemm_stub, &cpublas::cpublas_gemm_impl);
 REGISTER_DISPATCH(cpublas::axpy_stub, &cpublas::cpublas_axpy_impl);
 REGISTER_DISPATCH(cpublas::copy_stub, &cpublas::cpublas_copy_impl);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/CatKernel.cpp b/aten/src/ATen/native/cpu/CatKernel.cpp
index d3a83b2334..77fcfaa666 100644
--- a/aten/src/ATen/native/cpu/CatKernel.cpp
+++ b/aten/src/ATen/native/cpu/CatKernel.cpp
@@ -7,7 +7,7 @@
 #include <ATen/cpu/vec/vec.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -65,4 +65,4 @@ void cat_serial_kernel(const Tensor& result, const MaterializedITensorListRef& t
 
 REGISTER_DISPATCH(cat_serial_stub, &cat_serial_kernel);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/ChannelShuffleKernel.cpp b/aten/src/ATen/native/cpu/ChannelShuffleKernel.cpp
index d2494970c9..f465864534 100644
--- a/aten/src/ATen/native/cpu/ChannelShuffleKernel.cpp
+++ b/aten/src/ATen/native/cpu/ChannelShuffleKernel.cpp
@@ -8,7 +8,7 @@
 #include <ATen/cpu/vec/vec.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -113,4 +113,4 @@ void channel_shuffle_kernel_impl(
 
 REGISTER_DISPATCH(channel_shuffle_kernel, &channel_shuffle_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/ComplexKernel.cpp b/aten/src/ATen/native/cpu/ComplexKernel.cpp
index f47f75ef4b..80b1c8b473 100644
--- a/aten/src/ATen/native/cpu/ComplexKernel.cpp
+++ b/aten/src/ATen/native/cpu/ComplexKernel.cpp
@@ -4,7 +4,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cpu/Loops.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void complex_kernel(TensorIterator& iter) {
@@ -28,4 +28,4 @@ void polar_kernel(TensorIterator& iter) {
 REGISTER_DISPATCH(complex_stub, &complex_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(polar_stub, &polar_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/CopyKernel.cpp b/aten/src/ATen/native/cpu/CopyKernel.cpp
index c60496c90d..4eaded34f8 100644
--- a/aten/src/ATen/native/cpu/CopyKernel.cpp
+++ b/aten/src/ATen/native/cpu/CopyKernel.cpp
@@ -10,7 +10,7 @@
 #include <ATen/TensorIteratorInternal.h>
 #include <ATen/Parallel.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
 
 static void float_bfloat16_copy_kernel(TensorIteratorBase &iter, bool requires_neg) {
@@ -297,4 +297,4 @@ void copy_kernel(TensorIterator& iter, bool /*non_blocking*/) {
 
 REGISTER_DISPATCH(copy_stub, &copy_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/CrossKernel.cpp b/aten/src/ATen/native/cpu/CrossKernel.cpp
index 0394a9f524..6f4e774346 100644
--- a/aten/src/ATen/native/cpu/CrossKernel.cpp
+++ b/aten/src/ATen/native/cpu/CrossKernel.cpp
@@ -11,7 +11,7 @@
 #include <ATen/Parallel.h>
 #include <ATen/TensorIterator.h>
 #include <c10/util/irange.h>
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template<typename scalar_t>
@@ -78,4 +78,4 @@ static void cross_kernel_impl(const Tensor& result, const Tensor& a, const Tenso
 
 REGISTER_DISPATCH(cross_stub, &cross_kernel_impl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/DepthwiseConvKernel.cpp b/aten/src/ATen/native/cpu/DepthwiseConvKernel.cpp
index 3a34ad3f7a..6606a314d8 100644
--- a/aten/src/ATen/native/cpu/DepthwiseConvKernel.cpp
+++ b/aten/src/ATen/native/cpu/DepthwiseConvKernel.cpp
@@ -15,7 +15,7 @@
 #include <arm_neon.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 struct Arguments final {
@@ -312,4 +312,4 @@ Tensor _convolution_depthwise3x3_winograd(
 
 ALSO_REGISTER_AVX512_DISPATCH(convolution_depthwise3x3_winograd_stub, &_convolution_depthwise3x3_winograd);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/DistanceOpsKernel.cpp b/aten/src/ATen/native/cpu/DistanceOpsKernel.cpp
index f2346759cb..f0658c2644 100644
--- a/aten/src/ATen/native/cpu/DistanceOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/DistanceOpsKernel.cpp
@@ -10,7 +10,7 @@
 #include <ATen/cpu/vec/functional.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template<typename scalar_t>
@@ -448,4 +448,4 @@ REGISTER_DISPATCH(pdist_backward_stub, &pdist_backward_kernel_impl);
 REGISTER_DISPATCH(cdist_stub, &cdist_kernel_impl);
 REGISTER_DISPATCH(cdist_backward_stub, &cdist_backward_kernel_impl);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/DistributionKernels.cpp b/aten/src/ATen/native/cpu/DistributionKernels.cpp
index 6dce481853..a3081a7c25 100644
--- a/aten/src/ATen/native/cpu/DistributionKernels.cpp
+++ b/aten/src/ATen/native/cpu/DistributionKernels.cpp
@@ -23,7 +23,7 @@
 #include <cpuinfo.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static void cauchy_kernel(TensorIteratorBase& iter, double median, double sigma, c10::optional<Generator> gen) {
@@ -247,4 +247,4 @@ REGISTER_DISPATCH(random_from_to_stub, &random_from_to_kernel);
 REGISTER_DISPATCH(random_full_64_bits_range_stub, &random_full_64_bits_range_kernel);
 REGISTER_DISPATCH(random_stub, &random_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/FillKernel.cpp b/aten/src/ATen/native/cpu/FillKernel.cpp
index a04ffdbf90..ff1b239525 100644
--- a/aten/src/ATen/native/cpu/FillKernel.cpp
+++ b/aten/src/ATen/native/cpu/FillKernel.cpp
@@ -9,7 +9,7 @@
 #include <ATen/native/Fill.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 
@@ -58,4 +58,4 @@ void fill_kernel(TensorIterator& iter, const Scalar& value_scalar) {
 
 REGISTER_DISPATCH(fill_stub, &fill_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/FlashAttentionKernel.cpp b/aten/src/ATen/native/cpu/FlashAttentionKernel.cpp
index a93784acc1..f04e644217 100644
--- a/aten/src/ATen/native/cpu/FlashAttentionKernel.cpp
+++ b/aten/src/ATen/native/cpu/FlashAttentionKernel.cpp
@@ -17,7 +17,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -627,4 +627,4 @@ void flash_attention_backward_kernel_impl(
 ALSO_REGISTER_AVX512_DISPATCH(flash_attention_kernel, &flash_attention_kernel_impl);
 ALSO_REGISTER_AVX512_DISPATCH(flash_attention_backward_kernel, &flash_attention_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/FunctionOfAMatrixUtilsKernel.cpp b/aten/src/ATen/native/cpu/FunctionOfAMatrixUtilsKernel.cpp
index 92cf41c309..c0ba5c083c 100644
--- a/aten/src/ATen/native/cpu/FunctionOfAMatrixUtilsKernel.cpp
+++ b/aten/src/ATen/native/cpu/FunctionOfAMatrixUtilsKernel.cpp
@@ -11,7 +11,7 @@
 #define RESTRICT __restrict__
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -54,4 +54,4 @@ void _compute_linear_combination_cpu_kernel(
 
 REGISTER_DISPATCH(_compute_linear_combination_stub, &_compute_linear_combination_cpu_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/GridSamplerKernel.cpp b/aten/src/ATen/native/cpu/GridSamplerKernel.cpp
index 5c02472be5..ddd35cc19b 100644
--- a/aten/src/ATen/native/cpu/GridSamplerKernel.cpp
+++ b/aten/src/ATen/native/cpu/GridSamplerKernel.cpp
@@ -14,7 +14,7 @@
 #include <cstring>
 #include <type_traits>
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 /**  NOTE [ Grid Sample CPU Kernels ]
  *
@@ -1326,4 +1326,4 @@ REGISTER_DISPATCH(grid_sampler_2d_cpu_kernel, &grid_sampler_2d_cpu_kernel_impl);
 REGISTER_DISPATCH(grid_sampler_2d_backward_cpu_kernel, &grid_sampler_2d_backward_cpu_kernel_impl);
 
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/HistogramKernel.cpp b/aten/src/ATen/native/cpu/HistogramKernel.cpp
index e3a2b6c30b..b44a6ffc36 100644
--- a/aten/src/ATen/native/cpu/HistogramKernel.cpp
+++ b/aten/src/ATen/native/cpu/HistogramKernel.cpp
@@ -20,7 +20,7 @@
 #include <numeric>
 #include <functional>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -312,4 +312,4 @@ REGISTER_DISPATCH(histogramdd_stub, &histogramdd_kernel_impl);
 REGISTER_DISPATCH(histogramdd_linear_stub, &histogramdd_linear_kernel_impl);
 REGISTER_DISPATCH(histogram_select_outer_bin_edges_stub, &histogram_select_outer_bin_edges_impl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/IndexKernel.cpp b/aten/src/ATen/native/cpu/IndexKernel.cpp
index 36ce92f04d..9729de15fc 100644
--- a/aten/src/ATen/native/cpu/IndexKernel.cpp
+++ b/aten/src/ATen/native/cpu/IndexKernel.cpp
@@ -15,7 +15,7 @@
 #include <c10/util/irange.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using namespace vec;
@@ -783,4 +783,4 @@ REGISTER_DISPATCH(masked_select_stub, &masked_select_kernel);
 REGISTER_DISPATCH(masked_scatter_stub, &masked_scatter_kernel);
 REGISTER_DISPATCH(flip_stub, &flip_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/LinearAlgebraKernel.cpp b/aten/src/ATen/native/cpu/LinearAlgebraKernel.cpp
index f93394bb5e..d89354daef 100644
--- a/aten/src/ATen/native/cpu/LinearAlgebraKernel.cpp
+++ b/aten/src/ATen/native/cpu/LinearAlgebraKernel.cpp
@@ -8,7 +8,7 @@
 #include <ATen/native/cpu/Loops.h>
 #include <c10/util/irange.h>
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 void addr_kernel(TensorIterator &iter,
                  const Scalar& beta, const Scalar& alpha) {
@@ -86,4 +86,4 @@ void addr_kernel(TensorIterator &iter,
 } // anonymous namespace
 
 REGISTER_DISPATCH(addr_stub, &addr_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/MaxPoolKernel.cpp b/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
index 37f6957435..bbb8bc7ab2 100644
--- a/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/MaxPoolKernel.cpp
@@ -12,7 +12,7 @@
 #include <type_traits>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -752,4 +752,4 @@ REGISTER_DISPATCH(max_pool2d_kernel, &max_pool2d_kernel_impl);
 REGISTER_DISPATCH(max_pool2d_backward_kernel, &max_pool2d_backward_kernel_impl);
 REGISTER_DISPATCH(max_pool3d_kernel, &max_pool3d_kernel_impl);
 REGISTER_DISPATCH(max_pool3d_backward_kernel, &max_pool3d_backward_kernel_impl);
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/MaxPooling.cpp b/aten/src/ATen/native/cpu/MaxPooling.cpp
index 806f284d1e..a855d0805c 100644
--- a/aten/src/ATen/native/cpu/MaxPooling.cpp
+++ b/aten/src/ATen/native/cpu/MaxPooling.cpp
@@ -6,7 +6,7 @@
 #include <ATen/native/MaxPooling.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -78,4 +78,4 @@ void max_pool1d_impl(
 
 REGISTER_DISPATCH(max_pool1d_stub, &max_pool1d_impl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp b/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
index c9dc3eded2..2b186f3313 100644
--- a/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
+++ b/aten/src/ATen/native/cpu/MaxUnpoolKernel.cpp
@@ -9,7 +9,7 @@
 
 #include <c10/util/Optional.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -269,4 +269,4 @@ void max_unpool3d_kernel_impl(
 REGISTER_DISPATCH(max_unpool2d_kernel, &max_unpool2d_kernel_impl);
 REGISTER_DISPATCH(max_unpool3d_kernel, &max_unpool3d_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/MultinomialKernel.cpp b/aten/src/ATen/native/cpu/MultinomialKernel.cpp
index c5c2eebb5d..de2c06f728 100644
--- a/aten/src/ATen/native/cpu/MultinomialKernel.cpp
+++ b/aten/src/ATen/native/cpu/MultinomialKernel.cpp
@@ -15,7 +15,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t>
@@ -242,4 +242,4 @@ static void multinomial_with_replacement_kernel_impl(
 REGISTER_DISPATCH(
     multinomial_with_replacement_stub,
     &multinomial_with_replacement_kernel_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/NativeMultiheadAttnKernel.cpp b/aten/src/ATen/native/cpu/NativeMultiheadAttnKernel.cpp
index 6b9859b333..acb776b4de 100644
--- a/aten/src/ATen/native/cpu/NativeMultiheadAttnKernel.cpp
+++ b/aten/src/ATen/native/cpu/NativeMultiheadAttnKernel.cpp
@@ -10,7 +10,7 @@
 #include <ATen/native/transformers/attention.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -108,4 +108,4 @@ void transform_bias_rescale_qkv_kernel_impl(
 
 REGISTER_DISPATCH(transform_bias_rescale_qkv_stub, &transform_bias_rescale_qkv_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/PaddingKernel.cpp b/aten/src/ATen/native/cpu/PaddingKernel.cpp
index ca438f144b..4eefd066dc 100644
--- a/aten/src/ATen/native/cpu/PaddingKernel.cpp
+++ b/aten/src/ATen/native/cpu/PaddingKernel.cpp
@@ -8,7 +8,7 @@
 #include <ATen/native/cpu/utils.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -726,4 +726,4 @@ REGISTER_DISPATCH(replication_pad2d_backward_kernel, &replication_pad2d_backward
 REGISTER_DISPATCH(replication_pad3d_kernel, &replication_pad3d_kernel_impl);
 REGISTER_DISPATCH(replication_pad3d_backward_kernel, &replication_pad3d_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/PixelShuffleKernel.cpp b/aten/src/ATen/native/cpu/PixelShuffleKernel.cpp
index b654518ae2..4f1a07ad7c 100644
--- a/aten/src/ATen/native/cpu/PixelShuffleKernel.cpp
+++ b/aten/src/ATen/native/cpu/PixelShuffleKernel.cpp
@@ -8,7 +8,7 @@
 #include <ATen/cpu/vec/vec.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -250,4 +250,4 @@ void pixel_unshuffle_kernel_impl(
 REGISTER_DISPATCH(pixel_shuffle_kernel, &pixel_shuffle_kernel_impl);
 REGISTER_DISPATCH(pixel_unshuffle_kernel, &pixel_unshuffle_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/PointwiseOpsKernel.cpp b/aten/src/ATen/native/cpu/PointwiseOpsKernel.cpp
index 25243b2b19..ea84999c46 100644
--- a/aten/src/ATen/native/cpu/PointwiseOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/PointwiseOpsKernel.cpp
@@ -6,7 +6,7 @@
 #include <ATen/native/cpu/Loops.h>
 #include <c10/core/Scalar.h>
 #include <ATen/cpu/vec/functional.h>
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static void addcmul_cpu_kernel(TensorIteratorBase& iter, const Scalar& value) {
@@ -242,4 +242,4 @@ REGISTER_DISPATCH(smooth_l1_backward_stub, &smooth_l1_backward_cpu_kernel);
 REGISTER_DISPATCH(huber_backward_stub, &huber_backward_cpu_kernel);
 REGISTER_DISPATCH(mse_backward_stub, &mse_backward_cpu_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/PowKernel.cpp b/aten/src/ATen/native/cpu/PowKernel.cpp
index 6885e096fb..b443ac2276 100644
--- a/aten/src/ATen/native/cpu/PowKernel.cpp
+++ b/aten/src/ATen/native/cpu/PowKernel.cpp
@@ -10,7 +10,7 @@
 
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 inline namespace CPU_CAPABILITY {
 
@@ -147,4 +147,4 @@ static void pow_tensor_scalar_kernel(
 ALSO_REGISTER_AVX512_DISPATCH(pow_tensor_tensor_stub, &CPU_CAPABILITY::pow_tensor_tensor_kernel);
 ALSO_REGISTER_AVX512_DISPATCH(pow_tensor_scalar_stub, &CPU_CAPABILITY::pow_tensor_scalar_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/RangeFactoriesKernel.cpp b/aten/src/ATen/native/cpu/RangeFactoriesKernel.cpp
index 28adc7040c..5c5cbaf507 100644
--- a/aten/src/ATen/native/cpu/RangeFactoriesKernel.cpp
+++ b/aten/src/ATen/native/cpu/RangeFactoriesKernel.cpp
@@ -13,7 +13,7 @@
 
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using namespace vec;
@@ -74,4 +74,4 @@ static void linspace_kernel(TensorIterator& iter, const Scalar& scalar_start, co
 REGISTER_DISPATCH(arange_stub, &arange_kernel);
 REGISTER_DISPATCH(linspace_stub, &linspace_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/ReduceAllOpsKernel.cpp b/aten/src/ATen/native/cpu/ReduceAllOpsKernel.cpp
index 125f3ce3d1..1744bed0d3 100644
--- a/aten/src/ATen/native/cpu/ReduceAllOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/ReduceAllOpsKernel.cpp
@@ -15,7 +15,7 @@
 #include <ATen/cpu/vec/vec.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using namespace vec;
@@ -224,4 +224,4 @@ REGISTER_DISPATCH(min_all_stub, &min_all_kernel_impl);
 REGISTER_DISPATCH(max_all_stub, &max_all_kernel_impl);
 REGISTER_DISPATCH(aminmax_allreduce_stub, &aminmax_allreduce_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/ReduceOpsKernel.cpp b/aten/src/ATen/native/cpu/ReduceOpsKernel.cpp
index 405fda4d58..28ebb1424f 100644
--- a/aten/src/ATen/native/cpu/ReduceOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/ReduceOpsKernel.cpp
@@ -24,7 +24,7 @@
 #include <c10/util/irange.h>
 #include <ATen/AccumulateType.h>
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 using namespace vec;
 
@@ -463,4 +463,4 @@ REGISTER_DISPATCH(cumprod_stub, &cumprod_cpu_kernel);
 REGISTER_DISPATCH(cumsum_stub, &cumsum_cpu_kernel);
 REGISTER_DISPATCH(logcumsumexp_stub, &logcumsumexp_cpu_kernel);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/ReduceUtils.h b/aten/src/ATen/native/cpu/ReduceUtils.h
index c54dc494fb..082ebb7bcc 100644
--- a/aten/src/ATen/native/cpu/ReduceUtils.h
+++ b/aten/src/ATen/native/cpu/ReduceUtils.h
@@ -10,7 +10,7 @@
 #include <ATen/native/cpu/utils.h>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
 
 using namespace vec;
@@ -237,4 +237,4 @@ inline void write(scalar_t* out, int64_t count, int64_t K) {
 }
 
 } // namespace CPU_CAPABILITY
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/RenormKernel.cpp b/aten/src/ATen/native/cpu/RenormKernel.cpp
index f684d59328..62fc75a3d7 100644
--- a/aten/src/ATen/native/cpu/RenormKernel.cpp
+++ b/aten/src/ATen/native/cpu/RenormKernel.cpp
@@ -7,7 +7,7 @@
 
 #include <ATen/Dispatch.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void renorm_scale_factor_impl(TensorIteratorBase& iter, double maxnorm) {
@@ -35,4 +35,4 @@ void renorm_scale_factor_impl(TensorIteratorBase& iter, double maxnorm) {
 
 REGISTER_DISPATCH(renorm_scale_factor_stub, &renorm_scale_factor_impl);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/SampledAddmmKernel.cpp b/aten/src/ATen/native/cpu/SampledAddmmKernel.cpp
index 731f91c349..29e9d113ad 100644
--- a/aten/src/ATen/native/cpu/SampledAddmmKernel.cpp
+++ b/aten/src/ATen/native/cpu/SampledAddmmKernel.cpp
@@ -9,7 +9,7 @@
 #include <ATen/native/cpu/utils.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -96,4 +96,4 @@ void sampled_addmm_sparse_csr_kernel(
 
 REGISTER_DISPATCH(sampled_addmm_sparse_csr_stub, &sampled_addmm_sparse_csr_kernel);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/ScatterGatherKernel.cpp b/aten/src/ATen/native/cpu/ScatterGatherKernel.cpp
index cae9260b57..638f60f646 100644
--- a/aten/src/ATen/native/cpu/ScatterGatherKernel.cpp
+++ b/aten/src/ATen/native/cpu/ScatterGatherKernel.cpp
@@ -24,7 +24,7 @@
 #include <ATen/ops/empty.h>
 #include <ATen/ops/zeros.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -968,4 +968,4 @@ REGISTER_DISPATCH(scatter_add_expanded_index_stub, &scatter_add_expanded_index_k
 REGISTER_DISPATCH(scatter_reduce_expanded_index_stub, &scatter_reduce_expanded_index_kernel);
 REGISTER_DISPATCH(gather_expanded_index_stub, &gather_expanded_index_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/SoftMaxKernel.cpp b/aten/src/ATen/native/cpu/SoftMaxKernel.cpp
index 1157009d7a..ca6c6ca901 100644
--- a/aten/src/ATen/native/cpu/SoftMaxKernel.cpp
+++ b/aten/src/ATen/native/cpu/SoftMaxKernel.cpp
@@ -28,7 +28,7 @@
 //
 // We use a chunk size such that it'd fit in L1D.
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 template <typename scalar_t>
@@ -107,7 +107,7 @@ inline void _vec_log_softmax_lastdim(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax_lastdim(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -141,7 +141,7 @@ _vec_softmax_lastdim(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax_lastdim(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -260,7 +260,7 @@ inline void _vec_host_softmax_backward_lastdim(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax_backward(
     scalar_t* grad_input_data_base,
     scalar_t* grad_output_data_base,
@@ -343,7 +343,7 @@ _vec_softmax_backward(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax_backward(
     scalar_t* grad_input_data_base,
     scalar_t* grad_output_data_base,
@@ -469,7 +469,7 @@ _vec_softmax_backward(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_log_softmax_backward(
     scalar_t* grad_input_data_base,
     scalar_t* grad_output_data_base,
@@ -551,7 +551,7 @@ _vec_log_softmax_backward(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_log_softmax_backward(
     scalar_t* grad_input_data_base,
     scalar_t* grad_output_data_base,
@@ -683,7 +683,7 @@ struct vec_host_softmax_lastdim {
 };
 
 template<typename scalar_t>
-inline typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -791,7 +791,7 @@ _vec_softmax(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_softmax(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -885,7 +885,7 @@ _vec_softmax(
 // {dim_size, CHUNK_SIZE}, block size (128KB) selected to be L2 hit.
 //
 template<typename scalar_t>
-inline typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_logsoftmax(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -989,7 +989,7 @@ _vec_logsoftmax(
 }
 
 template<typename scalar_t>
-inline typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+inline typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 _vec_logsoftmax(
     scalar_t* input_data_base,
     scalar_t* output_data_base,
@@ -1300,4 +1300,4 @@ ALSO_REGISTER_AVX512_DISPATCH(softmax_backward_kernel, &softmax_backward_kernel_
 ALSO_REGISTER_AVX512_DISPATCH(
     log_softmax_backward_kernel,
     &log_softmax_backward_kernel_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/SortingKernel.cpp b/aten/src/ATen/native/cpu/SortingKernel.cpp
index 8975690658..c1a96489ad 100644
--- a/aten/src/ATen/native/cpu/SortingKernel.cpp
+++ b/aten/src/ATen/native/cpu/SortingKernel.cpp
@@ -19,7 +19,7 @@
 #include <fbgemm/Utils.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -246,4 +246,4 @@ static void topk_kernel(
 REGISTER_DISPATCH(sort_stub, &sort_kernel);
 REGISTER_DISPATCH(topk_stub, &topk_kernel);
 
-} //at::native
+}} //at::native
diff --git a/aten/src/ATen/native/cpu/SparseFactories.cpp b/aten/src/ATen/native/cpu/SparseFactories.cpp
index 8f938e545f..411fc2c7ce 100644
--- a/aten/src/ATen/native/cpu/SparseFactories.cpp
+++ b/aten/src/ATen/native/cpu/SparseFactories.cpp
@@ -8,7 +8,7 @@
 #include <c10/core/ScalarType.h>
 #include <c10/util/Exception.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 void _spdiags_kernel_cpu(
@@ -62,4 +62,4 @@ void _spdiags_kernel_cpu(
 
 REGISTER_DISPATCH(spdiags_kernel_stub, &_spdiags_kernel_cpu)
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/SpmmReduceKernel.h b/aten/src/ATen/native/cpu/SpmmReduceKernel.h
index cbcbf3c63d..1259692b09 100644
--- a/aten/src/ATen/native/cpu/SpmmReduceKernel.h
+++ b/aten/src/ATen/native/cpu/SpmmReduceKernel.h
@@ -4,7 +4,7 @@
 #include <ATen/native/DispatchStub.h>
 #include <ATen/native/ReductionType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using spmm_reduce_fn = void(*)(const Tensor&, const Tensor&, const Tensor&, const Tensor&, const Tensor&, ReductionType op);
 using spmm_reduce_arg_fn = void(*)(const Tensor&, const Tensor&, const Tensor&, const Tensor&, const Tensor&, const Tensor&, ReductionType op);
@@ -19,4 +19,4 @@ DECLARE_DISPATCH(spmm_reduce_backward_input_arg_fn, spmm_reduce_backward_input_a
 DECLARE_DISPATCH(spmm_reduce_backward_other_fn, spmm_reduce_backward_other_stub);
 DECLARE_DISPATCH(spmm_reduce_backward_input_arg_fn, spmm_reduce_backward_other_arg_stub);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/StackKernel.cpp b/aten/src/ATen/native/cpu/StackKernel.cpp
index 999b0d07b9..55544fc920 100644
--- a/aten/src/ATen/native/cpu/StackKernel.cpp
+++ b/aten/src/ATen/native/cpu/StackKernel.cpp
@@ -6,7 +6,7 @@
 #include <ATen/native/cpu/StackKernel.h>
 #include <ATen/native/cpu/SerialStackImpl.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -21,4 +21,4 @@ void stack_serial_kernel(Tensor& result, TensorList tensors, int64_t dim) {
 
 REGISTER_DISPATCH(stack_serial_stub, &stack_serial_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/SumKernel.cpp b/aten/src/ATen/native/cpu/SumKernel.cpp
index 3f0fde5d4b..8218a81d9a 100644
--- a/aten/src/ATen/native/cpu/SumKernel.cpp
+++ b/aten/src/ATen/native/cpu/SumKernel.cpp
@@ -9,7 +9,7 @@
 
 #include <algorithm>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 // Load vector from a smaller type (more elements) to a larger type (fewer elements),
@@ -635,4 +635,4 @@ void nansum_kernel_impl(TensorIterator &iter) {
 REGISTER_DISPATCH(nansum_stub, &nansum_kernel_impl);
 REGISTER_DISPATCH(sum_stub, &sum_kernel_impl);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cpu/TensorCompareKernel.cpp b/aten/src/ATen/native/cpu/TensorCompareKernel.cpp
index f014c34c7e..39504a5855 100644
--- a/aten/src/ATen/native/cpu/TensorCompareKernel.cpp
+++ b/aten/src/ATen/native/cpu/TensorCompareKernel.cpp
@@ -26,7 +26,7 @@
 #include <ATen/ops/result_type.h>
 #endif
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 template <typename scalar_t, typename scalar_t_2 = int64_t, typename loop1d_t>
 static inline void compare_base_kernel_core(
@@ -412,4 +412,4 @@ REGISTER_DISPATCH(clamp_min_scalar_stub, &clamp_min_scalar_kernel_impl);
 REGISTER_DISPATCH(clamp_max_scalar_stub, &clamp_max_scalar_kernel_impl);
 REGISTER_DISPATCH(isin_default_stub, &isin_default_kernel_cpu);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/UnaryOpsKernel.cpp b/aten/src/ATen/native/cpu/UnaryOpsKernel.cpp
index a966e4ac6d..9421e76c40 100644
--- a/aten/src/ATen/native/cpu/UnaryOpsKernel.cpp
+++ b/aten/src/ATen/native/cpu/UnaryOpsKernel.cpp
@@ -28,7 +28,7 @@
 #include <mkl.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 inline namespace CPU_CAPABILITY {
 
@@ -884,4 +884,4 @@ STATIC_IMPLEMENT_COMPLEX_KERNEL_WITH_AVX512(log2);
 STATIC_IMPLEMENT_COMPLEX_KERNEL_WITH_AVX512(tanh);
 IMPLEMENT_FLOAT_KERNEL_WITH_AVX512(lgamma);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/Unfold2d.cpp b/aten/src/ATen/native/cpu/Unfold2d.cpp
index bb35ef23b8..4875cd8f40 100644
--- a/aten/src/ATen/native/cpu/Unfold2d.cpp
+++ b/aten/src/ATen/native/cpu/Unfold2d.cpp
@@ -8,7 +8,7 @@
 #include <ATen/native/cpu/utils.h>
 #include <cmath>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -448,4 +448,4 @@ void unfolded2d_copy_kernel(
 REGISTER_DISPATCH(unfolded2d_copy_stub, &unfolded2d_copy_kernel);
 REGISTER_DISPATCH(unfolded2d_acc_stub, &unfolded2d_acc_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/UnfoldBackwardKernel.cpp b/aten/src/ATen/native/cpu/UnfoldBackwardKernel.cpp
index 35049ce21d..2ba3538b4a 100644
--- a/aten/src/ATen/native/cpu/UnfoldBackwardKernel.cpp
+++ b/aten/src/ATen/native/cpu/UnfoldBackwardKernel.cpp
@@ -53,7 +53,7 @@
 // and then the corresponding value of grad_in[...,i_in_dim,...,i_in_last_dim]
 // gets added up to grad_out[...,i_out_dim,...].
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -149,4 +149,4 @@ void unfold_backward_cpu_kernel(
 
 REGISTER_DISPATCH(unfold_backward_stub, &unfold_backward_cpu_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/UpSampleKernel.cpp b/aten/src/ATen/native/cpu/UpSampleKernel.cpp
index bee568881a..d7e1a6f975 100644
--- a/aten/src/ATen/native/cpu/UpSampleKernel.cpp
+++ b/aten/src/ATen/native/cpu/UpSampleKernel.cpp
@@ -18,7 +18,7 @@
 #include <ATen/ops/ones.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using scale_t = std::vector<c10::optional<double>>;
@@ -2038,4 +2038,4 @@ REGISTER_DISPATCH(upsample_trilinear3d_kernel, &upsample_trilinear3d_kernel_impl
 REGISTER_DISPATCH(upsample_bicubic2d_kernel, &upsample_bicubic2d_kernel_impl);
 REGISTER_DISPATCH(_upsample_bicubic2d_aa_kernel, &upsample_bicubic2d_aa_kernel_impl);
 REGISTER_DISPATCH(_upsample_bicubic2d_aa_backward_kernel, &upsample_bicubic2d_aa_backward_kernel_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/UpSampleMoreKernel.cpp b/aten/src/ATen/native/cpu/UpSampleMoreKernel.cpp
index 0e2511394e..934876d065 100644
--- a/aten/src/ATen/native/cpu/UpSampleMoreKernel.cpp
+++ b/aten/src/ATen/native/cpu/UpSampleMoreKernel.cpp
@@ -9,7 +9,7 @@
 #include <c10/util/irange.h>
 #include <ATen/cpu/vec/vec.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using scale_t = std::vector<c10::optional<double>>;
@@ -779,4 +779,4 @@ REGISTER_DISPATCH(upsample_linear1d_backward_kernel, &upsample_linear1d_backward
 REGISTER_DISPATCH(upsample_bilinear2d_backward_kernel, &upsample_bilinear2d_backward_kernel_impl);
 REGISTER_DISPATCH(upsample_trilinear3d_backward_kernel, &upsample_trilinear3d_backward_kernel_impl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/WeightNormKernel.cpp b/aten/src/ATen/native/cpu/WeightNormKernel.cpp
index cace911114..cd1da64149 100644
--- a/aten/src/ATen/native/cpu/WeightNormKernel.cpp
+++ b/aten/src/ATen/native/cpu/WeightNormKernel.cpp
@@ -10,7 +10,7 @@
 #include <ATen/cpu/vec/vec.h>
 #include <c10/util/irange.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -446,4 +446,4 @@ void weight_norm_backward_kernel(
 REGISTER_DISPATCH(weight_norm_stub, &weight_norm_kernel);
 REGISTER_DISPATCH(weight_norm_backward_stub, &weight_norm_backward_kernel);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cpu/airy_ai.cpp b/aten/src/ATen/native/cpu/airy_ai.cpp
index ee75717b8d..0db304f786 100644
--- a/aten/src/ATen/native/cpu/airy_ai.cpp
+++ b/aten/src/ATen/native/cpu/airy_ai.cpp
@@ -7,7 +7,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cpu/Loops.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
 static void airy_ai_kernel(TensorIteratorBase& iterator) {
     TORCH_INTERNAL_ASSERT(iterator.ntensors() == 2);
@@ -21,4 +21,4 @@ static void airy_ai_kernel(TensorIteratorBase& iterator) {
 } // namespace CPU_CAPABILITY
 
 REGISTER_DISPATCH(special_airy_ai_stub, &CPU_CAPABILITY::airy_ai_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/batch_norm_kernel.cpp b/aten/src/ATen/native/cpu/batch_norm_kernel.cpp
index ad0a9017af..82256423c5 100644
--- a/aten/src/ATen/native/cpu/batch_norm_kernel.cpp
+++ b/aten/src/ATen/native/cpu/batch_norm_kernel.cpp
@@ -22,7 +22,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using namespace vec;
@@ -71,7 +71,7 @@ void batch_norm_cpu_collect_linear_and_constant_terms(
 
 /// A fast path for CPU inference and training forward when all tensors are contiguous.
 template<typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_contiguous_impl(Tensor& output, const Tensor& input,
     const Tensor& weight, const Tensor& bias, const Tensor& save_mean, const Tensor& save_invstd,
     const Tensor& running_mean, const Tensor& running_var, bool train, double eps) {
@@ -123,7 +123,7 @@ batch_norm_cpu_contiguous_impl(Tensor& output, const Tensor& input,
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_channels_last_impl(Tensor& output, const Tensor& input,
     const Tensor& weight, const Tensor& bias, const Tensor& save_mean, const Tensor& save_invstd,
     const Tensor& running_mean, const Tensor& running_var, bool train, double eps) {
@@ -173,7 +173,7 @@ batch_norm_cpu_channels_last_impl(Tensor& output, const Tensor& input,
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_collect_stats_contiguous_impl(
     Tensor& mean, Tensor& var_sum, const Tensor& input) {
 
@@ -218,7 +218,7 @@ batch_norm_cpu_collect_stats_contiguous_impl(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_collect_stats_channels_last_impl(
     Tensor& mean, Tensor& var_sum, const Tensor& input) {
 
@@ -305,7 +305,7 @@ batch_norm_cpu_collect_stats_channels_last_impl(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_backward_contiguous_impl(Tensor& grad_input, Tensor& grad_weight, Tensor& grad_bias,
     const Tensor& grad_output, const Tensor& input, const Tensor& weight,
     const Tensor& running_mean, const Tensor& running_var, const Tensor& save_mean, const Tensor& save_invstd,
@@ -428,7 +428,7 @@ batch_norm_cpu_backward_contiguous_impl(Tensor& grad_input, Tensor& grad_weight,
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_backward_channels_last_impl(Tensor& grad_input, Tensor& grad_weight, Tensor& grad_bias,
     const Tensor& grad_output, const Tensor& input, const Tensor& weight,
     const Tensor& running_mean, const Tensor& running_var, const Tensor& save_mean, const Tensor& save_invstd,
@@ -610,7 +610,7 @@ batch_norm_cpu_backward_channels_last_impl(Tensor& grad_input, Tensor& grad_weig
 
 /// bfloat16/Half kernels
 template<typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_contiguous_impl(Tensor& output, const Tensor& input,
     const Tensor& weight, const Tensor& bias, const Tensor& save_mean, const Tensor& save_invstd,
     const Tensor& running_mean, const Tensor& running_var, bool train, double eps) {
@@ -675,7 +675,7 @@ batch_norm_cpu_contiguous_impl(Tensor& output, const Tensor& input,
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_channels_last_impl(Tensor& output, const Tensor& input,
     const Tensor& weight, const Tensor& bias, const Tensor& save_mean, const Tensor& save_invstd,
     const Tensor& running_mean, const Tensor& running_var, bool train, double eps) {
@@ -796,7 +796,7 @@ inline void batch_norm_cpu_collect_stats_contiguous_internal(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_collect_stats_contiguous_impl(
     Tensor& mean, Tensor& var_sum, const Tensor& input) {
   const bool mixed_type = is_mixed_type(input, mean, var_sum);
@@ -893,7 +893,7 @@ inline void batch_norm_cpu_collect_stats_channels_last_internal(
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_collect_stats_channels_last_impl(
     Tensor& mean, Tensor& var_sum, const Tensor& input) {
   const bool mixed_type = is_mixed_type(input, mean, var_sum);
@@ -1015,7 +1015,7 @@ void batch_norm_cpu_backward_contiguous_internal(Tensor& grad_input, Tensor& gra
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_backward_contiguous_impl(Tensor& grad_input, Tensor& grad_weight, Tensor& grad_bias,
     const Tensor& grad_output, const Tensor& input, const Tensor& weight,
     const Tensor& running_mean, const Tensor& running_var, const Tensor& save_mean, const Tensor& save_invstd,
@@ -1228,7 +1228,7 @@ void batch_norm_cpu_backward_channels_last_internal(Tensor& grad_input, Tensor&
 }
 
 template <typename scalar_t>
-typename std::enable_if_t<!std::is_same_v<scalar_t, at::opmath_type<scalar_t>>, void>
+typename std::enable_if_t<!std::is_same<scalar_t, at::opmath_type<scalar_t>>::value, void>
 batch_norm_cpu_backward_channels_last_impl(Tensor& grad_input, Tensor& grad_weight, Tensor& grad_bias,
     const Tensor& grad_output, const Tensor& input, const Tensor& weight,
     const Tensor& running_mean, const Tensor& running_var, const Tensor& save_mean, const Tensor& save_invstd,
@@ -1318,4 +1318,4 @@ REGISTER_DISPATCH(batch_norm_cpu_stub, &batch_norm_cpu_kernel);
 REGISTER_DISPATCH(batch_norm_cpu_collect_stats_stub, &batch_norm_cpu_collect_stats_kernel);
 REGISTER_DISPATCH(batch_norm_cpu_backward_stub, &batch_norm_cpu_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/group_norm_kernel.cpp b/aten/src/ATen/native/cpu/group_norm_kernel.cpp
index fc7aad9c28..9dd13a786c 100644
--- a/aten/src/ATen/native/cpu/group_norm_kernel.cpp
+++ b/aten/src/ATen/native/cpu/group_norm_kernel.cpp
@@ -21,7 +21,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1587,4 +1587,4 @@ void GroupNormBackwardKernelImpl(
 REGISTER_DISPATCH(GroupNormKernel, &GroupNormKernelImpl);
 REGISTER_DISPATCH(GroupNormBackwardKernel, &GroupNormBackwardKernelImpl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/layer_norm_kernel.cpp b/aten/src/ATen/native/cpu/layer_norm_kernel.cpp
index a0c3e0955e..a098268f70 100644
--- a/aten/src/ATen/native/cpu/layer_norm_kernel.cpp
+++ b/aten/src/ATen/native/cpu/layer_norm_kernel.cpp
@@ -19,7 +19,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -620,4 +620,4 @@ void LayerNormBackwardKernelImpl(
 REGISTER_DISPATCH(LayerNormKernel, &LayerNormKernelImpl);
 REGISTER_DISPATCH(LayerNormBackwardKernel, &LayerNormBackwardKernelImpl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/scaled_modified_bessel_k0.cpp b/aten/src/ATen/native/cpu/scaled_modified_bessel_k0.cpp
index c706b225da..93f8fe64d0 100644
--- a/aten/src/ATen/native/cpu/scaled_modified_bessel_k0.cpp
+++ b/aten/src/ATen/native/cpu/scaled_modified_bessel_k0.cpp
@@ -7,7 +7,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cpu/Loops.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
     static void scaled_modified_bessel_k0_kernel(TensorIteratorBase& iterator) {
         TORCH_INTERNAL_ASSERT(iterator.ntensors() == 2);
@@ -21,4 +21,4 @@ inline namespace CPU_CAPABILITY {
 } // namespace CPU_CAPABILITY
 
 REGISTER_DISPATCH(special_scaled_modified_bessel_k0_stub, &CPU_CAPABILITY::scaled_modified_bessel_k0_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/scaled_modified_bessel_k1.cpp b/aten/src/ATen/native/cpu/scaled_modified_bessel_k1.cpp
index d2d8de7158..286c163fdd 100644
--- a/aten/src/ATen/native/cpu/scaled_modified_bessel_k1.cpp
+++ b/aten/src/ATen/native/cpu/scaled_modified_bessel_k1.cpp
@@ -7,7 +7,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cpu/Loops.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
     static void scaled_modified_bessel_k1_kernel(TensorIteratorBase& iterator) {
         TORCH_INTERNAL_ASSERT(iterator.ntensors() == 2);
@@ -21,4 +21,4 @@ inline namespace CPU_CAPABILITY {
 } // namespace CPU_CAPABILITY
 
 REGISTER_DISPATCH(special_scaled_modified_bessel_k1_stub, &CPU_CAPABILITY::scaled_modified_bessel_k1_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cpu/spherical_bessel_j0.cpp b/aten/src/ATen/native/cpu/spherical_bessel_j0.cpp
index 351ab8670b..fbedf6b450 100644
--- a/aten/src/ATen/native/cpu/spherical_bessel_j0.cpp
+++ b/aten/src/ATen/native/cpu/spherical_bessel_j0.cpp
@@ -7,7 +7,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cpu/Loops.h>
 
-namespace at::native {
+namespace at{ namespace native {
 inline namespace CPU_CAPABILITY {
     static void spherical_bessel_j0_kernel(TensorIteratorBase& iterator) {
         TORCH_INTERNAL_ASSERT(iterator.ntensors() == 2);
@@ -21,4 +21,4 @@ inline namespace CPU_CAPABILITY {
 } // namespace CPU_CAPABILITY
 
 REGISTER_DISPATCH(special_spherical_bessel_j0_stub, &CPU_CAPABILITY::spherical_bessel_j0_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AbsKernel.cu b/aten/src/ATen/native/cuda/AbsKernel.cu
index 980bd66373..d9771875a6 100644
--- a/aten/src/ATen/native/cuda/AbsKernel.cu
+++ b/aten/src/ATen/native/cuda/AbsKernel.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/DispatchStub.h>
 #include <ATen/native/TensorIterator.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template<typename scalar_t>
 struct AbsFunctor {
@@ -48,4 +48,4 @@ void abs_kernel_cuda(TensorIteratorBase& iter) {
 
   REGISTER_DISPATCH(abs_stub, &abs_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Activation.cpp b/aten/src/ATen/native/cuda/Activation.cpp
index 633a5f386a..4622b036fc 100644
--- a/aten/src/ATen/native/cuda/Activation.cpp
+++ b/aten/src/ATen/native/cuda/Activation.cpp
@@ -20,7 +20,7 @@
 #include <ATen/ops/log_sigmoid_forward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // -----------------------------------
 // glu backward
@@ -105,4 +105,4 @@ TORCH_IMPL_FUNC(gelu_backward_out_cuda) (
   GeluBackwardCUDAKernelImpl(*this, get_gelutype_enum(approximate));
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationEluKernel.cu b/aten/src/ATen/native/cuda/ActivationEluKernel.cu
index 3f68b521c0..77758971ea 100644
--- a/aten/src/ATen/native/cuda/ActivationEluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationEluKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void elu_kernel(
@@ -83,4 +83,4 @@ void elu_backward_kernel(
 REGISTER_DISPATCH(elu_stub, &elu_kernel);
 REGISTER_DISPATCH(elu_backward_stub, &elu_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationGeluKernel.cu b/aten/src/ATen/native/cuda/ActivationGeluKernel.cu
index cd5a0ae85e..183ad00b1f 100644
--- a/aten/src/ATen/native/cuda/ActivationGeluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationGeluKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void GeluCUDAKernelImpl(TensorIteratorBase& it, GeluType approximate) {
   if (approximate == GeluType::Tanh) {
@@ -85,4 +85,4 @@ void GeluBackwardCUDAKernelImpl(TensorIteratorBase& it, GeluType approximate) {
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationGluKernel.cu b/aten/src/ATen/native/cuda/ActivationGluKernel.cu
index 15ac2a50c9..e4ea914ef9 100644
--- a/aten/src/ATen/native/cuda/ActivationGluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationGluKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // -----------------------------------
 // glu forward
@@ -138,4 +138,4 @@ void launch_glu_backward_kernel(
 REGISTER_DISPATCH(glu_stub, &glu_kernel);
 REGISTER_DISPATCH(glu_jvp_stub, &glu_jvp_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationHardshrinkKernel.cu b/aten/src/ATen/native/cuda/ActivationHardshrinkKernel.cu
index 3e2ca62e27..b83543a562 100644
--- a/aten/src/ATen/native/cuda/ActivationHardshrinkKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationHardshrinkKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void hardshrink_kernel(TensorIteratorBase& iter, const Scalar& value) {
@@ -36,4 +36,4 @@ void hardshrink_kernel(TensorIteratorBase& iter, const Scalar& value) {
 
 REGISTER_DISPATCH(hardshrink_stub, &hardshrink_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationHardsigmoidKernel.cu b/aten/src/ATen/native/cuda/ActivationHardsigmoidKernel.cu
index f69b5c5dae..8181bdd7cb 100644
--- a/aten/src/ATen/native/cuda/ActivationHardsigmoidKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationHardsigmoidKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void hardsigmoid_kernel(TensorIteratorBase& iter) {
@@ -71,4 +71,4 @@ void hardsigmoid_backward_kernel(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(hardsigmoid_stub, &hardsigmoid_kernel);
 REGISTER_DISPATCH(hardsigmoid_backward_stub, &hardsigmoid_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationHardswishKernel.cu b/aten/src/ATen/native/cuda/ActivationHardswishKernel.cu
index 38011e9ed6..13426b3bd3 100644
--- a/aten/src/ATen/native/cuda/ActivationHardswishKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationHardswishKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void hardswish_kernel(TensorIterator& iter) {
@@ -60,4 +60,4 @@ void hardswish_backward_kernel(TensorIterator& iter) {
 REGISTER_DISPATCH(hardswish_stub, &hardswish_kernel);
 REGISTER_DISPATCH(hardswish_backward_stub, &hardswish_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationHardtanhKernel.cu b/aten/src/ATen/native/cuda/ActivationHardtanhKernel.cu
index 30bb909d58..2bc4f4bbb1 100644
--- a/aten/src/ATen/native/cuda/ActivationHardtanhKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationHardtanhKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void hardtanh_backward_kernel(
@@ -42,4 +42,4 @@ void hardtanh_backward_kernel(
 
 REGISTER_DISPATCH(hardtanh_backward_stub, &hardtanh_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationLeakyReluKernel.cu b/aten/src/ATen/native/cuda/ActivationLeakyReluKernel.cu
index 6b848df333..7e527681f4 100644
--- a/aten/src/ATen/native/cuda/ActivationLeakyReluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationLeakyReluKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void leaky_relu_kernel(TensorIteratorBase& iter, const Scalar& negval_) {
@@ -59,4 +59,4 @@ void leaky_relu_backward_kernel(
 REGISTER_DISPATCH(leaky_relu_stub, &leaky_relu_kernel);
 REGISTER_DISPATCH(leaky_relu_backward_stub, &leaky_relu_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationLogSigmoidKernel.cu b/aten/src/ATen/native/cuda/ActivationLogSigmoidKernel.cu
index eb34d9d463..03426d0633 100644
--- a/aten/src/ATen/native/cuda/ActivationLogSigmoidKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationLogSigmoidKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // -----------------------------------
 // log_sigmoid forward
@@ -61,4 +61,4 @@ void log_sigmoid_backward_kernel(TensorIterator& iter) {
 
 REGISTER_DISPATCH(log_sigmoid_backward_stub, &log_sigmoid_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationMishKernel.cu b/aten/src/ATen/native/cuda/ActivationMishKernel.cu
index e259e64fc0..3822fcbbdc 100644
--- a/aten/src/ATen/native/cuda/ActivationMishKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationMishKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void mish_kernel(TensorIteratorBase& iter) {
@@ -61,4 +61,4 @@ void mish_backward_kernel(TensorIterator& iter) {
 REGISTER_DISPATCH(mish_stub, &mish_kernel);
 REGISTER_DISPATCH(mish_backward_stub, &mish_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationPreluKernel.cu b/aten/src/ATen/native/cuda/ActivationPreluKernel.cu
index d6b7331773..21c18bdf05 100644
--- a/aten/src/ATen/native/cuda/ActivationPreluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationPreluKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // -----------------------------------
 // prelu
@@ -45,4 +45,4 @@ void prelu_backward_kernel(TensorIterator &iter) {
 REGISTER_DISPATCH(prelu_stub, &prelu_kernel);
 REGISTER_DISPATCH(prelu_backward_stub, &prelu_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationSiluKernel.cu b/aten/src/ATen/native/cuda/ActivationSiluKernel.cu
index 82096b96db..261474b46f 100644
--- a/aten/src/ATen/native/cuda/ActivationSiluKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationSiluKernel.cu
@@ -17,7 +17,7 @@
 #include <ATen/native/cuda/Loops.cuh>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void silu_kernel(TensorIteratorBase& iter) {
@@ -57,4 +57,4 @@ void silu_backward_kernel(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(silu_stub, &silu_kernel);
 REGISTER_DISPATCH(silu_backward_stub, &silu_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationSoftplusKernel.cu b/aten/src/ATen/native/cuda/ActivationSoftplusKernel.cu
index 054e42139b..6d39429914 100644
--- a/aten/src/ATen/native/cuda/ActivationSoftplusKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationSoftplusKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void softplus_kernel(
@@ -71,4 +71,4 @@ void softplus_backward_kernel(
 REGISTER_DISPATCH(softplus_stub, &softplus_kernel);
 REGISTER_DISPATCH(softplus_backward_stub, &softplus_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationSoftshrinkKernel.cu b/aten/src/ATen/native/cuda/ActivationSoftshrinkKernel.cu
index a07d0d69a3..9623fe2414 100644
--- a/aten/src/ATen/native/cuda/ActivationSoftshrinkKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationSoftshrinkKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void softshrink_kernel(TensorIteratorBase& iter, const Scalar& value) {
@@ -55,4 +55,4 @@ void shrink_backward_kernel(TensorIteratorBase& iter, const Scalar& value) {
 REGISTER_DISPATCH(softshrink_stub, &softshrink_kernel);
 REGISTER_DISPATCH(shrink_backward_stub, &shrink_backward_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ActivationThresholdKernel.cu b/aten/src/ATen/native/cuda/ActivationThresholdKernel.cu
index 68baa5133e..0ec5cef5bf 100644
--- a/aten/src/ATen/native/cuda/ActivationThresholdKernel.cu
+++ b/aten/src/ATen/native/cuda/ActivationThresholdKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t>
@@ -49,4 +49,4 @@ static void threshold_kernel_cuda(
 
 REGISTER_DISPATCH(threshold_stub, &threshold_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AdaptiveAveragePooling.cu b/aten/src/ATen/native/cuda/AdaptiveAveragePooling.cu
index 2e56875471..017a0a6a9b 100644
--- a/aten/src/ATen/native/cuda/AdaptiveAveragePooling.cu
+++ b/aten/src/ATen/native/cuda/AdaptiveAveragePooling.cu
@@ -37,7 +37,7 @@
 #define CUDA_MAX_THREADS 1024 // this is safe, in reality 256 is our limit
 #define BLOCK_STRIDE 2 // increasing block_stride to lower # of blocks launched
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -803,7 +803,7 @@ namespace {
     return gradInput;
   }
 
-} // namespace at::native
+}} // namespace at::native
 
 #undef BLOCK_STRIDE
 #undef CUDA_MAX_THREADS
diff --git a/aten/src/ATen/native/cuda/AdaptiveAveragePooling3d.cu b/aten/src/ATen/native/cuda/AdaptiveAveragePooling3d.cu
index e070942096..1031d1cda5 100644
--- a/aten/src/ATen/native/cuda/AdaptiveAveragePooling3d.cu
+++ b/aten/src/ATen/native/cuda/AdaptiveAveragePooling3d.cu
@@ -25,7 +25,7 @@
 #include <cmath>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -542,4 +542,4 @@ Tensor adaptive_avg_pool3d_backward_cuda(
   return gradInput;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AdaptiveMaxPooling2d.cu b/aten/src/ATen/native/cuda/AdaptiveMaxPooling2d.cu
index d8fab31bc5..4acc71df1b 100644
--- a/aten/src/ATen/native/cuda/AdaptiveMaxPooling2d.cu
+++ b/aten/src/ATen/native/cuda/AdaptiveMaxPooling2d.cu
@@ -23,7 +23,7 @@
 #include <cmath>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -471,4 +471,4 @@ TORCH_IMPL_FUNC(adaptive_max_pool2d_backward_out_cuda)
     gradInput.copy_(gradInput_c);
   }
  }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AdaptiveMaxPooling3d.cu b/aten/src/ATen/native/cuda/AdaptiveMaxPooling3d.cu
index 06a4cf61ba..64b1d9fc80 100644
--- a/aten/src/ATen/native/cuda/AdaptiveMaxPooling3d.cu
+++ b/aten/src/ATen/native/cuda/AdaptiveMaxPooling3d.cu
@@ -23,7 +23,7 @@
 #include <cmath>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -481,4 +481,4 @@ TORCH_IMPL_FUNC(adaptive_max_pool3d_backward_out_cuda)
         });
   }
  }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AmpKernels.cu b/aten/src/ATen/native/cuda/AmpKernels.cu
index 8c161ca627..079f05f47b 100644
--- a/aten/src/ATen/native/cuda/AmpKernels.cu
+++ b/aten/src/ATen/native/cuda/AmpKernels.cu
@@ -35,7 +35,7 @@ static __host__ __device__ __forceinline__ int isfinite_ensure_cuda_math(float v
 }
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 // Single-tensor fallback for _amp_foreach_non_finite_check_and_unscale_cuda_.
@@ -249,4 +249,4 @@ Tensor& _amp_update_scale_cuda_(Tensor& current_scale,
   return current_scale;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AveragePool2d.cu b/aten/src/ATen/native/cuda/AveragePool2d.cu
index aa887fbcd2..dd9b664508 100644
--- a/aten/src/ATen/native/cuda/AveragePool2d.cu
+++ b/aten/src/ATen/native/cuda/AveragePool2d.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/avg_pool2d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 __device__ inline int min(int a, int b) {
@@ -455,4 +455,4 @@ TORCH_IMPL_FUNC(avg_pool2d_backward_out_cuda) (
   );
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/AveragePool3d.cu b/aten/src/ATen/native/cuda/AveragePool3d.cu
index a722236ea5..4697d8c221 100644
--- a/aten/src/ATen/native/cuda/AveragePool3d.cu
+++ b/aten/src/ATen/native/cuda/AveragePool3d.cu
@@ -21,7 +21,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 __device__ inline int min(int a, int b) {
@@ -603,4 +603,4 @@ TORCH_IMPL_FUNC(avg_pool3d_backward_out_cuda) (
   }
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/BinaryBitwiseOpsKernels.cu b/aten/src/ATen/native/cuda/BinaryBitwiseOpsKernels.cu
index f0a498b064..aebc35d75e 100644
--- a/aten/src/ATen/native/cuda/BinaryBitwiseOpsKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryBitwiseOpsKernels.cu
@@ -8,7 +8,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 template<typename scalar_t>
 struct BitwiseAndFunctor {
@@ -78,4 +78,4 @@ REGISTER_DISPATCH(bitwise_or_stub, &bitwise_or_kernel_cuda);
 REGISTER_DISPATCH(bitwise_xor_stub, &bitwise_xor_kernel_cuda);
 
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryDivFloorKernel.cu b/aten/src/ATen/native/cuda/BinaryDivFloorKernel.cu
index 8bb754c36b..75c722f98a 100644
--- a/aten/src/ATen/native/cuda/BinaryDivFloorKernel.cu
+++ b/aten/src/ATen/native/cuda/BinaryDivFloorKernel.cu
@@ -15,7 +15,7 @@
 
 #include <type_traits>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace binary_internal {
 
 void div_floor_kernel_cuda(TensorIteratorBase& iter) {
@@ -80,4 +80,4 @@ void div_floor_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(div_floor_stub, &binary_internal::div_floor_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryDivTrueKernel.cu b/aten/src/ATen/native/cuda/BinaryDivTrueKernel.cu
index aa955a9c7e..a7861c00cc 100644
--- a/aten/src/ATen/native/cuda/BinaryDivTrueKernel.cu
+++ b/aten/src/ATen/native/cuda/BinaryDivTrueKernel.cu
@@ -13,7 +13,7 @@
 
 #include <type_traits>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace binary_internal {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char div_name[] = "div_kernel";
@@ -58,4 +58,4 @@ void div_true_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(div_true_stub, &binary_internal::div_true_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryDivTruncKernel.cu b/aten/src/ATen/native/cuda/BinaryDivTruncKernel.cu
index 5e906a000b..b8d7568c68 100644
--- a/aten/src/ATen/native/cuda/BinaryDivTruncKernel.cu
+++ b/aten/src/ATen/native/cuda/BinaryDivTruncKernel.cu
@@ -12,7 +12,7 @@
 
 #include <type_traits>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace binary_internal {
 
 void div_trunc_kernel_cuda(TensorIteratorBase& iter) {
@@ -50,4 +50,4 @@ void div_trunc_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(div_trunc_stub, &binary_internal::div_trunc_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryGeometricKernels.cu b/aten/src/ATen/native/cuda/BinaryGeometricKernels.cu
index e734a66e93..f7e3682600 100644
--- a/aten/src/ATen/native/cuda/BinaryGeometricKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryGeometricKernels.cu
@@ -8,7 +8,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void atan2_kernel_cuda(TensorIteratorBase& iter) {
   AT_DISPATCH_FLOATING_TYPES_AND2(
@@ -36,4 +36,4 @@ void hypot_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(atan2_stub, &atan2_kernel_cuda);
 REGISTER_DISPATCH(hypot_stub, &hypot_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryLogicalOpsKernels.cu b/aten/src/ATen/native/cuda/BinaryLogicalOpsKernels.cu
index eaa01ac1ac..76507ad7ac 100644
--- a/aten/src/ATen/native/cuda/BinaryLogicalOpsKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryLogicalOpsKernels.cu
@@ -9,7 +9,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char logical_and_name[] = "logical_and_kernel";
 void logical_and_kernel_cuda(TensorIterator& iter) {
@@ -125,4 +125,4 @@ REGISTER_DISPATCH(logical_or_stub, &logical_or_kernel_cuda);
 REGISTER_DISPATCH(logical_xor_stub, &logical_xor_kernel_cuda);
 
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryMiscBackwardOpsKernels.cu b/aten/src/ATen/native/cuda/BinaryMiscBackwardOpsKernels.cu
index 75d5991f93..40a9a88f89 100644
--- a/aten/src/ATen/native/cuda/BinaryMiscBackwardOpsKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryMiscBackwardOpsKernels.cu
@@ -13,7 +13,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char sigmoid_backward_name[] = "sigmoid_backward";
 void sigmoid_backward_kernel_cuda(TensorIteratorBase& iter) {
@@ -128,4 +128,4 @@ REGISTER_DISPATCH(sigmoid_backward_stub, &sigmoid_backward_kernel_cuda);
 REGISTER_DISPATCH(logit_backward_stub, &logit_backward_kernel_cuda);
 REGISTER_DISPATCH(tanh_backward_stub, &tanh_backward_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryMiscOpsKernels.cu b/aten/src/ATen/native/cuda/BinaryMiscOpsKernels.cu
index 85be724c7a..0eeca76009 100644
--- a/aten/src/ATen/native/cuda/BinaryMiscOpsKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryMiscOpsKernels.cu
@@ -10,7 +10,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void smooth_l1_kernel_cuda(TensorIteratorBase& iter, double beta) {
   AT_DISPATCH_FLOATING_TYPES_AND_HALF(iter.dtype(), "smooth_l1_cuda", [&iter, beta]() {
@@ -78,4 +78,4 @@ REGISTER_DISPATCH(xlog1py_stub, &xlog1py_kernel_cuda);
 // DO NOT ADD ANY NEW KERNELS HERE
 // CUDA compilation times grow quickly.  It's perfectly acceptable to have a file per kernel.
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryMulKernel.cu b/aten/src/ATen/native/cuda/BinaryMulKernel.cu
index 251221f7ad..285c0c4f6a 100644
--- a/aten/src/ATen/native/cuda/BinaryMulKernel.cu
+++ b/aten/src/ATen/native/cuda/BinaryMulKernel.cu
@@ -16,7 +16,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char mul_name[] = "mul_kernel";
 void mul_kernel_cuda(TensorIteratorBase& iter) {
@@ -45,4 +45,4 @@ void mul_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(mul_stub, &mul_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryRemainderKernel.cu b/aten/src/ATen/native/cuda/BinaryRemainderKernel.cu
index dfa2f7124b..01b4a06460 100644
--- a/aten/src/ATen/native/cuda/BinaryRemainderKernel.cu
+++ b/aten/src/ATen/native/cuda/BinaryRemainderKernel.cu
@@ -11,7 +11,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void remainder_kernel_cuda(TensorIteratorBase& iter) {
   if (isIntegralType(iter.common_dtype(), /*includeBool*/ false)) {
@@ -58,4 +58,4 @@ void fmod_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(remainder_stub, &remainder_kernel_cuda);
 REGISTER_DISPATCH(fmod_stub, &fmod_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/BinaryShiftOpsKernels.cu b/aten/src/ATen/native/cuda/BinaryShiftOpsKernels.cu
index a7760d76ef..3988d4447e 100644
--- a/aten/src/ATen/native/cuda/BinaryShiftOpsKernels.cu
+++ b/aten/src/ATen/native/cuda/BinaryShiftOpsKernels.cu
@@ -8,7 +8,15 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+namespace std {
+  template< class T >
+    inline constexpr bool is_signed_v = is_signed<T>::value;
+}
+#endif
+
+namespace at{ namespace native {
 
 
 void lshift_kernel_cuda(TensorIteratorBase& iter) {
@@ -41,4 +49,4 @@ void rshift_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(lshift_stub, &lshift_kernel_cuda);
 REGISTER_DISPATCH(rshift_stub, &rshift_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Blas.cpp b/aten/src/ATen/native/cuda/Blas.cpp
index e5163c339d..20843892ce 100644
--- a/aten/src/ATen/native/cuda/Blas.cpp
+++ b/aten/src/ATen/native/cuda/Blas.cpp
@@ -32,7 +32,7 @@
 #include <ATen/ops/vdot_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -795,7 +795,7 @@ _scaled_mm_out_cuda(const Tensor& mat1, const Tensor& mat2,
   at::native::resize_output(out, {mat1_sizes[0], mat2_sizes[1]});
   at::native::resize_output(amax, {});
 
-#if !defined(USE_ROCM) && !defined(_MSC_VER)
+#if !defined(USE_ROCM) && !defined(_MSC_VER) && !defined(__APPLE__) && !defined(__MACH__)
   cublasCommonArgs args(mat1, mat2, out);
   const auto out_dtype_ = args.result->scalar_type();
   TORCH_CHECK(args.transa == 't' && args.transb == 'n', "Only multiplication of row-major and column-major matrices is supported by cuBLASLt");
@@ -842,4 +842,4 @@ _scaled_mm_cuda(const Tensor& mat_a, const Tensor& mat_b,
   return _scaled_mm_out_cuda(mat_a, mat_b, bias, out_dtype, scale_a, scale_b, scale_result, use_fast_accum, out, amax);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Bucketization.cu b/aten/src/ATen/native/cuda/Bucketization.cu
index c85c059f91..b632c61b6b 100644
--- a/aten/src/ATen/native/cuda/Bucketization.cu
+++ b/aten/src/ATen/native/cuda/Bucketization.cu
@@ -15,7 +15,7 @@
 #include <ATen/ops/searchsorted_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Implement a numpy like searchsorted and a TF like bucketize function running on cuda
 // See details in ATen/nativate/Bucketization.cpp
@@ -230,4 +230,4 @@ Tensor bucketize_cuda(const Scalar& self, const Tensor& boundaries, bool out_int
   return bucketize_cuda(searchsorted_scalar_tensor(self, boundaries.device()), boundaries, out_int32, right);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CUDAScalar.cu b/aten/src/ATen/native/cuda/CUDAScalar.cu
index 9487d4c5f8..8f0f7f51dd 100644
--- a/aten/src/ATen/native/cuda/CUDAScalar.cu
+++ b/aten/src/ATen/native/cuda/CUDAScalar.cu
@@ -10,7 +10,7 @@
 
 #include <ATen/cuda/CUDAContext.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 Scalar _local_scalar_dense_cuda(const Tensor& self) {
   Scalar r;
@@ -24,4 +24,4 @@ Scalar _local_scalar_dense_cuda(const Tensor& self) {
   return r;
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/Col2Im.cu b/aten/src/ATen/native/cuda/Col2Im.cu
index bb6d4748de..f961c09849 100644
--- a/aten/src/ATen/native/cuda/Col2Im.cu
+++ b/aten/src/ATen/native/cuda/Col2Im.cu
@@ -20,7 +20,7 @@
 #include <ATen/ops/im2col_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void col2im_out_cuda_template(
@@ -168,4 +168,4 @@ Tensor col2im_cuda(
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CompareEQKernel.cu b/aten/src/ATen/native/cuda/CompareEQKernel.cu
index 5491b663cb..60fa9f999f 100644
--- a/aten/src/ATen/native/cuda/CompareEQKernel.cu
+++ b/aten/src/ATen/native/cuda/CompareEQKernel.cu
@@ -9,7 +9,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 enum class EqOpType {EQ, NE};
 
@@ -47,4 +47,4 @@ void ne_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(eq_stub, &eq_kernel_cuda);
 REGISTER_DISPATCH(ne_stub, &ne_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CompareKernels.cu b/aten/src/ATen/native/cuda/CompareKernels.cu
index 8a1a97759f..087f59950f 100644
--- a/aten/src/ATen/native/cuda/CompareKernels.cu
+++ b/aten/src/ATen/native/cuda/CompareKernels.cu
@@ -9,7 +9,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native { namespace {
+namespace at{ namespace native { namespace {
 
 enum class OpType {GE, GT, LE, LT};
 
@@ -100,4 +100,4 @@ REGISTER_DISPATCH(gt_stub, &gt_kernel_cuda);
 REGISTER_DISPATCH(le_stub, &le_kernel_cuda);
 REGISTER_DISPATCH(lt_stub, &lt_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ComplexKernel.cu b/aten/src/ATen/native/cuda/ComplexKernel.cu
index 2bf26722fb..4040577533 100644
--- a/aten/src/ATen/native/cuda/ComplexKernel.cu
+++ b/aten/src/ATen/native/cuda/ComplexKernel.cu
@@ -7,7 +7,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void complex_kernel_cuda(TensorIterator& iter) {
@@ -33,4 +33,4 @@ void polar_kernel_cuda(TensorIterator& iter) {
 REGISTER_DISPATCH(complex_stub, &complex_kernel_cuda);
 REGISTER_DISPATCH(polar_stub, &polar_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ConvolutionMM2d.cu b/aten/src/ATen/native/cuda/ConvolutionMM2d.cu
index 301eb65cc1..406a0f7eab 100644
--- a/aten/src/ATen/native/cuda/ConvolutionMM2d.cu
+++ b/aten/src/ATen/native/cuda/ConvolutionMM2d.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/sum.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void slow_conv2d_shape_check(
@@ -499,4 +499,4 @@ std::tuple<Tensor, Tensor, Tensor> slow_conv2d_backward_cuda(
       grad_bias);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Copy.cu b/aten/src/ATen/native/cuda/Copy.cu
index bcfb8bef26..6aaaa44086 100644
--- a/aten/src/ATen/native/cuda/Copy.cu
+++ b/aten/src/ATen/native/cuda/Copy.cu
@@ -24,7 +24,7 @@
 #include <cuda_fp8.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 void neg_kernel_cuda(TensorIteratorBase &iter);
 void conj_kernel_cuda(TensorIteratorBase &iter);
@@ -353,4 +353,4 @@ static void copy_kernel_cuda(TensorIterator& iter, bool non_blocking) {
 
 REGISTER_DISPATCH(copy_stub, &copy_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CopysignKernel.cu b/aten/src/ATen/native/cuda/CopysignKernel.cu
index 38724d7e29..47881789a3 100644
--- a/aten/src/ATen/native/cuda/CopysignKernel.cu
+++ b/aten/src/ATen/native/cuda/CopysignKernel.cu
@@ -18,7 +18,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void copysign_kernel_cuda(TensorIteratorBase& iter) {
   AT_DISPATCH_FLOATING_TYPES_AND2(kBFloat16, kHalf, iter.common_dtype(), "copysign_cuda", [&]() {
@@ -30,4 +30,4 @@ void copysign_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(copysign_stub, &copysign_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CrossKernel.cu b/aten/src/ATen/native/cuda/CrossKernel.cu
index 956ce2446d..dad9989099 100644
--- a/aten/src/ATen/native/cuda/CrossKernel.cu
+++ b/aten/src/ATen/native/cuda/CrossKernel.cu
@@ -5,7 +5,7 @@
 #include <ATen/Dispatch.h>
 #include <ATen/core/Tensor.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T, typename OffsetCalc, typename StrideType>
 __global__ void cross_kernel(
@@ -89,4 +89,4 @@ void cross_impl(const Tensor& result, const Tensor& x1, const Tensor& x2, int64_
 
 REGISTER_DISPATCH(cross_stub, &cross_impl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CumminmaxKernel.cu b/aten/src/ATen/native/cuda/CumminmaxKernel.cu
index d72f13f559..087bc2fbc1 100644
--- a/aten/src/ATen/native/cuda/CumminmaxKernel.cu
+++ b/aten/src/ATen/native/cuda/CumminmaxKernel.cu
@@ -8,7 +8,7 @@
 #include <limits>
 #include <functional>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void launch_cummax_cuda_kernel(const TensorBase& self, const TensorBase& values, const TensorBase& indices, int64_t dim) {
   AT_DISPATCH_ALL_TYPES_AND3(at::ScalarType::Bool, at::ScalarType::Half, at::ScalarType::BFloat16,
@@ -26,4 +26,4 @@ void launch_cummin_cuda_kernel(const TensorBase& self, const TensorBase& values,
   });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CumprodKernel.cu b/aten/src/ATen/native/cuda/CumprodKernel.cu
index f44ec072b1..b9a392c586 100644
--- a/aten/src/ATen/native/cuda/CumprodKernel.cu
+++ b/aten/src/ATen/native/cuda/CumprodKernel.cu
@@ -5,7 +5,7 @@
 #include <ATen/native/cuda/ScanKernels.h>
 #include <ATen/native/cuda/ScanUtils.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void launch_cumprod_cuda_kernel(const TensorBase& result, const TensorBase& self, int64_t dim) {
   AT_DISPATCH_ALL_TYPES_AND_COMPLEX_AND2(
@@ -20,4 +20,4 @@ void launch_cumprod_cuda_kernel(const TensorBase& result, const TensorBase& self
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/CumsumKernel.cu b/aten/src/ATen/native/cuda/CumsumKernel.cu
index 07db9cd236..dd79604084 100644
--- a/aten/src/ATen/native/cuda/CumsumKernel.cu
+++ b/aten/src/ATen/native/cuda/CumsumKernel.cu
@@ -5,7 +5,7 @@
 #include <ATen/native/cuda/ScanKernels.h>
 #include <ATen/native/cuda/ScanUtils.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void launch_cumsum_cuda_kernel(const TensorBase& result, const TensorBase& self, int64_t dim) {
   AT_DISPATCH_ALL_TYPES_AND_COMPLEX_AND2(
@@ -22,4 +22,4 @@ void launch_cumsum_cuda_kernel(const TensorBase& result, const TensorBase& self,
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DepthwiseConv2d.cu b/aten/src/ATen/native/cuda/DepthwiseConv2d.cu
index 7e2a0796cc..5744a33dce 100644
--- a/aten/src/ATen/native/cuda/DepthwiseConv2d.cu
+++ b/aten/src/ATen/native/cuda/DepthwiseConv2d.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/_conv_depthwise2d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 using at::cuda::detail::CUDA_NUM_THREADS;
 using at::cuda::detail::GET_BLOCKS;
@@ -632,4 +632,4 @@ std::tuple<Tensor, Tensor> conv_depthwise2d_backward_cuda(
 
 REGISTER_CUDA_DISPATCH(conv_depthwise2d_backward_stub, &conv_depthwise2d_backward_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DepthwiseConv3d.cu b/aten/src/ATen/native/cuda/DepthwiseConv3d.cu
index 631c267790..eb12504df3 100644
--- a/aten/src/ATen/native/cuda/DepthwiseConv3d.cu
+++ b/aten/src/ATen/native/cuda/DepthwiseConv3d.cu
@@ -19,7 +19,7 @@
 #include <tuple>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t, typename accscalar_t,
@@ -703,4 +703,4 @@ REGISTER_CUDA_DISPATCH(conv_depthwise3d_backward_stub, &conv_depthwise3d_backwar
 #undef NODEF_OR_EQUAL_3
 #undef NODEF_OR_EQUAL
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DilatedMaxPool2d.cu b/aten/src/ATen/native/cuda/DilatedMaxPool2d.cu
index ab73f68955..ad53b11a64 100644
--- a/aten/src/ATen/native/cuda/DilatedMaxPool2d.cu
+++ b/aten/src/ATen/native/cuda/DilatedMaxPool2d.cu
@@ -21,7 +21,7 @@
 #include <ATen/ops/max_pool2d_with_indices_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 __device__ inline int min(int a, int b) {
@@ -564,4 +564,4 @@ const Tensor& gradInput) {
   );
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/DilatedMaxPool3d.cu b/aten/src/ATen/native/cuda/DilatedMaxPool3d.cu
index 139b3e9802..ccdebc0ce3 100644
--- a/aten/src/ATen/native/cuda/DilatedMaxPool3d.cu
+++ b/aten/src/ATen/native/cuda/DilatedMaxPool3d.cu
@@ -23,7 +23,7 @@
 #include <ATen/ops/max_pool3d_with_indices_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 __device__ inline int min(int a, int b) {
@@ -649,4 +649,4 @@ Tensor max_pool3d_with_indices_backward_cuda(
   return gradInput;
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/DistanceKernel.cu b/aten/src/ATen/native/cuda/DistanceKernel.cu
index 527e63f932..4d8919e448 100644
--- a/aten/src/ATen/native/cuda/DistanceKernel.cu
+++ b/aten/src/ATen/native/cuda/DistanceKernel.cu
@@ -19,7 +19,7 @@
 
 #include <c10/macros/Macros.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -362,4 +362,4 @@ REGISTER_DISPATCH(pdist_backward_stub, &pdist_backward_kernel_impl);
 REGISTER_DISPATCH(cdist_stub, &cdist_kernel_impl);
 REGISTER_DISPATCH(cdist_backward_stub, &cdist_backward_kernel_impl);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/DistributionBernoulli.cu b/aten/src/ATen/native/cuda/DistributionBernoulli.cu
index 89a518267d..b3ec045cc6 100644
--- a/aten/src/ATen/native/cuda/DistributionBernoulli.cu
+++ b/aten/src/ATen/native/cuda/DistributionBernoulli.cu
@@ -21,7 +21,7 @@
 #include <utility>
 #include <type_traits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void bernoulli_tensor_kernel(const TensorBase &self, const TensorBase &p_, c10::optional<Generator> gen_) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen_, cuda::detail::getDefaultCUDAGenerator());
@@ -37,4 +37,4 @@ void bernoulli_scalar_kernel(const TensorBase &self, double p, c10::optional<Gen
 REGISTER_DISPATCH(bernoulli_tensor_stub, &bernoulli_tensor_kernel);
 REGISTER_DISPATCH(bernoulli_scalar_stub, &bernoulli_scalar_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionCauchyKernel.cu b/aten/src/ATen/native/cuda/DistributionCauchyKernel.cu
index a66d3cf328..d80e80fe99 100644
--- a/aten/src/ATen/native/cuda/DistributionCauchyKernel.cu
+++ b/aten/src/ATen/native/cuda/DistributionCauchyKernel.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void cauchy_kernel(TensorIteratorBase& iter, double median, double sigma, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void cauchy_kernel(TensorIteratorBase& iter, double median, double sigma, c10::o
 
 REGISTER_DISPATCH(cauchy_stub, &cauchy_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionExponentialKernel.cu b/aten/src/ATen/native/cuda/DistributionExponentialKernel.cu
index 76cb94f6fd..661bfa5b65 100644
--- a/aten/src/ATen/native/cuda/DistributionExponentialKernel.cu
+++ b/aten/src/ATen/native/cuda/DistributionExponentialKernel.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void exponential_kernel(TensorIteratorBase& iter, double lambda, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void exponential_kernel(TensorIteratorBase& iter, double lambda, c10::optional<G
 
 REGISTER_DISPATCH(exponential_stub, &exponential_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionGeometricKernel.cu b/aten/src/ATen/native/cuda/DistributionGeometricKernel.cu
index 0fe49d7bbd..2cb79cffe4 100644
--- a/aten/src/ATen/native/cuda/DistributionGeometricKernel.cu
+++ b/aten/src/ATen/native/cuda/DistributionGeometricKernel.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void geometric_kernel(TensorIteratorBase& iter, double p_, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void geometric_kernel(TensorIteratorBase& iter, double p_, c10::optional<Generat
 
 REGISTER_DISPATCH(geometric_stub, &geometric_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionLogNormalKernel.cu b/aten/src/ATen/native/cuda/DistributionLogNormalKernel.cu
index f394d4fea3..1f74d3c8b8 100644
--- a/aten/src/ATen/native/cuda/DistributionLogNormalKernel.cu
+++ b/aten/src/ATen/native/cuda/DistributionLogNormalKernel.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void log_normal_kernel(TensorIteratorBase& iter, double mean, double std, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void log_normal_kernel(TensorIteratorBase& iter, double mean, double std, c10::o
 
 REGISTER_DISPATCH(log_normal_stub, &log_normal_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionNormal.cu b/aten/src/ATen/native/cuda/DistributionNormal.cu
index a17c3e3da0..eb1cc2a106 100644
--- a/aten/src/ATen/native/cuda/DistributionNormal.cu
+++ b/aten/src/ATen/native/cuda/DistributionNormal.cu
@@ -3,7 +3,7 @@
 #include <ATen/cuda/CUDAGeneratorImpl.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void normal_kernel(const TensorBase &self, double mean, double std, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void normal_kernel(const TensorBase &self, double mean, double std, c10::optiona
 
 REGISTER_DISPATCH(normal_stub, &normal_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionRandomKernel.cu b/aten/src/ATen/native/cuda/DistributionRandomKernel.cu
index 034a19c512..16434a3d7c 100644
--- a/aten/src/ATen/native/cuda/DistributionRandomKernel.cu
+++ b/aten/src/ATen/native/cuda/DistributionRandomKernel.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void random_from_to_kernel(TensorIteratorBase& iter, uint64_t range, int64_t base, c10::optional<Generator> gen_) {
   auto gen = get_generator_or_default<CUDAGeneratorImpl>(gen_, cuda::detail::getDefaultCUDAGenerator());
@@ -24,4 +24,4 @@ REGISTER_DISPATCH(random_from_to_stub, &random_from_to_kernel);
 REGISTER_DISPATCH(random_stub, &random_kernel);
 REGISTER_DISPATCH(random_full_64_bits_range_stub, &random_full_64_bits_range_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/DistributionUniform.cu b/aten/src/ATen/native/cuda/DistributionUniform.cu
index 2ebdfa4464..68aaca72d2 100644
--- a/aten/src/ATen/native/cuda/DistributionUniform.cu
+++ b/aten/src/ATen/native/cuda/DistributionUniform.cu
@@ -3,7 +3,7 @@
 #include <ATen/native/UnaryOps.h>
 #include <ATen/native/cuda/DistributionTemplates.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void uniform_kernel(TensorIteratorBase& iter, double from, double to, c10::optional<Generator> gen) {
   auto generator = get_generator_or_default<CUDAGeneratorImpl>(gen, cuda::detail::getDefaultCUDAGenerator());
@@ -12,4 +12,4 @@ void uniform_kernel(TensorIteratorBase& iter, double from, double to, c10::optio
 
 REGISTER_DISPATCH(uniform_stub, &uniform_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Distributions.cpp b/aten/src/ATen/native/cuda/Distributions.cpp
index c0d5abb49b..d34c51474d 100644
--- a/aten/src/ATen/native/cuda/Distributions.cpp
+++ b/aten/src/ATen/native/cuda/Distributions.cpp
@@ -16,7 +16,7 @@
 #include <ATen/ops/poisson_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor _s_poisson_cuda(const Tensor& lambda, c10::optional<Generator> gen_) {
   auto gen = get_generator_or_default<CUDAGeneratorImpl>(gen_, cuda::detail::getDefaultCUDAGenerator());
@@ -81,4 +81,4 @@ Tensor _dirichlet_grad_cuda(const Tensor& x, const Tensor& alpha, const Tensor&
   return ret;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Distributions.cu b/aten/src/ATen/native/cuda/Distributions.cu
index 1aac9fe8ba..89d8d01d2c 100644
--- a/aten/src/ATen/native/cuda/Distributions.cu
+++ b/aten/src/ATen/native/cuda/Distributions.cu
@@ -128,7 +128,7 @@ void gamma_cuda_kernel(
 
 } // namespace
 
-namespace at::native {
+namespace at{ namespace native {
 
 void launch_dirichlet_kernel(at::TensorIteratorBase &iter) {
   AT_DISPATCH_FLOATING_TYPES_AND2(at::ScalarType::Half, at::ScalarType::BFloat16,
@@ -205,4 +205,4 @@ void launch_dirichlet_grad_kernel(TensorIteratorBase &iter) {
   });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Dropout.cu b/aten/src/ATen/native/cuda/Dropout.cu
index 67ea3e4f83..7ba506a6b2 100644
--- a/aten/src/ATen/native/cuda/Dropout.cu
+++ b/aten/src/ATen/native/cuda/Dropout.cu
@@ -25,7 +25,7 @@
 #include <ATen/ops/zeros_like.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -413,4 +413,4 @@ Tensor masked_scale_cuda(const Tensor& self, const Tensor& mask, double scale){
   return dropout_backward_cuda<uint8_t>(self, mask, scale);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Embedding.cu b/aten/src/ATen/native/cuda/Embedding.cu
index 92eb4bbbb4..7d6bb56f37 100644
--- a/aten/src/ATen/native/cuda/Embedding.cu
+++ b/aten/src/ATen/native/cuda/Embedding.cu
@@ -31,7 +31,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -392,4 +392,4 @@ Tensor & embedding_renorm_cuda_(Tensor & self, const Tensor & indices,
 }
 
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/EmbeddingBackwardKernel.cu b/aten/src/ATen/native/cuda/EmbeddingBackwardKernel.cu
index e2caf590f9..7a151ff4f1 100644
--- a/aten/src/ATen/native/cuda/EmbeddingBackwardKernel.cu
+++ b/aten/src/ATen/native/cuda/EmbeddingBackwardKernel.cu
@@ -21,7 +21,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -362,4 +362,4 @@ Tensor embedding_backward_cuda_kernel(
   return grad_weight;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/EmbeddingBag.cu b/aten/src/ATen/native/cuda/EmbeddingBag.cu
index 262d3fe74f..ebf740dcfa 100644
--- a/aten/src/ATen/native/cuda/EmbeddingBag.cu
+++ b/aten/src/ATen/native/cuda/EmbeddingBag.cu
@@ -34,7 +34,7 @@
 #include <thrust/iterator/reverse_iterator.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if !CUB_SUPPORTS_SCAN_BY_KEY()
 template<typename index_t>
@@ -565,4 +565,4 @@ Tensor _embedding_bag_per_sample_weights_backward_cuda(
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Equal.cpp b/aten/src/ATen/native/cuda/Equal.cpp
index 8950bc4fb7..5403fabd59 100644
--- a/aten/src/ATen/native/cuda/Equal.cpp
+++ b/aten/src/ATen/native/cuda/Equal.cpp
@@ -10,7 +10,7 @@
 #include <ATen/ops/equal_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 bool cuda_equal(const Tensor& self, const Tensor &src) {
   if (!at::namedinference::are_names_equal(
@@ -45,4 +45,4 @@ bool cuda_equal(const Tensor& self, const Tensor &src) {
   return at::cuda::eq(self, src).all().item().to<bool>();
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/FillKernel.cu b/aten/src/ATen/native/cuda/FillKernel.cu
index dd7a7f96c2..4aa174edc3 100644
--- a/aten/src/ATen/native/cuda/FillKernel.cu
+++ b/aten/src/ATen/native/cuda/FillKernel.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/Fill.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template<typename scalar_t>
 struct FillFunctor {
@@ -26,4 +26,4 @@ void fill_kernel_cuda(TensorIterator& iter, const Scalar& value) {
 
 REGISTER_DISPATCH(fill_stub, &fill_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/FlattenIndicesKernel.cu b/aten/src/ATen/native/cuda/FlattenIndicesKernel.cu
index a127e0a52d..cc7c6fa878 100644
--- a/aten/src/ATen/native/cuda/FlattenIndicesKernel.cu
+++ b/aten/src/ATen/native/cuda/FlattenIndicesKernel.cu
@@ -6,7 +6,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/AccumulateType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -25,4 +25,4 @@ Tensor flatten_indices_cuda_kernel(const Tensor& indices, IntArrayRef size) {
 
 REGISTER_CUDA_DISPATCH(flatten_indices_stub, &flatten_indices_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachBinaryOpList.cu b/aten/src/ATen/native/cuda/ForeachBinaryOpList.cu
index 366049a540..b991ba8635 100644
--- a/aten/src/ATen/native/cuda/ForeachBinaryOpList.cu
+++ b/aten/src/ATen/native/cuda/ForeachBinaryOpList.cu
@@ -20,7 +20,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T, template <class> class Op>
 std::vector<Tensor> foreach_tensor_list_op(
@@ -290,4 +290,4 @@ void foreach_tensor_copy_list_kernel_cuda_(
   increment_version(self);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachBinaryOpScalar.cu b/aten/src/ATen/native/cuda/ForeachBinaryOpScalar.cu
index 35865afa67..286ae2a28e 100644
--- a/aten/src/ATen/native/cuda/ForeachBinaryOpScalar.cu
+++ b/aten/src/ATen/native/cuda/ForeachBinaryOpScalar.cu
@@ -19,7 +19,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T, template <class> class Op>
 std::vector<Tensor> foreach_binary_op(
@@ -242,4 +242,4 @@ std::vector<Tensor> foreach_tensor_sub_scalar_kernel_cuda(
 FOREACH_BINARY_OP_SCALAR(all_types_half_bfloat16, clamp_max, minimum, false);
 FOREACH_BINARY_OP_SCALAR(all_types_half_bfloat16, clamp_min, maximum, false);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachBinaryOpScalarList.cu b/aten/src/ATen/native/cuda/ForeachBinaryOpScalarList.cu
index b650ec07aa..e268b7e38c 100644
--- a/aten/src/ATen/native/cuda/ForeachBinaryOpScalarList.cu
+++ b/aten/src/ATen/native/cuda/ForeachBinaryOpScalarList.cu
@@ -19,7 +19,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T, template <class> class Op>
 std::vector<Tensor> foreach_binary_op(
@@ -246,4 +246,4 @@ FOREACH_BINARY_OP_SCALARLIST(
     maximum,
     false);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachBinaryOpScalarTensor.cu b/aten/src/ATen/native/cuda/ForeachBinaryOpScalarTensor.cu
index ad5eeee5eb..2f9be3752e 100644
--- a/aten/src/ATen/native/cuda/ForeachBinaryOpScalarTensor.cu
+++ b/aten/src/ATen/native/cuda/ForeachBinaryOpScalarTensor.cu
@@ -15,7 +15,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T, template <class> class Op>
 std::vector<Tensor> foreach_binary_op(
@@ -203,4 +203,4 @@ FOREACH_BINARY_OP_SCALAR_TENSOR(
     std::divides,
     /* div_op */ true);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachFunctors.cuh b/aten/src/ATen/native/cuda/ForeachFunctors.cuh
index 55e4fd7a59..dceb919fd2 100644
--- a/aten/src/ATen/native/cuda/ForeachFunctors.cuh
+++ b/aten/src/ATen/native/cuda/ForeachFunctors.cuh
@@ -4,7 +4,7 @@
 #include <ATen/native/cuda/MultiTensorApply.cuh>
 #include <ATen/native/cuda/Pow.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -678,4 +678,4 @@ struct reverse_power_functor {
 };
 
 } // namespace
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachMinMaxFunctors.cuh b/aten/src/ATen/native/cuda/ForeachMinMaxFunctors.cuh
index 9b08911b1d..4c23b6822c 100644
--- a/aten/src/ATen/native/cuda/ForeachMinMaxFunctors.cuh
+++ b/aten/src/ATen/native/cuda/ForeachMinMaxFunctors.cuh
@@ -2,7 +2,7 @@
 
 #include <ATen/NumericUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // std:: does not have clamp functors
 template <typename T>
@@ -19,4 +19,4 @@ struct maximum {
   }
 };
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachPointwiseOp.cu b/aten/src/ATen/native/cuda/ForeachPointwiseOp.cu
index 7a3276c447..cb3d1b1845 100644
--- a/aten/src/ATen/native/cuda/ForeachPointwiseOp.cu
+++ b/aten/src/ATen/native/cuda/ForeachPointwiseOp.cu
@@ -19,7 +19,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <template <class> class Op>
 std::vector<Tensor> foreach_pointwise_op(
@@ -269,4 +269,4 @@ FOREACH_POINTWISE_OP_SCALARLIST(addcdiv, std::divides);
 FOREACH_POINTWISE_OP_TENSOR(addcdiv, std::divides);
 FOREACH_POINTWISE_OP_TENSOR(addcmul, std::multiplies);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachReduceOp.cu b/aten/src/ATen/native/cuda/ForeachReduceOp.cu
index d8af951afa..f72803e090 100644
--- a/aten/src/ATen/native/cuda/ForeachReduceOp.cu
+++ b/aten/src/ATen/native/cuda/ForeachReduceOp.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <
     typename T,
@@ -225,4 +225,4 @@ std::vector<Tensor> foreach_tensor_norm_cuda(
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachTernaryOp.cu b/aten/src/ATen/native/cuda/ForeachTernaryOp.cu
index bfb92f180a..84416e04df 100644
--- a/aten/src/ATen/native/cuda/ForeachTernaryOp.cu
+++ b/aten/src/ATen/native/cuda/ForeachTernaryOp.cu
@@ -13,7 +13,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T>
 struct LerpFunctor {
@@ -156,4 +156,4 @@ void foreach_tensor_lerp_list_cuda_(
             weight.to<opmath_t>());
       });
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ForeachUnaryOp.cu b/aten/src/ATen/native/cuda/ForeachUnaryOp.cu
index ff809d108d..b4177d6488 100644
--- a/aten/src/ATen/native/cuda/ForeachUnaryOp.cu
+++ b/aten/src/ATen/native/cuda/ForeachUnaryOp.cu
@@ -41,7 +41,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, template <class> class Op>
 std::vector<Tensor> foreach_unary_op(TensorList tensors) {
@@ -404,4 +404,4 @@ void foreach_tensor_zero_cuda_(TensorList tensors) {
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/FractionalMaxPool2d.cu b/aten/src/ATen/native/cuda/FractionalMaxPool2d.cu
index 2da8801900..457d29fc72 100644
--- a/aten/src/ATen/native/cuda/FractionalMaxPool2d.cu
+++ b/aten/src/ATen/native/cuda/FractionalMaxPool2d.cu
@@ -24,7 +24,7 @@
 #include <cfloat>
 #include <cmath>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::cuda::detail;
 
@@ -265,4 +265,4 @@ TORCH_IMPL_FUNC(fractional_max_pool2d_backward_cuda)(
   );
 }
 
-}// at::native
+}}// at::native
diff --git a/aten/src/ATen/native/cuda/FractionalMaxPool3d.cu b/aten/src/ATen/native/cuda/FractionalMaxPool3d.cu
index 84570451d6..51ea562742 100644
--- a/aten/src/ATen/native/cuda/FractionalMaxPool3d.cu
+++ b/aten/src/ATen/native/cuda/FractionalMaxPool3d.cu
@@ -28,7 +28,7 @@
 #include <cfloat>
 #include <cmath>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::cuda::detail;
 
@@ -341,4 +341,4 @@ Tensor fractional_max_pool3d_backward_cuda(
     return gradInput;
  }
 
-}// namespace at::native
+}}// namespace at::native
diff --git a/aten/src/ATen/native/cuda/FunctionOfAMatrixUtilsKernel.cu b/aten/src/ATen/native/cuda/FunctionOfAMatrixUtilsKernel.cu
index 683c9c058a..7591cb3c75 100644
--- a/aten/src/ATen/native/cuda/FunctionOfAMatrixUtilsKernel.cu
+++ b/aten/src/ATen/native/cuda/FunctionOfAMatrixUtilsKernel.cu
@@ -7,7 +7,7 @@
 #include <ATen/cuda/Atomic.cuh>
 #include <ATen/cuda/CUDAContext.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -111,4 +111,4 @@ void _compute_linear_combination_cuda_kernel(
 
 REGISTER_DISPATCH(_compute_linear_combination_stub, &_compute_linear_combination_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/FusedAdamKernel.cu b/aten/src/ATen/native/cuda/FusedAdamKernel.cu
index 33273d81f2..eab0094b14 100644
--- a/aten/src/ATen/native/cuda/FusedAdamKernel.cu
+++ b/aten/src/ATen/native/cuda/FusedAdamKernel.cu
@@ -6,7 +6,7 @@
 #include <c10/util/Exception.h>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 // note(crcrpar): To observe the CI rules, i.e. 20 minutes per file to compile, defensively split instantiations into _impl files.
 // this is only for CUDA 11.3 for which it took about 20 minutes and 28 minutes in my workstation and CI, respectively.
@@ -88,4 +88,4 @@ void _fused_adam_kernel_cuda_(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/GcdLcmKernel.cu b/aten/src/ATen/native/cuda/GcdLcmKernel.cu
index c4a8cdfaf1..3366e9b55d 100644
--- a/aten/src/ATen/native/cuda/GcdLcmKernel.cu
+++ b/aten/src/ATen/native/cuda/GcdLcmKernel.cu
@@ -11,7 +11,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 // See note [Jiterator]
 CONSTEXPR_EXCEPT_WIN_CUDA char gcd_name[] = "gcd";
@@ -55,4 +55,4 @@ void lcm_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(gcd_stub, &gcd_kernel_cuda);
 REGISTER_DISPATCH(lcm_stub, &lcm_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/GridSampler.cpp b/aten/src/ATen/native/cuda/GridSampler.cpp
index efe19edab4..423c30a1ac 100644
--- a/aten/src/ATen/native/cuda/GridSampler.cpp
+++ b/aten/src/ATen/native/cuda/GridSampler.cpp
@@ -14,7 +14,7 @@
 #include <ATen/ops/zeros_like.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor grid_sampler_2d_cuda(const Tensor& input, const Tensor& grid,
                             int64_t interpolation_mode, int64_t padding_mode,
@@ -79,4 +79,4 @@ grid_sampler_3d_backward_cuda(const Tensor& grad_output, const Tensor& input,
   return std::make_tuple(grad_input, grad_grid);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/GridSampler.cu b/aten/src/ATen/native/cuda/GridSampler.cu
index 9d87cbc327..92af7ccbca 100644
--- a/aten/src/ATen/native/cuda/GridSampler.cu
+++ b/aten/src/ATen/native/cuda/GridSampler.cu
@@ -13,7 +13,7 @@
 #include <c10/macros/Macros.h>
 #include <cmath>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::cuda::detail;
 
@@ -958,4 +958,4 @@ void launch_grid_sampler_3d_backward_kernel(
   }
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/IGammaKernel.cu b/aten/src/ATen/native/cuda/IGammaKernel.cu
index be3f7fc54a..61b515005d 100644
--- a/aten/src/ATen/native/cuda/IGammaKernel.cu
+++ b/aten/src/ATen/native/cuda/IGammaKernel.cu
@@ -531,7 +531,7 @@ struct CalcIgamma{
 
 // end of regularized lower & upper incomplete gamma
 
-namespace at::native {
+namespace at{ namespace native {
 
 void igamma_kernel_cuda(TensorIteratorBase& iter) {
   AT_DISPATCH_FLOATING_TYPES(iter.common_dtype(), "igamma_cuda", [&]() {
@@ -551,4 +551,4 @@ REGISTER_DISPATCH(igammac_stub, &igammac_kernel_cuda);
 // DO NOT ADD ANY NEW KERNELS HERE
 // CUDA compilation times grow quickly.  It's perfectly acceptable to have a file per kernel.
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Im2Col.cu b/aten/src/ATen/native/cuda/Im2Col.cu
index 312ad893c0..23bb70424f 100644
--- a/aten/src/ATen/native/cuda/Im2Col.cu
+++ b/aten/src/ATen/native/cuda/Im2Col.cu
@@ -20,7 +20,7 @@
 #include <ATen/ops/im2col_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static void im2col_out_cuda_template(
@@ -162,4 +162,4 @@ Tensor im2col_cuda(
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/IndexKernel.cpp b/aten/src/ATen/native/cuda/IndexKernel.cpp
index 68770bc64e..e1c3a29c0b 100644
--- a/aten/src/ATen/native/cuda/IndexKernel.cpp
+++ b/aten/src/ATen/native/cuda/IndexKernel.cpp
@@ -19,7 +19,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 static Tensor & masked_select_out_cuda_impl(Tensor & result, const Tensor & self, const Tensor & mask) {
   NoNamesGuard guard;
@@ -81,4 +81,4 @@ Tensor & masked_scatter__cuda(Tensor& self, const Tensor& mask, const Tensor& so
   return self;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/IndexKernel.cu b/aten/src/ATen/native/cuda/IndexKernel.cu
index 657c0c77b3..43f000814b 100644
--- a/aten/src/ATen/native/cuda/IndexKernel.cu
+++ b/aten/src/ATen/native/cuda/IndexKernel.cu
@@ -16,7 +16,7 @@
 
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static constexpr int launch_bound2 = 4;
 
@@ -249,7 +249,11 @@ void index_put_kernel_quantized_cuda(TensorIterator& iter, const IntArrayRef ind
 
     gpu_index_kernel(iter, index_size, index_stride, [inv_scale, zero_point, qmin, qmax]C10_DEVICE(char* const out_data, const char* const in_data, const int64_t offset) {
       int64_t qvalue = static_cast<int64_t>(zero_point + nearbyintf(*(float*)in_data * inv_scale));
+#if defined(__APPLE__) && defined(__MACH__)
+      qvalue = min(max(qvalue, qmin), qmax);
+#else
       qvalue = std::clamp(qvalue, qmin, qmax);
+#endif
       *(scalar_t*)(out_data + offset) = static_cast<scalar_t>(qvalue);
     });
   });
@@ -460,4 +464,4 @@ REGISTER_DISPATCH(flip_stub, &flip_kernel);
 
 REGISTER_CUDA_DISPATCH(index_put_kernel_quantized_stub, &index_put_kernel_quantized_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Indexing.cu b/aten/src/ATen/native/cuda/Indexing.cu
index 92f55fa3b9..78dabb3a7b 100644
--- a/aten/src/ATen/native/cuda/Indexing.cu
+++ b/aten/src/ATen/native/cuda/Indexing.cu
@@ -285,7 +285,7 @@ __global__ void indexing_backward_kernel_quantized(
 }
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1803,4 +1803,4 @@ Tensor index_select_sparse_cuda(const Tensor& self, int64_t dim, const Tensor& i
 }
 
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/KernelUtils.cuh b/aten/src/ATen/native/cuda/KernelUtils.cuh
index d07f54093e..5d0ded546c 100644
--- a/aten/src/ATen/native/cuda/KernelUtils.cuh
+++ b/aten/src/ATen/native/cuda/KernelUtils.cuh
@@ -1,7 +1,8 @@
 #pragma once
 #include <ATen/cuda/Atomic.cuh>
 
-#if !(defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800))))
+// #if (!(defined(USE_ROCM) || ((defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800))))) && CUDA_VERSION >= 11000
+#if CUDA_VERSION >= 11000
 #include <cuda_bf16.h>
 #endif
 
@@ -89,7 +90,8 @@ __device__ __forceinline__ void fastSpecializedAtomicAdd(
     scalar_t value) {
 #if (                      \
     (defined(USE_ROCM)) || \
-    (defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800)))
+    (defined(__CUDA_ARCH__) && (__CUDA_ARCH__ < 800))) || \
+    CUDA_VERSION < 11000
   gpuAtomicAddNoReturn(
       reinterpret_cast<at::BFloat16*>(tensor) + index,
       static_cast<at::BFloat16>(value));
diff --git a/aten/src/ATen/native/cuda/LegacyThrustHelpers.cu b/aten/src/ATen/native/cuda/LegacyThrustHelpers.cu
index d6c015ab8d..bd88c40eea 100644
--- a/aten/src/ATen/native/cuda/LegacyThrustHelpers.cu
+++ b/aten/src/ATen/native/cuda/LegacyThrustHelpers.cu
@@ -17,7 +17,7 @@
 #include <thrust/device_ptr.h>
 #include <thrust/iterator/constant_iterator.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void index_put_with_sort_kernel_thrust_helper(Tensor &linearIndex, Tensor &orig_indices, Tensor &sorted_indices, int64_t num_indices) {
   sorted_indices.copy_(linearIndex);
@@ -109,4 +109,4 @@ int64_t embedding_backward_cuda_kernel_unique_by_key<int>(const Tensor &sorted_i
 template
 int64_t embedding_backward_cuda_kernel_unique_by_key<int64_t>(const Tensor &sorted_indices, Tensor &segment_offsets);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Lerp.cu b/aten/src/ATen/native/cuda/Lerp.cu
index 01053a3bee..a7e762611e 100644
--- a/aten/src/ATen/native/cuda/Lerp.cu
+++ b/aten/src/ATen/native/cuda/Lerp.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/cuda/JitLoops.cuh>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char lerp_tensor_name[] = "lerp_tensor";
@@ -124,4 +124,4 @@ void lerp_scalar_kernel(at::TensorIteratorBase& iter, const c10::Scalar& weight)
 REGISTER_DISPATCH(lerp_kernel_tensor_weight, &lerp_tensor_kernel);
 REGISTER_DISPATCH(lerp_kernel_scalar_weight, &lerp_scalar_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/LinearAlgebra.cu b/aten/src/ATen/native/cuda/LinearAlgebra.cu
index fb59f97604..895464a939 100644
--- a/aten/src/ATen/native/cuda/LinearAlgebra.cu
+++ b/aten/src/ATen/native/cuda/LinearAlgebra.cu
@@ -9,7 +9,7 @@
 #include <ATen/native/ReduceOps.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -139,4 +139,4 @@ void unpack_pivots_cuda_kernel(TensorIterator& iter, const int64_t dim_size, con
 
 REGISTER_DISPATCH(unpack_pivots_stub, &unpack_pivots_cuda_kernel);
 REGISTER_DISPATCH(addr_stub, &addr_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/LinearAlgebraStubs.cpp b/aten/src/ATen/native/cuda/LinearAlgebraStubs.cpp
index 045bfa8d1f..10cd4f4ded 100644
--- a/aten/src/ATen/native/cuda/LinearAlgebraStubs.cpp
+++ b/aten/src/ATen/native/cuda/LinearAlgebraStubs.cpp
@@ -29,7 +29,7 @@ struct MagmaInitializer {
 }  // namespace (anonymous)
 #endif
 #endif
-namespace at::native {
+namespace at{ namespace native {
 #if defined(BUILD_LAZY_CUDA_LINALG)
 namespace {
 cuda::detail::LinalgDispatch disp = {_cholesky_solve_helper_cuda};
@@ -175,4 +175,4 @@ Tensor _cholesky_solve_helper_cuda(const Tensor& self, const Tensor& A, bool upp
 
 #endif /*defined(BUILD_LAZY_CUDA_LINALG)*/
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/LogAddExpKernel.cu b/aten/src/ATen/native/cuda/LogAddExpKernel.cu
index c167ef698d..9b444943f4 100644
--- a/aten/src/ATen/native/cuda/LogAddExpKernel.cu
+++ b/aten/src/ATen/native/cuda/LogAddExpKernel.cu
@@ -10,7 +10,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void logaddexp_kernel_cuda(TensorIteratorBase& iter) {
   AT_DISPATCH_FLOATING_TYPES_AND2(
@@ -54,4 +54,4 @@ void logaddexp2_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(logaddexp_stub, &logaddexp_kernel_cuda);
 REGISTER_DISPATCH(logaddexp2_stub, &logaddexp2_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/LogcumsumexpKernel.cu b/aten/src/ATen/native/cuda/LogcumsumexpKernel.cu
index 18430d5e69..350629ddf8 100644
--- a/aten/src/ATen/native/cuda/LogcumsumexpKernel.cu
+++ b/aten/src/ATen/native/cuda/LogcumsumexpKernel.cu
@@ -9,7 +9,7 @@
 #include <cmath>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // custom min and max to be used in logcumsumexp for complex arguments
 template <typename scalar_t, bool min>
@@ -121,4 +121,4 @@ void launch_logcumsumexp_cuda_kernel(const TensorBase& result, const TensorBase&
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Loops.cuh b/aten/src/ATen/native/cuda/Loops.cuh
index fe38b1e17f..219ed07402 100644
--- a/aten/src/ATen/native/cuda/Loops.cuh
+++ b/aten/src/ATen/native/cuda/Loops.cuh
@@ -80,7 +80,7 @@ __device__ inline void elementwise_kernel_helper(func_t f, policy_t policy) {
   #include <ATen/native/cuda/ROCmLoops.cuh>
 #endif
 
-namespace at:: native {
+namespace at{ namespace native {
 
 template <typename func_t>
 void gpu_kernel_nocast(TensorIteratorBase& iter, const func_t& f) {
@@ -333,4 +333,4 @@ void gpu_kernel_multiple_outputs(TensorIteratorBase& iter, const func_t& f) {
   gpu_kernel_multiple_outputs_impl(iter, f);
 }
 
-} //namespace at::native
+}} //namespace at::native
diff --git a/aten/src/ATen/native/cuda/Loss.cu b/aten/src/ATen/native/cuda/Loss.cu
index 3f76f0931b..e7cdc7e346 100644
--- a/aten/src/ATen/native/cuda/Loss.cu
+++ b/aten/src/ATen/native/cuda/Loss.cu
@@ -60,7 +60,7 @@ void binary_cross_entropy_backward_out_kernel(Tensor& grad_input, const Tensor&
 
 } // namespace
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor binary_cross_entropy_cuda(const Tensor& input, const Tensor& target, const c10::optional<Tensor>& weight_opt, int64_t reduction) {
   // See [Note: hacky wrapper removal for optional tensor]
@@ -623,4 +623,4 @@ TORCH_IMPL_FUNC(nll_loss_backward_out_cuda)
       reduction,
       ignore_index);
 }
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/LossCTC.cu b/aten/src/ATen/native/cuda/LossCTC.cu
index 5fb86d16e9..9460734e9f 100644
--- a/aten/src/ATen/native/cuda/LossCTC.cu
+++ b/aten/src/ATen/native/cuda/LossCTC.cu
@@ -36,7 +36,7 @@
 #include <type_traits>
 #include <numeric>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -780,4 +780,4 @@ Tensor ctc_loss_backward_gpu(const Tensor& grad, const Tensor& log_probs, const
     });
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/MaxMinElementwiseKernel.cu b/aten/src/ATen/native/cuda/MaxMinElementwiseKernel.cu
index 51c82e9521..8e330660a1 100644
--- a/aten/src/ATen/native/cuda/MaxMinElementwiseKernel.cu
+++ b/aten/src/ATen/native/cuda/MaxMinElementwiseKernel.cu
@@ -9,7 +9,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void maximum_kernel_cuda(TensorIteratorBase& iter) {
   if (iter.dtype() == ScalarType::Bool) {
@@ -95,4 +95,4 @@ REGISTER_DISPATCH(minimum_stub, &minimum_kernel_cuda);
 REGISTER_DISPATCH(fmax_stub, &fmax_kernel_cuda);
 REGISTER_DISPATCH(fmin_stub, &fmin_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/MaxUnpooling.cu b/aten/src/ATen/native/cuda/MaxUnpooling.cu
index 340162c649..8f382a4646 100644
--- a/aten/src/ATen/native/cuda/MaxUnpooling.cu
+++ b/aten/src/ATen/native/cuda/MaxUnpooling.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/empty_like.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::cuda::detail;
 
@@ -609,4 +609,4 @@ at::Tensor max_unpooling3d_backward_cuda(
   return grad_input;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/MultiLabelMarginCriterion.cu b/aten/src/ATen/native/cuda/MultiLabelMarginCriterion.cu
index 28ed4dcc08..a0cd0be255 100644
--- a/aten/src/ATen/native/cuda/MultiLabelMarginCriterion.cu
+++ b/aten/src/ATen/native/cuda/MultiLabelMarginCriterion.cu
@@ -18,7 +18,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 const int MULTILABELMARGIN_THREADS = 128;
@@ -437,4 +437,4 @@ Tensor multilabel_margin_loss_backward_cuda(
   return grad_input;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/MultiMarginLoss.cu b/aten/src/ATen/native/cuda/MultiMarginLoss.cu
index 989a3e116a..733cea0dca 100644
--- a/aten/src/ATen/native/cuda/MultiMarginLoss.cu
+++ b/aten/src/ATen/native/cuda/MultiMarginLoss.cu
@@ -16,7 +16,7 @@
 #include <ATen/ops/multi_margin_loss_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 constexpr int MULTIMARGIN_THREADS = 128;
 
@@ -411,4 +411,4 @@ Tensor multi_margin_loss_cuda_backward(
   return grad_input;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/MultiTensorApply.cuh b/aten/src/ATen/native/cuda/MultiTensorApply.cuh
index 17f14444ab..ecf0245263 100644
--- a/aten/src/ATen/native/cuda/MultiTensorApply.cuh
+++ b/aten/src/ATen/native/cuda/MultiTensorApply.cuh
@@ -6,7 +6,7 @@
 #include <ATen/native/cuda/MemoryAccess.cuh>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -376,4 +376,4 @@ void multi_tensor_apply_for_fused_optimizer(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/MultinomialKernel.cu b/aten/src/ATen/native/cuda/MultinomialKernel.cu
index bf60739fdc..28e7cfb0d9 100644
--- a/aten/src/ATen/native/cuda/MultinomialKernel.cu
+++ b/aten/src/ATen/native/cuda/MultinomialKernel.cu
@@ -27,7 +27,17 @@
 #include <curand_philox4x32_x.h>
 #include <type_traits>
 
-namespace at::native {
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+namespace std {
+  template< class T >
+    inline constexpr bool is_floating_point_v = is_floating_point<T>::value;
+  template< class From, class To >
+    inline constexpr bool is_convertible_v = is_convertible<From, To>::value;
+} // namespace std
+#endif
+
+namespace at{ namespace native {
 
 namespace {
 
@@ -460,4 +470,4 @@ void multinomial_with_replacement_kernel_impl(
 REGISTER_DISPATCH(
     multinomial_with_replacement_stub,
     &multinomial_with_replacement_kernel_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/NLLLoss2d.cu b/aten/src/ATen/native/cuda/NLLLoss2d.cu
index 53d4238806..0c2650d975 100644
--- a/aten/src/ATen/native/cuda/NLLLoss2d.cu
+++ b/aten/src/ATen/native/cuda/NLLLoss2d.cu
@@ -23,7 +23,7 @@
 #include <ATen/ops/nll_loss2d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -530,4 +530,4 @@ Tensor nll_loss2d_backward_cuda(
   return grad_input;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/NaiveConvolutionTranspose2d.cu b/aten/src/ATen/native/cuda/NaiveConvolutionTranspose2d.cu
index c6c115dc64..bbd5bfe0db 100644
--- a/aten/src/ATen/native/cuda/NaiveConvolutionTranspose2d.cu
+++ b/aten/src/ATen/native/cuda/NaiveConvolutionTranspose2d.cu
@@ -23,7 +23,7 @@
 #include <ATen/ops/slow_conv_transpose2d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static inline void slow_conv_transpose2d_shape_check(
@@ -830,4 +830,4 @@ std::tuple<Tensor, Tensor, Tensor> slow_conv_transpose2d_backward_cuda(
 
 REGISTER_CUDA_DISPATCH(slow_conv_transpose2d_backward_stub, &slow_conv_transpose2d_backward_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/NaiveConvolutionTranspose3d.cu b/aten/src/ATen/native/cuda/NaiveConvolutionTranspose3d.cu
index 1074769392..f6ba39e909 100644
--- a/aten/src/ATen/native/cuda/NaiveConvolutionTranspose3d.cu
+++ b/aten/src/ATen/native/cuda/NaiveConvolutionTranspose3d.cu
@@ -22,7 +22,7 @@
 #include <ATen/ops/slow_conv_transpose3d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static inline void slow_conv_transpose3d_shape_check(
@@ -1013,4 +1013,4 @@ std::tuple<Tensor, Tensor, Tensor> slow_conv_transpose3d_backward_cuda(
 
 REGISTER_CUDA_DISPATCH(slow_conv_transpose3d_backward_stub, &slow_conv_transpose3d_backward_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/NaiveDilatedConvolution.cu b/aten/src/ATen/native/cuda/NaiveDilatedConvolution.cu
index e62e959fdf..487be42388 100644
--- a/aten/src/ATen/native/cuda/NaiveDilatedConvolution.cu
+++ b/aten/src/ATen/native/cuda/NaiveDilatedConvolution.cu
@@ -22,7 +22,7 @@
 
 #include <tuple>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -611,4 +611,4 @@ std::tuple<Tensor, Tensor, Tensor> slow_conv_dilated3d_backward_cuda(
 REGISTER_CUDA_DISPATCH(slow_conv_dilated2d_backward_stub, &slow_conv_dilated2d_backward_cuda);
 REGISTER_CUDA_DISPATCH(slow_conv_dilated3d_backward_stub, &slow_conv_dilated3d_backward_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Nonzero.cu b/aten/src/ATen/native/cuda/Nonzero.cu
index 5d62f7711d..5bb78656ab 100644
--- a/aten/src/ATen/native/cuda/Nonzero.cu
+++ b/aten/src/ATen/native/cuda/Nonzero.cu
@@ -16,7 +16,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace{
 template<typename T>
@@ -127,4 +127,4 @@ Tensor nonzero_cuda(const Tensor& self){
   Tensor out = at::detail::empty_cuda({0}, self.options().dtype(kLong));
   return at::native::nonzero_out_cuda(self, out);
 }
-} //namespace at::native
+}} //namespace at::native
diff --git a/aten/src/ATen/native/cuda/Normalization.cu b/aten/src/ATen/native/cuda/Normalization.cu
index f2104ee9d0..1280dcfaf5 100644
--- a/aten/src/ATen/native/cuda/Normalization.cu
+++ b/aten/src/ATen/native/cuda/Normalization.cu
@@ -26,7 +26,7 @@
 #include <ATen/ops/scalar_tensor.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -736,4 +736,4 @@ std::tuple<Tensor, Tensor> batch_norm_update_stats_cuda(
   return std::tuple<Tensor, Tensor>(save_mean, save_var);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/PointwiseOpsKernel.cu b/aten/src/ATen/native/cuda/PointwiseOpsKernel.cu
index 53b6712522..7160fe7437 100644
--- a/aten/src/ATen/native/cuda/PointwiseOpsKernel.cu
+++ b/aten/src/ATen/native/cuda/PointwiseOpsKernel.cu
@@ -9,7 +9,7 @@
 #include <ATen/native/PointwiseOps.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char addcmul_name[] = "addcmul";
 void addcmul_cuda_kernel(TensorIteratorBase& iter, const Scalar& value) {
@@ -148,4 +148,4 @@ REGISTER_DISPATCH(addcmul_stub, &addcmul_cuda_kernel);
 REGISTER_DISPATCH(smooth_l1_backward_stub, &smooth_l1_backward_cuda_kernel);
 REGISTER_DISPATCH(huber_backward_stub, &huber_backward_cuda_kernel);
 REGISTER_DISPATCH(mse_backward_stub, &mse_backward_cuda_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/PowKernel.cu b/aten/src/ATen/native/cuda/PowKernel.cu
index eb56da722f..9602e10b87 100644
--- a/aten/src/ATen/native/cuda/PowKernel.cu
+++ b/aten/src/ATen/native/cuda/PowKernel.cu
@@ -9,7 +9,7 @@
 #include <ATen/native/Pow.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Forward declare some unary kernels
 void rsqrt_kernel_cuda(TensorIteratorBase& iter);
@@ -206,4 +206,4 @@ void pow_tensor_scalar_kernel(TensorIteratorBase& iter, const Scalar& exp_scalar
 REGISTER_DISPATCH(pow_tensor_tensor_stub, &pow_tensor_tensor_kernel);
 REGISTER_DISPATCH(pow_tensor_scalar_stub, &pow_tensor_scalar_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/RNN.cu b/aten/src/ATen/native/cuda/RNN.cu
index 405c3ff42f..d010e9a49d 100644
--- a/aten/src/ATen/native/cuda/RNN.cu
+++ b/aten/src/ATen/native/cuda/RNN.cu
@@ -19,7 +19,7 @@
 #include <ATen/ops/_thnn_fused_gru_cell_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -646,4 +646,4 @@ std::tuple<Tensor, Tensor, Tensor, Tensor, Tensor> _thnn_fused_gru_cell_backward
   return std::make_tuple(grad_input_gates, grad_hidden_gates, grad_hx, grad_input_bias, grad_hidden_bias);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Randperm.cu b/aten/src/ATen/native/cuda/Randperm.cu
index c22c99dfe6..41671b881b 100644
--- a/aten/src/ATen/native/cuda/Randperm.cu
+++ b/aten/src/ATen/native/cuda/Randperm.cu
@@ -18,7 +18,7 @@
 
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // [Algorithm of randperm]
 //
@@ -130,4 +130,4 @@ Tensor& randperm_out_cuda(int64_t n, c10::optional<Generator> generator, Tensor&
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/RangeFactories.cu b/aten/src/ATen/native/cuda/RangeFactories.cu
index e471ce9f9d..8b01c77c1e 100644
--- a/aten/src/ATen/native/cuda/RangeFactories.cu
+++ b/aten/src/ATen/native/cuda/RangeFactories.cu
@@ -21,6 +21,14 @@
 
 #define GPU_LAMBDA __device__ __host__
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+namespace std {
+  template< class T, class U >
+    inline constexpr bool is_same_v = is_same<T, U>::value;
+} // namespace std
+#endif
+
 namespace {
 
 #if defined(USE_ROCM)
@@ -67,7 +75,7 @@ void gpu_kernel_with_index(at::Tensor &output, func_t f) {
 
 }  // namespace
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor& linspace_cuda_out(const Scalar& start, const Scalar& end, int64_t steps, Tensor& result) {
   TORCH_CHECK(steps >= 0, "number of steps must be non-negative");
@@ -271,4 +279,4 @@ Tensor& arange_cuda_out(const Scalar& start, const Scalar& end, const Scalar& st
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/RecordStream.cu b/aten/src/ATen/native/cuda/RecordStream.cu
index cc7fc20d43..c56fcab365 100644
--- a/aten/src/ATen/native/cuda/RecordStream.cu
+++ b/aten/src/ATen/native/cuda/RecordStream.cu
@@ -8,9 +8,9 @@
 #include <ATen/ops/record_stream_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 void record_stream_cuda(Tensor& self, c10::Stream stream) {
   struct c10::StreamData3 data = stream.pack3();
   c10::cuda::CUDACachingAllocator::recordStream(self.storage().data_ptr(), at::cuda::CUDAStream::unpack3(data.stream_id, data.device_index, data.device_type));
 }
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Reduce.cu b/aten/src/ATen/native/cuda/Reduce.cu
index 36a1313488..3e215c367e 100644
--- a/aten/src/ATen/native/cuda/Reduce.cu
+++ b/aten/src/ATen/native/cuda/Reduce.cu
@@ -5,7 +5,7 @@
 #include <iostream>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 static inline std::ostream& operator<<(std::ostream& out, dim3 dim) {
   if (dim.y == 1 && dim.z == 1) {
@@ -53,4 +53,4 @@ std::ostream& operator<<(std::ostream& out, const ReduceConfig& config) {
   return out;
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceAMinMaxKernel.cu b/aten/src/ATen/native/cuda/ReduceAMinMaxKernel.cu
index cdd5daab2d..e746a8405d 100644
--- a/aten/src/ATen/native/cuda/ReduceAMinMaxKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceAMinMaxKernel.cu
@@ -15,7 +15,7 @@
 #include <ATen/NumericUtils.h>
 #include <ATen/cuda/NumericLimits.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t>
 void _min_max_values_kernel_cuda_impl(TensorIterator& iter) {
@@ -46,4 +46,4 @@ void aminmax_launch_kernel(TensorIterator& iter) {
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceArgMaxKernel.cu b/aten/src/ATen/native/cuda/ReduceArgMaxKernel.cu
index c5d763f313..d1cbebeb64 100644
--- a/aten/src/ATen/native/cuda/ReduceArgMaxKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceArgMaxKernel.cu
@@ -15,7 +15,7 @@
 #include <ATen/NumericUtils.h>
 #include <ATen/cuda/NumericLimits.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, typename acc_t = scalar_t>
 void argmax_kernel_cuda_impl(TensorIterator& iter) {
@@ -43,4 +43,4 @@ void argmax_kernel_cuda(TensorIterator& iter) {
 
 REGISTER_DISPATCH(argmax_stub, &argmax_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceArgMinKernel.cu b/aten/src/ATen/native/cuda/ReduceArgMinKernel.cu
index fc34c11c51..f7bef60a71 100644
--- a/aten/src/ATen/native/cuda/ReduceArgMinKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceArgMinKernel.cu
@@ -15,7 +15,7 @@
 #include <ATen/NumericUtils.h>
 #include <ATen/cuda/NumericLimits.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, typename acc_t = scalar_t>
 void argmin_kernel_cuda_impl(TensorIterator& iter) {
@@ -43,4 +43,4 @@ void argmin_kernel_cuda(TensorIterator& iter) {
 
 REGISTER_DISPATCH(argmin_stub, &argmin_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceLogicKernel.cu b/aten/src/ATen/native/cuda/ReduceLogicKernel.cu
index 3f65c745d7..2c04945dc4 100644
--- a/aten/src/ATen/native/cuda/ReduceLogicKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceLogicKernel.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/ReduceOps.h>
 #include <ATen/Dispatch.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void and_kernel_cuda(TensorIterator& iter) {
   AT_DISPATCH_ALL_TYPES_AND_COMPLEX_AND3(
@@ -35,4 +35,4 @@ void or_kernel_cuda(TensorIterator& iter) {
 REGISTER_DISPATCH(and_stub, &and_kernel_cuda);
 REGISTER_DISPATCH(or_stub, &or_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceMaxValuesKernel.cu b/aten/src/ATen/native/cuda/ReduceMaxValuesKernel.cu
index 883e8fe214..aac661517c 100644
--- a/aten/src/ATen/native/cuda/ReduceMaxValuesKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceMaxValuesKernel.cu
@@ -15,7 +15,7 @@
 #include <ATen/NumericUtils.h>
 #include <ATen/cuda/NumericLimits.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename acc_t>
 struct MaxNanFunctor {
@@ -58,4 +58,4 @@ void max_all_launch_kernel(TensorIterator &iter) {
 
 REGISTER_DISPATCH(max_values_stub, &max_values_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceMinValuesKernel.cu b/aten/src/ATen/native/cuda/ReduceMinValuesKernel.cu
index a0ccf873be..061dbd3ab1 100644
--- a/aten/src/ATen/native/cuda/ReduceMinValuesKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceMinValuesKernel.cu
@@ -16,7 +16,7 @@
 #include <ATen/cuda/NumericLimits.cuh>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename acc_t>
 struct MinNanFunctor {
@@ -55,4 +55,4 @@ void min_all_launch_kernel(TensorIterator &iter) {
 
 REGISTER_DISPATCH(min_values_stub, &min_values_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceMomentKernel.cu b/aten/src/ATen/native/cuda/ReduceMomentKernel.cu
index 1b23132264..b13f8e69fe 100644
--- a/aten/src/ATen/native/cuda/ReduceMomentKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceMomentKernel.cu
@@ -8,7 +8,7 @@
 #include <ATen/Dispatch.h>
 #include <ATen/native/ReduceOps.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, typename out_t=scalar_t>
 void std_var_kernel_impl(TensorIterator& iter, double correction, bool take_sqrt) {
@@ -65,4 +65,4 @@ static void mean_kernel_cuda(TensorIterator& iter) {
 REGISTER_DISPATCH(std_var_stub, &std_var_kernel_cuda);
 REGISTER_DISPATCH(mean_stub, &mean_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceNormKernel.cu b/aten/src/ATen/native/cuda/ReduceNormKernel.cu
index dd03f79be9..6ffe62b92e 100644
--- a/aten/src/ATen/native/cuda/ReduceNormKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceNormKernel.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/LinearAlgebra.h>
 #include <c10/core/Scalar.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // This reduction accumulates results as the type `acc_t`. By default, when
 // `scalar_t` is complex, `acc_t` is the downgraded real number type.
@@ -48,4 +48,4 @@ void norm_launch_kernel(TensorIterator& iter, double ord) {
   });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceOps.cpp b/aten/src/ATen/native/cuda/ReduceOps.cpp
index 0d0b5e20c4..fe1c390952 100644
--- a/aten/src/ATen/native/cuda/ReduceOps.cpp
+++ b/aten/src/ATen/native/cuda/ReduceOps.cpp
@@ -24,7 +24,7 @@
 #include <ATen/ops/where.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void norm_kernel_cuda(TensorIterator& iter, const Scalar& val) {
@@ -99,4 +99,4 @@ REGISTER_CUDA_DISPATCH(aminmax_stub, &aminmax_kernel_impl);
 
 REGISTER_CUDA_DISPATCH(norm_stub, &norm_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReduceSumProdKernel.cu b/aten/src/ATen/native/cuda/ReduceSumProdKernel.cu
index e628e1916f..e14768bd7c 100644
--- a/aten/src/ATen/native/cuda/ReduceSumProdKernel.cu
+++ b/aten/src/ATen/native/cuda/ReduceSumProdKernel.cu
@@ -8,7 +8,7 @@
 #include <ATen/jit_macros.h>
 #include <ATen/OpMathType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, typename acc_t = scalar_t, typename out_t = scalar_t>
 struct sum_functor {
@@ -212,4 +212,4 @@ REGISTER_DISPATCH(sum_stub, &sum_kernel_cuda);
 REGISTER_DISPATCH(nansum_stub, &nansum_kernel_cuda);
 REGISTER_DISPATCH(prod_stub, &prod_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReflectionPad.cu b/aten/src/ATen/native/cuda/ReflectionPad.cu
index 3e576c8967..0e1936cb77 100644
--- a/aten/src/ATen/native/cuda/ReflectionPad.cu
+++ b/aten/src/ATen/native/cuda/ReflectionPad.cu
@@ -25,7 +25,7 @@
 
 #include <thrust/pair.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 using at::cuda::detail::canUse32BitIndexMath;
@@ -674,4 +674,4 @@ TORCH_IMPL_FUNC(reflection_pad3d_backward_out_cuda) (
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/RenormKernel.cu b/aten/src/ATen/native/cuda/RenormKernel.cu
index ef133761ae..740d112754 100644
--- a/aten/src/ATen/native/cuda/RenormKernel.cu
+++ b/aten/src/ATen/native/cuda/RenormKernel.cu
@@ -5,7 +5,7 @@
 
 #include <ATen/Dispatch.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 void renorm_scale_factor_impl(TensorIteratorBase& iter, double maxnorm) {
@@ -26,4 +26,4 @@ void renorm_scale_factor_impl(TensorIteratorBase& iter, double maxnorm) {
 
 REGISTER_DISPATCH(renorm_scale_factor_stub, &renorm_scale_factor_impl);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Repeat.cu b/aten/src/ATen/native/cuda/Repeat.cu
index 65c6863745..d903751aa8 100644
--- a/aten/src/ATen/native/cuda/Repeat.cu
+++ b/aten/src/ATen/native/cuda/Repeat.cu
@@ -50,7 +50,7 @@ static void compute_cuda(
   C10_CUDA_KERNEL_LAUNCH_CHECK();
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor repeat_interleave_cuda(
     const Tensor& repeat,
@@ -64,4 +64,4 @@ Tensor repeat_interleave_cuda(
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ReplicationPadding.cu b/aten/src/ATen/native/cuda/ReplicationPadding.cu
index e65c0e90fe..a7d6dec66c 100644
--- a/aten/src/ATen/native/cuda/ReplicationPadding.cu
+++ b/aten/src/ATen/native/cuda/ReplicationPadding.cu
@@ -27,7 +27,7 @@
 #include <cmath>
 
 
-namespace at::native {
+namespace at{ namespace native {
 __host__ __device__ __forceinline__ int imin(int a, int b) {
   return a > b ? b : a;
 }
@@ -695,4 +695,4 @@ Tensor replication_pad3d_backward_cuda(
   return gradInput;
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/Resize.cpp b/aten/src/ATen/native/cuda/Resize.cpp
index 2bf6266d67..02efe4e37a 100644
--- a/aten/src/ATen/native/cuda/Resize.cpp
+++ b/aten/src/ATen/native/cuda/Resize.cpp
@@ -12,7 +12,7 @@
 #include <ATen/ops/resize_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 void resize_bytes_cuda(StorageImpl* storage, size_t size_bytes) {
   TORCH_CHECK(storage->resizable(), "Trying to resize storage that is not resizable");
@@ -71,4 +71,4 @@ const Tensor& resize_cuda_(
   }
   return self;
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/RreluWithNoise.cu b/aten/src/ATen/native/cuda/RreluWithNoise.cu
index 463a5ce00c..99873b6a89 100644
--- a/aten/src/ATen/native/cuda/RreluWithNoise.cu
+++ b/aten/src/ATen/native/cuda/RreluWithNoise.cu
@@ -14,7 +14,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, int unroll_factor, typename F>
 #if __CUDA_ARCH__ >= 350 || defined USE_ROCM
@@ -192,4 +192,4 @@ Tensor& rrelu_with_noise_cuda_(
       self, noise, lower, upper, training, generator, self);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ScanKernels.cpp b/aten/src/ATen/native/cuda/ScanKernels.cpp
index 463ceb23ba..bf9942d074 100644
--- a/aten/src/ATen/native/cuda/ScanKernels.cpp
+++ b/aten/src/ATen/native/cuda/ScanKernels.cpp
@@ -16,7 +16,7 @@
 #include <ATen/ops/empty_like.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static c10::MaybeOwned<Tensor> contiguous_out_arg(const Tensor &tensor) {
   if (tensor.is_contiguous()) {
@@ -112,4 +112,4 @@ void cumprod_cuda_kernel(const Tensor& result, const Tensor& self, int64_t dim)
 REGISTER_CUDA_DISPATCH(cumsum_stub, &cumsum_cuda_kernel);
 REGISTER_CUDA_DISPATCH(cumprod_stub, &cumprod_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ScatterGatherKernel.cu b/aten/src/ATen/native/cuda/ScatterGatherKernel.cu
index 5509d854a3..3633f9f87d 100644
--- a/aten/src/ATen/native/cuda/ScatterGatherKernel.cu
+++ b/aten/src/ATen/native/cuda/ScatterGatherKernel.cu
@@ -15,7 +15,7 @@
 #include <ATen/cuda/Atomic.cuh>
 #include <ATen/cuda/CUDAContext.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Implement as functors since lambdas don't get optimized.
 class ReduceMultiply {
@@ -570,4 +570,4 @@ REGISTER_DISPATCH(scatter_reduce_stub, &scatter_reduce_cuda_kernel);
 REGISTER_DISPATCH(scatter_scalar_reduce_stub, &scatter_scalar_reduce_cuda_kernel);
 REGISTER_DISPATCH(scatter_reduce_two_stub, &scatter_reduce_two_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SegmentReduce.cu b/aten/src/ATen/native/cuda/SegmentReduce.cu
index d4af81db77..e7e9f79172 100644
--- a/aten/src/ATen/native/cuda/SegmentReduce.cu
+++ b/aten/src/ATen/native/cuda/SegmentReduce.cu
@@ -17,7 +17,7 @@
 #include <ATen/ops/cumsum.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 struct CustomMax {
@@ -599,4 +599,4 @@ REGISTER_DISPATCH(
   _segment_reduce_offsets_backward_stub,
   &_segment_reduce_offsets_backward_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Shape.cu b/aten/src/ATen/native/cuda/Shape.cu
index 2ecd52ac8f..e58e460c8b 100644
--- a/aten/src/ATen/native/cuda/Shape.cu
+++ b/aten/src/ATen/native/cuda/Shape.cu
@@ -23,7 +23,7 @@
 #include <ATen/ops/narrow.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 constexpr int CAT_ARRAY_BATCH_SIZE = 128;
 constexpr int CAT_ARRAY_MAX_INPUT_DIMS = 4;
@@ -447,4 +447,4 @@ TORCH_IMPL_FUNC(cat_out_cuda)
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SoftMax.cu b/aten/src/ATen/native/cuda/SoftMax.cu
index b57d778d7c..10b1253009 100644
--- a/aten/src/ATen/native/cuda/SoftMax.cu
+++ b/aten/src/ATen/native/cuda/SoftMax.cu
@@ -29,7 +29,7 @@
 #include <ATen/ops/_softmax_backward_data.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1137,4 +1137,4 @@ Tensor masked_softmax_backward_cuda(
   return grad_input;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Sort.cpp b/aten/src/ATen/native/cuda/Sort.cpp
index 87475923e5..c3ca89b75a 100644
--- a/aten/src/ATen/native/cuda/Sort.cpp
+++ b/aten/src/ATen/native/cuda/Sort.cpp
@@ -21,7 +21,7 @@
 
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 std::vector<int64_t> infer_dense_strides_dim_last(const Tensor & self, int64_t dim);
 
@@ -124,4 +124,4 @@ void sort_cuda_kernel(
 // NOLINTNEXTLINE(cppcoreguidelines-avoid-non-const-global-variables)
 REGISTER_CUDA_DISPATCH(sort_stub, &sort_cuda_kernel);
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Sort.cu b/aten/src/ATen/native/cuda/Sort.cu
index e60dd72754..c5d50fcb01 100644
--- a/aten/src/ATen/native/cuda/Sort.cu
+++ b/aten/src/ATen/native/cuda/Sort.cu
@@ -14,7 +14,15 @@
 #include <limits>
 #include <c10/core/DeviceArray.h>
 
-namespace at::native {
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+namespace std {
+  template< class T, class U >
+    inline constexpr bool is_same_v = is_same<T, U>::value;
+} // namespace std
+#endif
+
+namespace at{ namespace native {
 
 template <typename T>
 static int minimum_grid_for_occupancy(T kernel, int max_block_size) {
@@ -379,4 +387,4 @@ void sortKeyValueInplace(
   }
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SortImpl.cu b/aten/src/ATen/native/cuda/SortImpl.cu
index 5d779d0fd1..77ad838ad3 100644
--- a/aten/src/ATen/native/cuda/SortImpl.cu
+++ b/aten/src/ATen/native/cuda/SortImpl.cu
@@ -3,7 +3,7 @@
 #include <thrust/execution_policy.h>
 #include <thrust/sort.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 std::vector<int64_t> infer_dense_strides_dim_last(const Tensor & self, int64_t dim) {
   int64_t ndim = self.dim();
@@ -34,4 +34,4 @@ std::vector<int64_t> infer_dense_strides_dim_last(const Tensor & self, int64_t d
   return new_strides_unsort;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SortStable.cu b/aten/src/ATen/native/cuda/SortStable.cu
index b80f6fdb4e..22e542a30d 100644
--- a/aten/src/ATen/native/cuda/SortStable.cu
+++ b/aten/src/ATen/native/cuda/SortStable.cu
@@ -15,7 +15,7 @@
 #include <c10/core/DeviceArray.h>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -293,4 +293,4 @@ void launch_stable_sort_kernel(
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Sorting.cpp b/aten/src/ATen/native/cuda/Sorting.cpp
index 9381c0e4f0..e57537ee7a 100644
--- a/aten/src/ATen/native/cuda/Sorting.cpp
+++ b/aten/src/ATen/native/cuda/Sorting.cpp
@@ -23,7 +23,7 @@
 #include <ATen/ops/where.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 std::tuple<Tensor&, Tensor&> kthvalue_out_impl_cuda(
@@ -204,4 +204,4 @@ Tensor nanmedian_cuda(const Tensor& self) {
   return median_impl(self, /*ignore_nan=*/true);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Sorting.cu b/aten/src/ATen/native/cuda/Sorting.cu
index 313c6d1ea9..9ddbebcc97 100644
--- a/aten/src/ATen/native/cuda/Sorting.cu
+++ b/aten/src/ATen/native/cuda/Sorting.cu
@@ -15,7 +15,7 @@
 #include <cassert>
 #include <cstdlib>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -277,4 +277,4 @@ void launch_median_kernel(
       });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SparseBinaryOpIntersectionKernel.cu b/aten/src/ATen/native/cuda/SparseBinaryOpIntersectionKernel.cu
index 62282659f6..4f1dbfb6b1 100644
--- a/aten/src/ATen/native/cuda/SparseBinaryOpIntersectionKernel.cu
+++ b/aten/src/ATen/native/cuda/SparseBinaryOpIntersectionKernel.cu
@@ -6,7 +6,7 @@
 #include <ATen/cuda/detail/OffsetCalculator.cuh>
 #include <ATen/AccumulateType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -208,4 +208,4 @@ REGISTER_CUDA_DISPATCH(mul_sparse_sparse_out_stub, &mul_sparse_sparse_out_cuda_k
 REGISTER_CUDA_DISPATCH(sparse_mask_intersection_out_stub, &sparse_mask_intersection_out_cuda_kernel);
 REGISTER_CUDA_DISPATCH(sparse_mask_projection_out_stub, &sparse_mask_projection_out_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SparseMM.cu b/aten/src/ATen/native/cuda/SparseMM.cu
index 78bc554b52..7f08cb5aba 100644
--- a/aten/src/ATen/native/cuda/SparseMM.cu
+++ b/aten/src/ATen/native/cuda/SparseMM.cu
@@ -8,7 +8,7 @@
 #include <ATen/ops/sspaddmm_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 // sparse, sparse, sparse, dense, real, real -> sparse
 Tensor& _sspaddmm_out_only_sparse_cuda(const Tensor& self,
     const Tensor& mat1, const Tensor& mat2, const Scalar& beta, const Scalar& alpha, Tensor& result) {
@@ -18,4 +18,4 @@ Tensor& _sspaddmm_out_cuda(const Tensor& self,
     const Tensor& mat1, const Tensor& mat2, const Scalar& beta, const Scalar& alpha, Tensor& result) {
   AT_ERROR("NYI: CUDA sspaddmm is not implemented");
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/SpectralOps.cpp b/aten/src/ATen/native/cuda/SpectralOps.cpp
index 6a0c05a9e5..9cc9d9128b 100644
--- a/aten/src/ATen/native/cuda/SpectralOps.cpp
+++ b/aten/src/ATen/native/cuda/SpectralOps.cpp
@@ -30,7 +30,7 @@
 #include <cmath>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::native::detail;
 
@@ -545,4 +545,4 @@ Tensor& _fft_c2c_cufft_out(const Tensor& self, IntArrayRef dim,
 }
 
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/SpectralOps.cu b/aten/src/ATen/native/cuda/SpectralOps.cu
index 0141a6b952..3dd782dc17 100644
--- a/aten/src/ATen/native/cuda/SpectralOps.cu
+++ b/aten/src/ATen/native/cuda/SpectralOps.cu
@@ -11,7 +11,7 @@
 #include <vector>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Offset calculator for indexing in Hermitian mirrored order.
 // In mirrored dims, maps linear index i to (n - i) % n
@@ -121,4 +121,4 @@ void _fft_fill_with_conjugate_symmetry_cuda_(
 
 REGISTER_DISPATCH(fft_fill_with_conjugate_symmetry_stub, &_fft_fill_with_conjugate_symmetry_cuda_);
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/StepKernel.cu b/aten/src/ATen/native/cuda/StepKernel.cu
index 72ad829828..d429f2a56f 100644
--- a/aten/src/ATen/native/cuda/StepKernel.cu
+++ b/aten/src/ATen/native/cuda/StepKernel.cu
@@ -9,7 +9,7 @@
 // NOTE: CUDA on Windows requires that the enclosing function
 // of a __device__ lambda not have internal linkage.
 
-namespace at::native {
+namespace at{ namespace native {
 
 void nextafter_kernel_cuda(TensorIteratorBase& iter) {
   AT_DISPATCH_FLOATING_TYPES_AND(kBFloat16, iter.common_dtype(), "nextafter_cuda", [&]() {
@@ -30,4 +30,4 @@ void heaviside_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(nextafter_stub, &nextafter_kernel_cuda);
 REGISTER_DISPATCH(heaviside_stub, &heaviside_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorCompare.cpp b/aten/src/ATen/native/cuda/TensorCompare.cpp
index 1b4d7490b0..533ca6e072 100644
--- a/aten/src/ATen/native/cuda/TensorCompare.cpp
+++ b/aten/src/ATen/native/cuda/TensorCompare.cpp
@@ -2,7 +2,7 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/native/TensorCompare.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -20,4 +20,4 @@ void isin_default_kernel_gpu(
 
 REGISTER_CUDA_DISPATCH(isin_default_stub, &isin_default_kernel_gpu);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorCompare.cu b/aten/src/ATen/native/cuda/TensorCompare.cu
index f695640517..0e5df4c022 100644
--- a/aten/src/ATen/native/cuda/TensorCompare.cu
+++ b/aten/src/ATen/native/cuda/TensorCompare.cu
@@ -7,7 +7,7 @@
 #include <c10/core/Scalar.h>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -130,4 +130,4 @@ void _assert_async_msg_cuda(const Tensor& self_tensor, c10::string_view assert_m
   _assert_async_cuda(self_tensor);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorFactories.cu b/aten/src/ATen/native/cuda/TensorFactories.cu
index 42ea83a4b8..274da717d6 100644
--- a/aten/src/ATen/native/cuda/TensorFactories.cu
+++ b/aten/src/ATen/native/cuda/TensorFactories.cu
@@ -29,7 +29,7 @@
 #include <cmath>
 #include <cstddef>
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor& eye_out_cuda(int64_t n, Tensor& result) {
   // the default value of `m` equals to `n`
@@ -394,4 +394,4 @@ Tensor triu_indices_cuda(
   return tensor;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorModeKernel.cpp b/aten/src/ATen/native/cuda/TensorModeKernel.cpp
index d22ea241aa..0da444b934 100644
--- a/aten/src/ATen/native/cuda/TensorModeKernel.cpp
+++ b/aten/src/ATen/native/cuda/TensorModeKernel.cpp
@@ -11,7 +11,7 @@ constexpr int MAX_BLOCK_SIZE = AT_ROCM_ENABLED() ? 256 : 1024;
 // Maximum size per grid dimension that we assume (compute capability >= 2.0)
 constexpr int64_t MAX_GRID_SIZE = 65535LL;
 
-namespace at::native {
+namespace at{ namespace native {
 
 void mode_kernel_impl(
     Tensor& values,
@@ -99,4 +99,4 @@ void mode_kernel_impl(
 }
 
 REGISTER_CUDA_DISPATCH(mode_stub, &mode_kernel_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorModeKernel.cu b/aten/src/ATen/native/cuda/TensorModeKernel.cu
index b848ed5748..18fc8a6498 100644
--- a/aten/src/ATen/native/cuda/TensorModeKernel.cu
+++ b/aten/src/ATen/native/cuda/TensorModeKernel.cu
@@ -18,7 +18,7 @@
 #include <thrust/sequence.h>
 #include <thrust/sort.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t>
 struct ModeImpl {
@@ -287,4 +287,4 @@ void launch_apply_mode_kernel(const TensorBase &values, const TensorBase &indice
   });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorShapeCUDA.cpp b/aten/src/ATen/native/cuda/TensorShapeCUDA.cpp
index 8edfa1a674..c2c511920d 100644
--- a/aten/src/ATen/native/cuda/TensorShapeCUDA.cpp
+++ b/aten/src/ATen/native/cuda/TensorShapeCUDA.cpp
@@ -10,7 +10,7 @@
 #include <ATen/ops/set_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // this needs to be split along CPU/CUDA lines because we don't have a consistent
 // way of getting the allocator to use for a device (c10::GetAllocator is not
@@ -38,4 +38,4 @@ Tensor& set_storage_cuda_(Tensor& result, Storage storage, int64_t storage_offse
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorTopK.cpp b/aten/src/ATen/native/cuda/TensorTopK.cpp
index 36e45d4dae..23e1f1d847 100644
--- a/aten/src/ATen/native/cuda/TensorTopK.cpp
+++ b/aten/src/ATen/native/cuda/TensorTopK.cpp
@@ -17,7 +17,7 @@
 #include <ATen/ops/topk_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 // TODO: remove this when CUDA <11.6 is no longer supported
 void topk_out_with_sort(
@@ -94,4 +94,4 @@ TORCH_IMPL_FUNC(topk_out_cuda)
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TensorTopK.cu b/aten/src/ATen/native/cuda/TensorTopK.cu
index bd48c9b058..4add29442a 100644
--- a/aten/src/ATen/native/cuda/TensorTopK.cu
+++ b/aten/src/ATen/native/cuda/TensorTopK.cu
@@ -19,7 +19,7 @@
 
 using namespace at::native;
 
-namespace at::native {
+namespace at{ namespace native {
 
 // TODO: remove this when CUDA <11.6 is no longer supported
 bool disable_sort_for_topk() {
@@ -617,7 +617,7 @@ int get_items_per_thread(uint64_t num_slices, uint64_t slice_size) {
   int max_blocks_per_mp = 32;
 #else
   int regs_per_mp = prop->regsPerMultiprocessor;
-#if !defined(USE_ROCM)
+#if !defined(USE_ROCM) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
   int max_blocks_per_mp = prop->maxBlocksPerMultiProcessor;
 #else
   int max_blocks_per_mp = 32;
@@ -904,4 +904,4 @@ void launch_gather_topk_kernel(
 #undef RUN_K
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/cuda/TensorTransformations.cu b/aten/src/ATen/native/cuda/TensorTransformations.cu
index 1823756a48..c8ec84fb05 100644
--- a/aten/src/ATen/native/cuda/TensorTransformations.cu
+++ b/aten/src/ATen/native/cuda/TensorTransformations.cu
@@ -18,7 +18,7 @@
 #include <cstddef>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename scalar_t, typename IndexType>
 #if __CUDA_ARCH__ >= 350 || defined(USE_ROCM)
@@ -151,4 +151,4 @@ Tensor roll_cuda(const Tensor& self, IntArrayRef shifts, IntArrayRef dims) {
   return out_tensor;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/TriangularOps.cu b/aten/src/ATen/native/cuda/TriangularOps.cu
index e7ab3a44dd..784652f12a 100644
--- a/aten/src/ATen/native/cuda/TriangularOps.cu
+++ b/aten/src/ATen/native/cuda/TriangularOps.cu
@@ -19,7 +19,7 @@
 
 #include <ATen/cuda/CUDAApplyUtils.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ triu/tril ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -110,4 +110,4 @@ Tensor trace_cuda(const Tensor& self) {
   return self.diagonal().sum();
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryComplexKernels.cu b/aten/src/ATen/native/cuda/UnaryComplexKernels.cu
index 14c4e934c6..9cd6bbd402 100644
--- a/aten/src/ATen/native/cuda/UnaryComplexKernels.cu
+++ b/aten/src/ATen/native/cuda/UnaryComplexKernels.cu
@@ -9,7 +9,7 @@
 #include <ATen/native/DispatchStub.h>
 #include <ATen/native/TensorIterator.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // We manually overload angle because std::arg does not work with types other than c10::complex.
 template<typename scalar_t>
@@ -99,4 +99,4 @@ void conj_kernel_cuda(TensorIteratorBase& iter) {
 REGISTER_DISPATCH(angle_stub, &angle_kernel_cuda);
 REGISTER_DISPATCH(conj_physical_stub, &conj_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryFractionKernels.cu b/aten/src/ATen/native/cuda/UnaryFractionKernels.cu
index e3529e5503..6edefde92b 100644
--- a/aten/src/ATen/native/cuda/UnaryFractionKernels.cu
+++ b/aten/src/ATen/native/cuda/UnaryFractionKernels.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cuda/Math.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // We manually overload ceil because std::ceil does not work with std::complex types.
 template <typename scalar_t>
@@ -196,4 +196,4 @@ REGISTER_DISPATCH(round_stub, &round_kernel_cuda);
 REGISTER_DISPATCH(round_decimals_stub, &round_decimals_kernel_cuda);
 REGISTER_DISPATCH(trunc_stub, &trunc_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGammaKernels.cu b/aten/src/ATen/native/cuda/UnaryGammaKernels.cu
index 4393d91818..07232c29b2 100644
--- a/aten/src/ATen/native/cuda/UnaryGammaKernels.cu
+++ b/aten/src/ATen/native/cuda/UnaryGammaKernels.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/Math.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char digamma_name[] = "digamma";
@@ -107,4 +107,4 @@ REGISTER_DISPATCH(digamma_stub, &digamma_kernel_cuda);
 REGISTER_DISPATCH(polygamma_stub, &polygamma_kernel_cuda);
 REGISTER_DISPATCH(lgamma_stub, &lgamma_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAcosKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAcosKernel.cu
index 42ef6a9960..13ab5bc345 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAcosKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAcosKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if 0 && AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char acos_name[] = "acos_impl";
@@ -55,4 +55,4 @@ void acos_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(acos_stub, &acos_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAcoshKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAcoshKernel.cu
index d621dd246a..de6eb8c09b 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAcoshKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAcoshKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if 0 && AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char acosh_name[] = "acosh_impl";
@@ -56,4 +56,4 @@ void acosh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(acosh_stub, &acosh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAsinKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAsinKernel.cu
index e9b16dd3d2..1f1efff0ad 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAsinKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAsinKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if 0 && AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char asin_name[] = "asin_impl";
@@ -52,4 +52,4 @@ void asin_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(asin_stub, &asin_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAsinhKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAsinhKernel.cu
index 7494932f9d..911fcd6841 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAsinhKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAsinhKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if 0 && AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char asinh_name[] = "asinh_impl";
@@ -56,4 +56,4 @@ void asinh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(asinh_stub, &asinh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAtanKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAtanKernel.cu
index 758d7bc5c8..e380b927ef 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAtanKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAtanKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char atan_name[] = "atan_impl";
@@ -55,4 +55,4 @@ void atan_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(atan_stub, &atan_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricAtanhKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricAtanhKernel.cu
index aad7775219..d62046be5d 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricAtanhKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricAtanhKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char atanh_name[] = "atanh_impl";
@@ -55,4 +55,4 @@ void atanh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(atanh_stub, &atanh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricCosKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricCosKernel.cu
index 2a994fb626..d069efb9f6 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricCosKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricCosKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char cos_name[] = "cos_impl";
@@ -54,4 +54,4 @@ void cos_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(cos_stub, &cos_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricCoshKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricCoshKernel.cu
index 49babec137..925337dd49 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricCoshKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricCoshKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char cosh_name[] = "cosh_impl";
@@ -55,4 +55,4 @@ void cosh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(cosh_stub, &cosh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricSinKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricSinKernel.cu
index d87a190959..2f69a57e52 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricSinKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricSinKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char sin_name[] = "sin_impl";
@@ -54,4 +54,4 @@ void sin_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(sin_stub, &sin_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricSinhKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricSinhKernel.cu
index 82b730a0ff..6b01063f7f 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricSinhKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricSinhKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char sinh_name[] = "sinh_impl";
@@ -55,4 +55,4 @@ void sinh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(sinh_stub, &sinh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricTanKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricTanKernel.cu
index 8f62529e8e..c40d9a490c 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricTanKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricTanKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char tan_name[] = "tan_impl";
@@ -54,4 +54,4 @@ void tan_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(tan_stub, &tan_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryGeometricTanhKernel.cu b/aten/src/ATen/native/cuda/UnaryGeometricTanhKernel.cu
index d5f0172015..555d587d6a 100644
--- a/aten/src/ATen/native/cuda/UnaryGeometricTanhKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryGeometricTanhKernel.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char tanh_name[] = "tanh_impl";
@@ -55,4 +55,4 @@ void tanh_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(tanh_stub, &tanh_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryLogKernels.cu b/aten/src/ATen/native/cuda/UnaryLogKernels.cu
index 2a2f56670b..1d165a54ff 100644
--- a/aten/src/ATen/native/cuda/UnaryLogKernels.cu
+++ b/aten/src/ATen/native/cuda/UnaryLogKernels.cu
@@ -10,7 +10,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/native/cuda/Math.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 #if AT_USE_JITERATOR()
 CONSTEXPR_EXCEPT_WIN_CUDA char log_name[] = "log_kernel";
@@ -118,4 +118,4 @@ REGISTER_DISPATCH(log10_stub, &log10_kernel_cuda);
 REGISTER_DISPATCH(log2_stub, &log2_kernel_cuda);
 REGISTER_DISPATCH(log1p_stub, &log1p_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnaryOpsKernel.cu b/aten/src/ATen/native/cuda/UnaryOpsKernel.cu
index 451c15443f..8aa59ae8d5 100644
--- a/aten/src/ATen/native/cuda/UnaryOpsKernel.cu
+++ b/aten/src/ATen/native/cuda/UnaryOpsKernel.cu
@@ -18,7 +18,7 @@
 #include <c10/core/Scalar.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void bitwise_not_kernel_cuda(TensorIteratorBase& iter) {
   if (iter.dtype() == ScalarType::Bool) {
@@ -283,4 +283,4 @@ REGISTER_DISPATCH(sqrt_stub, &sqrt_kernel_cuda);
 REGISTER_DISPATCH(nan_to_num_stub, &nan_to_num_kernel_cuda);
 REGISTER_DISPATCH(frexp_stub, &frexp_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnarySignKernels.cu b/aten/src/ATen/native/cuda/UnarySignKernels.cu
index 83233f3143..0a04f0de39 100644
--- a/aten/src/ATen/native/cuda/UnarySignKernels.cu
+++ b/aten/src/ATen/native/cuda/UnarySignKernels.cu
@@ -12,7 +12,7 @@
 
 #include <type_traits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void logical_not_kernel_cuda(TensorIteratorBase& iter) {
   // error check -- this is just ensuring we don't dispatch on types that aren't in ALL_TYPES_AND_COMPLEX_AND3(...)
@@ -134,4 +134,4 @@ REGISTER_DISPATCH(sign_stub, &sign_kernel_cuda);
 REGISTER_DISPATCH(signbit_stub, &signbit_kernel_cuda);
 REGISTER_DISPATCH(sgn_stub, &sgn_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnarySpecialOpsKernel.cu b/aten/src/ATen/native/cuda/UnarySpecialOpsKernel.cu
index f259776c2f..37ddfd880b 100644
--- a/aten/src/ATen/native/cuda/UnarySpecialOpsKernel.cu
+++ b/aten/src/ATen/native/cuda/UnarySpecialOpsKernel.cu
@@ -17,7 +17,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 CONSTEXPR_EXCEPT_WIN_CUDA char exp2_name[] = "exp2_kernel";
 void exp2_kernel_cuda(TensorIteratorBase& iter) {
@@ -395,4 +395,4 @@ REGISTER_DISPATCH(special_ndtri_stub, &ndtri_kernel_cuda);
 REGISTER_DISPATCH(special_log_ndtr_stub, &log_ndtr_kernel_cuda);
 REGISTER_DISPATCH(special_erfcx_stub, &erfcx_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UnfoldBackwardKernel.cu b/aten/src/ATen/native/cuda/UnfoldBackwardKernel.cu
index 2f48d4fc01..18eeed5112 100644
--- a/aten/src/ATen/native/cuda/UnfoldBackwardKernel.cu
+++ b/aten/src/ATen/native/cuda/UnfoldBackwardKernel.cu
@@ -15,7 +15,7 @@
 // unfold_backward, the algorithm is described in
 // /native/cpu/UnfoldBackwardKernel.cpp
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -159,4 +159,4 @@ void unfold_backward_cuda_kernel(
 
 REGISTER_DISPATCH(unfold_backward_stub, &unfold_backward_cuda_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/Unique.cu b/aten/src/ATen/native/cuda/Unique.cu
index 31aa3a9cd1..7bf5ff0fff 100644
--- a/aten/src/ATen/native/cuda/Unique.cu
+++ b/aten/src/ATen/native/cuda/Unique.cu
@@ -29,7 +29,7 @@
 
 #include <ATen/native/cuda/UniqueCub.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -232,4 +232,4 @@ unique_consecutive_cuda(const Tensor& self, const bool return_inverse, const boo
   return unique_dim_consecutive_cuda(self, dim.value(), return_inverse, return_counts);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UniqueCub.cu b/aten/src/ATen/native/cuda/UniqueCub.cu
index 38f75f1ee4..f2be09a94b 100644
--- a/aten/src/ATen/native/cuda/UniqueCub.cu
+++ b/aten/src/ATen/native/cuda/UniqueCub.cu
@@ -16,7 +16,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native::internal {
+namespace at{ namespace native { namespace internal {
 
 namespace {
 
@@ -338,4 +338,4 @@ INSTANTIATE_UNIQUE_CUDA_TEMPLATE(at::Half);
 
 #undef INSTANTIATE
 
-} // namespace at::native::internal
+}}} // namespace at::native::internal
diff --git a/aten/src/ATen/native/cuda/UpSampleBicubic2d.cu b/aten/src/ATen/native/cuda/UpSampleBicubic2d.cu
index c96d7dbae7..461ca91f71 100644
--- a/aten/src/ATen/native/cuda/UpSampleBicubic2d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleBicubic2d.cu
@@ -16,7 +16,7 @@
 #include <ATen/ops/upsample_bicubic2d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t, typename accscalar_t>
@@ -296,4 +296,4 @@ TORCH_IMPL_FUNC(upsample_bicubic2d_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleBilinear2d.cu b/aten/src/ATen/native/cuda/UpSampleBilinear2d.cu
index 1570853c84..ef70763778 100644
--- a/aten/src/ATen/native/cuda/UpSampleBilinear2d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleBilinear2d.cu
@@ -27,7 +27,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t, typename accscalar_t>
@@ -920,4 +920,4 @@ TORCH_IMPL_FUNC(_upsample_bicubic2d_aa_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, align_corners, scales_h, scales_w);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleLinear1d.cu b/aten/src/ATen/native/cuda/UpSampleLinear1d.cu
index 54a03ae61b..42d2208c83 100644
--- a/aten/src/ATen/native/cuda/UpSampleLinear1d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleLinear1d.cu
@@ -19,7 +19,7 @@
 #include <ATen/ops/upsample_linear1d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename scalar_t, typename accscalar_t>
@@ -229,4 +229,4 @@ TORCH_IMPL_FUNC(upsample_linear1d_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, align_corners, scales);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleNearest1d.cu b/aten/src/ATen/native/cuda/UpSampleNearest1d.cu
index 6bfeef431c..9cc5ed8d26 100644
--- a/aten/src/ATen/native/cuda/UpSampleNearest1d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleNearest1d.cu
@@ -18,7 +18,7 @@
 #include <ATen/ops/_upsample_nearest_exact1d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 #define MAX_THREADS 512
@@ -235,4 +235,4 @@ TORCH_IMPL_FUNC(_upsample_nearest_exact1d_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, scales);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleNearest2d.cu b/aten/src/ATen/native/cuda/UpSampleNearest2d.cu
index ba71fdc0b0..03b4b46dd0 100644
--- a/aten/src/ATen/native/cuda/UpSampleNearest2d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleNearest2d.cu
@@ -22,7 +22,7 @@
 #include <ATen/ops/upsample_nearest2d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 #define MAX_THREADS 512
@@ -484,4 +484,4 @@ TORCH_IMPL_FUNC(_upsample_nearest_exact2d_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, scales_h, scales_w);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleNearest3d.cu b/aten/src/ATen/native/cuda/UpSampleNearest3d.cu
index f9c1dfdb8a..d6541feeaa 100644
--- a/aten/src/ATen/native/cuda/UpSampleNearest3d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleNearest3d.cu
@@ -24,7 +24,7 @@
 #include <ATen/ops/_upsample_nearest_exact3d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 #define MAX_THREADS 512
@@ -336,4 +336,4 @@ TORCH_IMPL_FUNC(_upsample_nearest_exact3d_backward_out_cuda) (
 using at::native::upsample::compute_output_size;
 using at::native::upsample_cuda::get_scale_value;
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/UpSampleTrilinear3d.cu b/aten/src/ATen/native/cuda/UpSampleTrilinear3d.cu
index de8e797c6d..27941f3cb6 100644
--- a/aten/src/ATen/native/cuda/UpSampleTrilinear3d.cu
+++ b/aten/src/ATen/native/cuda/UpSampleTrilinear3d.cu
@@ -21,7 +21,7 @@
 #include <ATen/ops/upsample_trilinear3d_backward_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 __device__ __forceinline__ size_t
@@ -395,4 +395,4 @@ TORCH_IMPL_FUNC(upsample_trilinear3d_backward_out_cuda) (
       grad_input, grad_output, output_size, input_size, align_corners, scales_d, scales_h, scales_w);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ValidateCompressedIndicesKernel.cu b/aten/src/ATen/native/cuda/ValidateCompressedIndicesKernel.cu
index 9f7fb1cbd0..abbd412fa4 100644
--- a/aten/src/ATen/native/cuda/ValidateCompressedIndicesKernel.cu
+++ b/aten/src/ATen/native/cuda/ValidateCompressedIndicesKernel.cu
@@ -2,7 +2,7 @@
 #include <ATen/native/sparse/ValidateCompressedIndicesCommon.h>
 #include <ATen/native/cuda/Loops.cuh>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -26,4 +26,4 @@ void _validate_compressed_sparse_indices_cuda(
       is_crow, cidx, idx, cdim, dim, nnz);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/WeightNorm.cu b/aten/src/ATen/native/cuda/WeightNorm.cu
index 7ac9f8ffa7..fc670edb37 100644
--- a/aten/src/ATen/native/cuda/WeightNorm.cu
+++ b/aten/src/ATen/native/cuda/WeightNorm.cu
@@ -19,7 +19,7 @@
 #endif
 
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 // Block size for weight_norm_*_first_dim_kernel.
@@ -522,4 +522,4 @@ std::tuple<Tensor, Tensor> weight_norm_backward_cuda
 #undef TILE_W
 #undef TILE_H
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/ZetaKernel.cu b/aten/src/ATen/native/cuda/ZetaKernel.cu
index 7459504f50..fa5599aada 100644
--- a/aten/src/ATen/native/cuda/ZetaKernel.cu
+++ b/aten/src/ATen/native/cuda/ZetaKernel.cu
@@ -7,7 +7,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 /*
@@ -36,4 +36,4 @@ void zeta_kernel_cuda(TensorIteratorBase& iter) {
 
 REGISTER_DISPATCH(zeta_stub, &zeta_kernel_cuda);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/airy_ai.cu b/aten/src/ATen/native/cuda/airy_ai.cu
index 35e6b00226..8e6dfa7fe3 100644
--- a/aten/src/ATen/native/cuda/airy_ai.cu
+++ b/aten/src/ATen/native/cuda/airy_ai.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 CONSTEXPR_EXCEPT_WIN_CUDA char airy_ai_name[] = "airy_ai_forward";
 
@@ -39,4 +39,4 @@ void airy_ai_kernel_cuda(TensorIteratorBase& iterator) {
 } // anonymous namespace
 
 REGISTER_DISPATCH(special_airy_ai_stub, &airy_ai_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/bessel_j0.cu b/aten/src/ATen/native/cuda/bessel_j0.cu
index 2ebfe676e5..079fa158a1 100644
--- a/aten/src/ATen/native/cuda/bessel_j0.cu
+++ b/aten/src/ATen/native/cuda/bessel_j0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 CONSTEXPR_EXCEPT_WIN_CUDA char bessel_j0_name[] = "bessel_j0_forward";
 
@@ -39,4 +39,4 @@ void bessel_j0_kernel_cuda(TensorIteratorBase& iterator) {
 } // anonymous namespace
 
 REGISTER_DISPATCH(special_bessel_j0_stub, &bessel_j0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/bessel_j1.cu b/aten/src/ATen/native/cuda/bessel_j1.cu
index 42bd43321f..4b03582f60 100644
--- a/aten/src/ATen/native/cuda/bessel_j1.cu
+++ b/aten/src/ATen/native/cuda/bessel_j1.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 CONSTEXPR_EXCEPT_WIN_CUDA char bessel_j1_name[] = "bessel_j1_forward";
 
@@ -39,4 +39,4 @@ void bessel_j1_kernel_cuda(TensorIteratorBase& iterator) {
 } // anonymous namespace
 
 REGISTER_DISPATCH(special_bessel_j1_stub, &bessel_j1_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/bessel_y0.cu b/aten/src/ATen/native/cuda/bessel_y0.cu
index 631031d4e2..6f5273de0b 100644
--- a/aten/src/ATen/native/cuda/bessel_y0.cu
+++ b/aten/src/ATen/native/cuda/bessel_y0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char bessel_y0_name[] = "bessel_y0_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_bessel_y0_stub, &bessel_y0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/bessel_y1.cu b/aten/src/ATen/native/cuda/bessel_y1.cu
index 1375061e43..f79873297d 100644
--- a/aten/src/ATen/native/cuda/bessel_y1.cu
+++ b/aten/src/ATen/native/cuda/bessel_y1.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char bessel_y1_name[] = "bessel_y1_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_bessel_y1_stub, &bessel_y1_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/chebyshev_polynomial_t.cu b/aten/src/ATen/native/cuda/chebyshev_polynomial_t.cu
index 7736d20e01..0da94ae5ce 100644
--- a/aten/src/ATen/native/cuda/chebyshev_polynomial_t.cu
+++ b/aten/src/ATen/native/cuda/chebyshev_polynomial_t.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char chebyshev_polynomial_t_name[] = "chebyshev_polynomial_t_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(chebyshev_polynomial_t_stub, &chebyshev_polynomial_t_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/chebyshev_polynomial_u.cu b/aten/src/ATen/native/cuda/chebyshev_polynomial_u.cu
index 412479e11f..9b87685278 100644
--- a/aten/src/ATen/native/cuda/chebyshev_polynomial_u.cu
+++ b/aten/src/ATen/native/cuda/chebyshev_polynomial_u.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char chebyshev_polynomial_u_name[] = "chebyshev_polynomial_u_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(chebyshev_polynomial_u_stub, &chebyshev_polynomial_u_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/chebyshev_polynomial_v.cu b/aten/src/ATen/native/cuda/chebyshev_polynomial_v.cu
index ca2e534e64..72e4fc687e 100644
--- a/aten/src/ATen/native/cuda/chebyshev_polynomial_v.cu
+++ b/aten/src/ATen/native/cuda/chebyshev_polynomial_v.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char chebyshev_polynomial_v_name[] = "chebyshev_polynomial_v_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(chebyshev_polynomial_v_stub, &chebyshev_polynomial_v_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/chebyshev_polynomial_w.cu b/aten/src/ATen/native/cuda/chebyshev_polynomial_w.cu
index 9d5a0e3a7b..f2c8d2c2b7 100644
--- a/aten/src/ATen/native/cuda/chebyshev_polynomial_w.cu
+++ b/aten/src/ATen/native/cuda/chebyshev_polynomial_w.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char chebyshev_polynomial_w_name[] = "chebyshev_polynomial_w_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(chebyshev_polynomial_w_stub, &chebyshev_polynomial_w_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/fused_adam_amsgrad_impl.cu b/aten/src/ATen/native/cuda/fused_adam_amsgrad_impl.cu
index 6655c4f6d2..7d44342022 100644
--- a/aten/src/ATen/native/cuda/fused_adam_amsgrad_impl.cu
+++ b/aten/src/ATen/native/cuda/fused_adam_amsgrad_impl.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/cuda/MultiTensorApply.cuh>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void _fused_adam_amsgrad_cuda_impl_(
     at::TensorList params,
@@ -95,4 +95,4 @@ void _fused_adam_amsgrad_cuda_impl_(
         });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/fused_adam_impl.cu b/aten/src/ATen/native/cuda/fused_adam_impl.cu
index b83c2804b0..210dedb973 100644
--- a/aten/src/ATen/native/cuda/fused_adam_impl.cu
+++ b/aten/src/ATen/native/cuda/fused_adam_impl.cu
@@ -6,7 +6,7 @@
 #include <ATen/native/cuda/MultiTensorApply.cuh>
 #include <vector>
 
-namespace at::native {
+namespace at{ namespace native {
 
 void _fused_adam_cuda_impl_(
     at::TensorList params,
@@ -93,4 +93,4 @@ void _fused_adam_cuda_impl_(
         });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/group_norm_kernel.cu b/aten/src/ATen/native/cuda/group_norm_kernel.cu
index 5a29338c30..923cf13800 100644
--- a/aten/src/ATen/native/cuda/group_norm_kernel.cu
+++ b/aten/src/ATen/native/cuda/group_norm_kernel.cu
@@ -21,7 +21,7 @@
 #include <ATen/ops/empty.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -993,4 +993,4 @@ void GroupNormBackwardKernelImpl(
 REGISTER_DISPATCH(GroupNormKernel, &GroupNormKernelImpl);
 REGISTER_DISPATCH(GroupNormBackwardKernel, &GroupNormBackwardKernelImpl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/hermite_polynomial_h.cu b/aten/src/ATen/native/cuda/hermite_polynomial_h.cu
index f53253bcd0..448f060af1 100644
--- a/aten/src/ATen/native/cuda/hermite_polynomial_h.cu
+++ b/aten/src/ATen/native/cuda/hermite_polynomial_h.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char hermite_polynomial_h_name[] = "hermite_polynomial_h_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(hermite_polynomial_h_stub, &hermite_polynomial_h_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/hermite_polynomial_he.cu b/aten/src/ATen/native/cuda/hermite_polynomial_he.cu
index bab3765658..112d515c5d 100644
--- a/aten/src/ATen/native/cuda/hermite_polynomial_he.cu
+++ b/aten/src/ATen/native/cuda/hermite_polynomial_he.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char hermite_polynomial_he_name[] = "hermite_polynomial_he_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(hermite_polynomial_he_stub, &hermite_polynomial_he_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/int4mm.cu b/aten/src/ATen/native/cuda/int4mm.cu
index 07a70013b2..3d7ea1c3ec 100644
--- a/aten/src/ATen/native/cuda/int4mm.cu
+++ b/aten/src/ATen/native/cuda/int4mm.cu
@@ -11,7 +11,7 @@
 #include <c10/cuda/CUDAGuard.h>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename U, typename V>
 constexpr __host__ __device__ auto divDown(U a, V b) -> decltype(a + b) {
@@ -1095,4 +1095,4 @@ at::Tensor _convert_weight_to_int4pack_cuda(
 }
 
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/jit_utils.cpp b/aten/src/ATen/native/cuda/jit_utils.cpp
index 61781e03b4..cb22e851ce 100644
--- a/aten/src/ATen/native/cuda/jit_utils.cpp
+++ b/aten/src/ATen/native/cuda/jit_utils.cpp
@@ -38,7 +38,7 @@
 #endif
 
 
-namespace at::cuda::jit {
+namespace at{ namespace cuda{ namespace jit {
 
 // hiprtc already includes some traits, so this removes duplicate definitions of
 // integral_constant, is_same, is_integral, enable_if, is_floating_point, is_arithmetic.
@@ -1656,4 +1656,4 @@ void launch_jitted_pwise_function(
     nullptr));
 }
 
-} // at::cuda::jit
+}}} // at::cuda::jit
diff --git a/aten/src/ATen/native/cuda/laguerre_polynomial_l.cu b/aten/src/ATen/native/cuda/laguerre_polynomial_l.cu
index a98336dfcb..d2913c283e 100644
--- a/aten/src/ATen/native/cuda/laguerre_polynomial_l.cu
+++ b/aten/src/ATen/native/cuda/laguerre_polynomial_l.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char laguerre_polynomial_l_name[] = "laguerre_polynomial_l_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(laguerre_polynomial_l_stub, &laguerre_polynomial_l_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/layer_norm_kernel.cu b/aten/src/ATen/native/cuda/layer_norm_kernel.cu
index 45b9717fbe..419462e71e 100644
--- a/aten/src/ATen/native/cuda/layer_norm_kernel.cu
+++ b/aten/src/ATen/native/cuda/layer_norm_kernel.cu
@@ -28,7 +28,7 @@
 #include <c10/util/env.h>
 
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -1459,4 +1459,4 @@ std::tuple<Tensor, Tensor, Tensor> layer_norm_backward_cuda(
 REGISTER_DISPATCH(LayerNormKernel, &LayerNormKernelImpl);
 REGISTER_DISPATCH(LayerNormBackwardKernel, &LayerNormBackwardKernelImpl);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/legendre_polynomial_p.cu b/aten/src/ATen/native/cuda/legendre_polynomial_p.cu
index 9f5efc9b45..8a22b74193 100644
--- a/aten/src/ATen/native/cuda/legendre_polynomial_p.cu
+++ b/aten/src/ATen/native/cuda/legendre_polynomial_p.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             const char legendre_polynomial_p_name[] = "legendre_polynomial_p_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(legendre_polynomial_p_stub, &legendre_polynomial_p_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebra.cpp b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebra.cpp
index a08547dc21..764ccae981 100644
--- a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebra.cpp
+++ b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebra.cpp
@@ -66,7 +66,7 @@ const bool use_magma_ = false;
 
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 #if defined(BUILD_LAZY_CUDA_LINALG)
 // All registrations with PyTorch runtime should be done dynamically
 // so if library is lazy loaded it must not export anything, otherwise
@@ -2774,6 +2774,6 @@ struct DispatchInitializer {
 
 }  // namespace lazy_linalg
 #endif
-}  // namespace at::native
+}}  // namespace at::native
 
 #undef ALLOCATE_ARRAY
diff --git a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLib.cpp b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLib.cpp
index ec65435d6c..d5799455da 100644
--- a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLib.cpp
+++ b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLib.cpp
@@ -28,7 +28,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static cublasOperation_t to_cublas(TransposeType trans) {
   switch (trans) {
@@ -1540,4 +1540,4 @@ void lu_solve_looped_cusolver(const Tensor& LU, const Tensor& pivots, const Tens
 
 #endif  // USE_LINALG_SOLVER
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLibBlas.cpp b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLibBlas.cpp
index 38e7b8dd32..1dc20e01ab 100644
--- a/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLibBlas.cpp
+++ b/aten/src/ATen/native/cuda/linalg/BatchLinearAlgebraLibBlas.cpp
@@ -46,7 +46,7 @@
 #include <ATen/ops/zeros.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static cublasOperation_t to_cublas(TransposeType trans) {
   switch (trans) {
@@ -284,4 +284,4 @@ void gels_batched_cublas(const Tensor& a, Tensor& b, Tensor& infos) {
   });
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/modified_bessel_i0.cu b/aten/src/ATen/native/cuda/modified_bessel_i0.cu
index 9f1f3ba98c..01a8688d3e 100644
--- a/aten/src/ATen/native/cuda/modified_bessel_i0.cu
+++ b/aten/src/ATen/native/cuda/modified_bessel_i0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char modified_bessel_i0_name[] = "modified_bessel_i0_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_modified_bessel_i0_stub, &modified_bessel_i0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/modified_bessel_i1.cu b/aten/src/ATen/native/cuda/modified_bessel_i1.cu
index d51e7fefb0..8592f8097f 100644
--- a/aten/src/ATen/native/cuda/modified_bessel_i1.cu
+++ b/aten/src/ATen/native/cuda/modified_bessel_i1.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char modified_bessel_i1_name[] = "modified_bessel_i1_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_modified_bessel_i1_stub, &modified_bessel_i1_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/modified_bessel_k0.cu b/aten/src/ATen/native/cuda/modified_bessel_k0.cu
index 574268456c..7973583ed9 100644
--- a/aten/src/ATen/native/cuda/modified_bessel_k0.cu
+++ b/aten/src/ATen/native/cuda/modified_bessel_k0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char modified_bessel_k0_name[] = "modified_bessel_k0_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_modified_bessel_k0_stub, &modified_bessel_k0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/modified_bessel_k1.cu b/aten/src/ATen/native/cuda/modified_bessel_k1.cu
index b3720d8e1b..3a6c0fde2e 100644
--- a/aten/src/ATen/native/cuda/modified_bessel_k1.cu
+++ b/aten/src/ATen/native/cuda/modified_bessel_k1.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char modified_bessel_k1_name[] = "modified_bessel_k1_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_modified_bessel_k1_stub, &modified_bessel_k1_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/scaled_modified_bessel_k0.cu b/aten/src/ATen/native/cuda/scaled_modified_bessel_k0.cu
index ac2355e409..56ab0b8887 100644
--- a/aten/src/ATen/native/cuda/scaled_modified_bessel_k0.cu
+++ b/aten/src/ATen/native/cuda/scaled_modified_bessel_k0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char scaled_modified_bessel_k0_name[] = "scaled_modified_bessel_k0_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_scaled_modified_bessel_k0_stub, &scaled_modified_bessel_k0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/scaled_modified_bessel_k1.cu b/aten/src/ATen/native/cuda/scaled_modified_bessel_k1.cu
index b1d8d2a41b..1abd831074 100644
--- a/aten/src/ATen/native/cuda/scaled_modified_bessel_k1.cu
+++ b/aten/src/ATen/native/cuda/scaled_modified_bessel_k1.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char scaled_modified_bessel_k1_name[] = "scaled_modified_bessel_k1_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_scaled_modified_bessel_k1_stub, &scaled_modified_bessel_k1_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_t.cu b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_t.cu
index d86042030c..b0e8bc3234 100644
--- a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_t.cu
+++ b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_t.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char shifted_chebyshev_polynomial_t_name[] = "shifted_chebyshev_polynomial_t_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(shifted_chebyshev_polynomial_t_stub, &shifted_chebyshev_polynomial_t_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_u.cu b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_u.cu
index a2e2cd485f..1810ebdc94 100644
--- a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_u.cu
+++ b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_u.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char shifted_chebyshev_polynomial_u_name[] = "shifted_chebyshev_polynomial_u_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(shifted_chebyshev_polynomial_u_stub, &shifted_chebyshev_polynomial_u_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_v.cu b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_v.cu
index 6e5404179a..4d76cf9a41 100644
--- a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_v.cu
+++ b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_v.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 CONSTEXPR_EXCEPT_WIN_CUDA char shifted_chebyshev_polynomial_v_name[] = "shifted_chebyshev_polynomial_v_forward";
 
@@ -29,4 +29,4 @@ void shifted_chebyshev_polynomial_v_kernel_cuda(TensorIteratorBase& iterator) {
 } // namespace (anonymous)
 
 REGISTER_DISPATCH(shifted_chebyshev_polynomial_v_stub, &shifted_chebyshev_polynomial_v_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_w.cu b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_w.cu
index 3bfee57d14..29bb783c6f 100644
--- a/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_w.cu
+++ b/aten/src/ATen/native/cuda/shifted_chebyshev_polynomial_w.cu
@@ -8,7 +8,7 @@
 #include <ATen/native/cuda/Math.cuh>
 #include <ATen/native/cuda/jit_utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char shifted_chebyshev_polynomial_w_name[] = "shifted_chebyshev_polynomial_w_forward";
 
@@ -28,4 +28,4 @@ namespace at::native {
         } // namespace (anonymous)
 
         REGISTER_DISPATCH(shifted_chebyshev_polynomial_w_stub, &shifted_chebyshev_polynomial_w_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/cuda/spherical_bessel_j0.cu b/aten/src/ATen/native/cuda/spherical_bessel_j0.cu
index d0bf46e653..e4ef7051a2 100644
--- a/aten/src/ATen/native/cuda/spherical_bessel_j0.cu
+++ b/aten/src/ATen/native/cuda/spherical_bessel_j0.cu
@@ -18,7 +18,7 @@
 #include <c10/cuda/CUDAMathCompat.h>
 #include <c10/util/complex.h>
 
-namespace at::native {
+namespace at{ namespace native {
         namespace {
             CONSTEXPR_EXCEPT_WIN_CUDA char spherical_bessel_j0_name[] = "spherical_bessel_j0_forward";
 
@@ -38,4 +38,4 @@ namespace at::native {
         }
 
         REGISTER_DISPATCH(special_spherical_bessel_j0_stub, &spherical_bessel_j0_kernel_cuda);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/im2col.h b/aten/src/ATen/native/im2col.h
index df94723ab2..485f8436b9 100644
--- a/aten/src/ATen/native/im2col.h
+++ b/aten/src/ATen/native/im2col.h
@@ -9,7 +9,7 @@
 
 #include <algorithm>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T>
 static void im2col(
@@ -146,4 +146,4 @@ static void col2im(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/im2col_shape_check.h b/aten/src/ATen/native/im2col_shape_check.h
index f7ae0854f7..dd5c9ef783 100644
--- a/aten/src/ATen/native/im2col_shape_check.h
+++ b/aten/src/ATen/native/im2col_shape_check.h
@@ -3,7 +3,7 @@
 #include <ATen/TensorUtils.h>
 #include <ATen/div_rtn.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static inline void col2im_shape_check(
     const Tensor& input,
@@ -229,4 +229,4 @@ static inline void im2col_shape_check(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/layer_norm.h b/aten/src/ATen/native/layer_norm.h
index 13fb1e4783..63a19e46e9 100644
--- a/aten/src/ATen/native/layer_norm.h
+++ b/aten/src/ATen/native/layer_norm.h
@@ -4,7 +4,7 @@
 #include <ATen/native/DispatchStub.h>
 #include <c10/util/accumulate.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -97,4 +97,4 @@ using backward_fn = void (*)(
 DECLARE_DISPATCH(forward_fn, LayerNormKernel);
 DECLARE_DISPATCH(backward_fn, LayerNormBackwardKernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mkldnn/IDeepRegistration.cpp b/aten/src/ATen/native/mkldnn/IDeepRegistration.cpp
index 5977b04595..4c007d47cb 100644
--- a/aten/src/ATen/native/mkldnn/IDeepRegistration.cpp
+++ b/aten/src/ATen/native/mkldnn/IDeepRegistration.cpp
@@ -19,7 +19,7 @@ RegisterEngineAllocator cpu_alloc(
   }
 );
 
-namespace at::native::mkldnn{
+namespace at{ namespace native { namespace mkldnn{
 void clear_computation_cache();
 
 void clear_computation_cache() {
@@ -28,6 +28,6 @@ void clear_computation_cache() {
   ideep::convolution_forward::t_store().clear();
 }
 
-} // namespace  at::native::mkldnn
+}}} // namespace  at::native::mkldnn
 
 #endif // AT_MKLDNN_ENALBED()
diff --git a/aten/src/ATen/native/mkldnn/RNN.cpp b/aten/src/ATen/native/mkldnn/RNN.cpp
index a5effcc0ce..b428baa4cd 100644
--- a/aten/src/ATen/native/mkldnn/RNN.cpp
+++ b/aten/src/ATen/native/mkldnn/RNN.cpp
@@ -21,7 +21,7 @@
 
 #if !AT_MKLDNN_ENABLED()
 
-namespace at::native {
+namespace at{ namespace native {
 
 
 std::tuple<Tensor, Tensor, Tensor, Tensor> mkldnn_rnn_layer(
@@ -73,14 +73,14 @@ std::tuple<Tensor, Tensor, Tensor, Tensor, Tensor, Tensor, Tensor> mkldnn_rnn_la
 
 REGISTER_NO_CPU_DISPATCH(lstm_mkldnn_stub);
 
-} // namespace at::native
+}} // namespace at::native
 
 #else // AT_MKLDNN_EBABLED
 
 #include <ATen/native/mkldnn/MKLDNNCommon.h>
 #include <ATen/native/mkldnn/Utils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 struct RNNParams {
   ideep::rnn_kind mode;
@@ -567,6 +567,6 @@ void lstm_mkldnn(Tensor& output, Tensor& hy, Tensor& cy,
 
 REGISTER_ALL_CPU_DISPATCH(lstm_mkldnn_stub, &lstm_mkldnn);
 
-} // namespace at::native
+}} // namespace at::native
 
 #endif // AT_MKLDNN_EBABLED
diff --git a/aten/src/ATen/native/mps/OperationUtils.h b/aten/src/ATen/native/mps/OperationUtils.h
index 34ca4186a6..7da22a86f3 100644
--- a/aten/src/ATen/native/mps/OperationUtils.h
+++ b/aten/src/ATen/native/mps/OperationUtils.h
@@ -27,7 +27,7 @@
 
 using namespace at::mps;
 
-namespace at::native::mps {
+namespace at{ namespace native { namespace mps {
 
 void dispatch_sync_with_rethrow(dispatch_queue_t queue, void (^block)());
 
@@ -323,4 +323,4 @@ inline bool is_dense_in_storage(const at::Tensor& t) {
   return compute_storage_numel_distance(t) == static_cast<size_t>(t.numel());
 }
 
-} // namespace at::native::mps
+}}} // namespace at::native::mps
diff --git a/aten/src/ATen/native/mps/OperationUtils.mm b/aten/src/ATen/native/mps/OperationUtils.mm
index 7972cc3148..c7404a0925 100644
--- a/aten/src/ATen/native/mps/OperationUtils.mm
+++ b/aten/src/ATen/native/mps/OperationUtils.mm
@@ -11,7 +11,7 @@
 #include <ATen/ops/scalar_tensor.h>
 #endif
 
-namespace at::native::mps {
+namespace at{ namespace native { namespace mps {
 
 void dispatch_sync_with_rethrow(dispatch_queue_t queue, void (^block)()) {
   __block std::optional<std::exception_ptr> block_exception;
@@ -527,4 +527,4 @@ void executeMPSAllocatorCallback(void* ptr, EventType event) override {}
 
 REGISTER_MPS_ALLOCATOR_CALLBACK("mps_graph_cache_callback", MPSGraphCacheCallback);
 
-} // namespace at::native::mps
+}}} // namespace at::native::mps
diff --git a/aten/src/ATen/native/mps/TensorFactory.cpp b/aten/src/ATen/native/mps/TensorFactory.cpp
index 6fe145a6cc..0b23b1d9e2 100644
--- a/aten/src/ATen/native/mps/TensorFactory.cpp
+++ b/aten/src/ATen/native/mps/TensorFactory.cpp
@@ -18,7 +18,7 @@
 #endif
 #include <ATen/ops/_efficientzerotensor_native.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static inline void maybe_resize_storage_mps(TensorImpl* self, uint64_t new_size) {
   if (new_size == 0) {
@@ -161,4 +161,4 @@ Tensor _efficientzerotensor_mps(IntArrayRef size,
     return out;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Activation.mm b/aten/src/ATen/native/mps/operations/Activation.mm
index a8ac52c2ec..47e30b6a11 100644
--- a/aten/src/ATen/native/mps/operations/Activation.mm
+++ b/aten/src/ATen/native/mps/operations/Activation.mm
@@ -47,7 +47,7 @@
 
 using namespace at::mps;
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor relu_mps(const Tensor& self) {
   using namespace mps;
@@ -2230,4 +2230,4 @@ Tensor hardswish_backward_mps(const Tensor& grad_output, const Tensor& self) {
   }
   return grad_input;
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/AdaptivePooling.mm b/aten/src/ATen/native/mps/operations/AdaptivePooling.mm
index c88d468f7e..bd73235d3b 100644
--- a/aten/src/ATen/native/mps/operations/AdaptivePooling.mm
+++ b/aten/src/ATen/native/mps/operations/AdaptivePooling.mm
@@ -20,7 +20,7 @@
 #include <ATen/ops/mul.h>
 #include <ATen/ops/ones_like.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 static void set_kernel_params(int64_t isizeH,
                               int64_t isizeW,
@@ -233,4 +233,4 @@ Tensor adaptive_avg_pool2d_backward_mps(const Tensor& gradOutput, const Tensor&
                                            indices);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/BinaryKernel.h b/aten/src/ATen/native/mps/operations/BinaryKernel.h
index d22c22a190..f60374fba0 100644
--- a/aten/src/ATen/native/mps/operations/BinaryKernel.h
+++ b/aten/src/ATen/native/mps/operations/BinaryKernel.h
@@ -1,5 +1,5 @@
 #pragma once
 
-namespace at::native::mps {
+namespace at{ namespace native { namespace mps {
 void complex_mul_out(const Tensor& input, const Tensor& other, const Tensor& output);
-}
+}}}
diff --git a/aten/src/ATen/native/mps/operations/BinaryKernel.mm b/aten/src/ATen/native/mps/operations/BinaryKernel.mm
index 5185968717..7ebc7d1ca6 100644
--- a/aten/src/ATen/native/mps/operations/BinaryKernel.mm
+++ b/aten/src/ATen/native/mps/operations/BinaryKernel.mm
@@ -18,7 +18,7 @@
 #include <ATen/ops/view_as_real.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 static const char* METAL_BINARY = R"BINARY_METAL(
@@ -401,4 +401,4 @@ static void nextafter_mps_kernel(TensorIteratorBase& iter) {
   mps::binary_mps_impl(iter, "polar");
   return output;
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/BinaryOps.mm b/aten/src/ATen/native/mps/operations/BinaryOps.mm
index 4c96954ef4..ffca37f285 100644
--- a/aten/src/ATen/native/mps/operations/BinaryOps.mm
+++ b/aten/src/ATen/native/mps/operations/BinaryOps.mm
@@ -40,7 +40,7 @@
 #include <ATen/ops/xlogy_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct BinaryOpCachedGraph : public MPSCachedGraph {
@@ -536,4 +536,4 @@ Tensor floor_divide_mps(const Tensor& self, const Tensor& other) {
 TORCH_IMPL_FUNC(lerp_Scalar_mps)(const Tensor& self, const Tensor& end, const Scalar& weight, const Tensor& out) {
   mps::add_sub_lerp_template(self, end, weight, out, "lerp");
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/BitwiseOps.mm b/aten/src/ATen/native/mps/operations/BitwiseOps.mm
index 6cef504f07..0c09a5549d 100644
--- a/aten/src/ATen/native/mps/operations/BitwiseOps.mm
+++ b/aten/src/ATen/native/mps/operations/BitwiseOps.mm
@@ -10,7 +10,7 @@
 #include <ATen/ops/logical_not_native.h>
 #include <fmt/format.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 static const char* BITWISE_OPS_TEMPLATE = R"METAL(
 
@@ -353,4 +353,4 @@ static void _bitwise_not_out_mps(const Tensor& self, const Tensor& output_) {
 TORCH_IMPL_FUNC(bitwise_not_out_mps)(const Tensor& self, const Tensor& output) {
   mps::_bitwise_not_out_mps(self, output);
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Blas.mm b/aten/src/ATen/native/mps/operations/Blas.mm
index 74cc252ddb..48c805d67b 100644
--- a/aten/src/ATen/native/mps/operations/Blas.mm
+++ b/aten/src/ATen/native/mps/operations/Blas.mm
@@ -16,7 +16,7 @@
 #include <MetalPerformanceShaders/MetalPerformanceShaders.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace mps {
 
@@ -207,4 +207,4 @@ Tensor dot_mps(const Tensor& self, const Tensor& other) {
   addmv_out_mps_impl(self, mat, vec, beta_, alpha_, const_cast<Tensor&>(result));
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Bucketization.mm b/aten/src/ATen/native/mps/operations/Bucketization.mm
index 6f32f47d6e..db1f67e72a 100644
--- a/aten/src/ATen/native/mps/operations/Bucketization.mm
+++ b/aten/src/ATen/native/mps/operations/Bucketization.mm
@@ -14,7 +14,7 @@
 #include <ATen/ops/searchsorted_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 static const char* METAL_BUCKETIZATION = R"BUCKETIZE_METAL(
@@ -392,4 +392,4 @@ Tensor bucketize_mps(const Scalar& self, const Tensor& boundaries, bool out_int3
   return bucketize_mps(mps::wrapped_scalar_tensor_mps(self, boundaries.device()), boundaries, out_int32, right);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/ConstantOps.mm b/aten/src/ATen/native/mps/operations/ConstantOps.mm
index 52c74c3637..512f8eaac7 100644
--- a/aten/src/ATen/native/mps/operations/ConstantOps.mm
+++ b/aten/src/ATen/native/mps/operations/ConstantOps.mm
@@ -11,7 +11,7 @@
 #include <ATen/ops/zero_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static Tensor& fill_scalar_mps_impl(Tensor& self, const Scalar& value) {
   using namespace mps;
@@ -122,4 +122,4 @@ static bool fill_mps_tensor_(Tensor& self, uint8_t value) {
   return fill_scalar_mps(self, 0.0f);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Convolution.mm b/aten/src/ATen/native/mps/operations/Convolution.mm
index 625df25bc1..190c8cc328 100644
--- a/aten/src/ATen/native/mps/operations/Convolution.mm
+++ b/aten/src/ATen/native/mps/operations/Convolution.mm
@@ -7,7 +7,7 @@
 #include <ATen/ops/mps_convolution_backward_native.h>
 #include <ATen/ops/mps_convolution_transpose_backward_native.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static void fill_depthwise_conv_desc(MPSGraphDepthwiseConvolution3DOpDescriptor* descriptor_,
                                      NSUInteger strideInX,
@@ -626,4 +626,4 @@ static Tensor mps_convolution_transpose_backward_weight(IntArrayRef weight_size,
   return std::tuple<Tensor, Tensor>{grad_input, grad_weight};
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Copy.mm b/aten/src/ATen/native/mps/operations/Copy.mm
index 8b1dd402e4..23f9d1b96d 100644
--- a/aten/src/ATen/native/mps/operations/Copy.mm
+++ b/aten/src/ATen/native/mps/operations/Copy.mm
@@ -6,7 +6,7 @@
 #include <ATen/ops/_copy_from_and_resize_native.h>
 #include <ATen/ops/_copy_from_native.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 static void* pageAlignedBlockPtr(const void* ptr, NSUInteger size, NSUInteger* alignedBlockSize) {
@@ -331,4 +331,4 @@ Tensor _copy_from_mps(const at::Tensor& self, const at::Tensor& dst, bool non_bl
   return mps::mps_copy_(const_cast<Tensor&>(dst), self, non_blocking);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/CrossKernel.mm b/aten/src/ATen/native/mps/operations/CrossKernel.mm
index f681901b83..e5923aeaee 100644
--- a/aten/src/ATen/native/mps/operations/CrossKernel.mm
+++ b/aten/src/ATen/native/mps/operations/CrossKernel.mm
@@ -5,7 +5,7 @@
 #include <ATen/native/Cross.h>
 #include <ATen/native/mps/OperationUtils.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static const char* METAL_CROSS = R"CROSS_METAL(
@@ -202,4 +202,4 @@ void cross_mps_impl(const Tensor& out, const Tensor& input, const Tensor& other,
 } // anonymous namespace
 
 REGISTER_DISPATCH(cross_stub, &cross_mps_impl);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Distributions.mm b/aten/src/ATen/native/mps/operations/Distributions.mm
index deac6b61a7..ffedad54fd 100644
--- a/aten/src/ATen/native/mps/operations/Distributions.mm
+++ b/aten/src/ATen/native/mps/operations/Distributions.mm
@@ -26,7 +26,7 @@
 #include <ATen/ops/uniform_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct RandomCachedGraph : public MPSCachedGraph {
@@ -642,4 +642,4 @@ Tensor multinomial_mps(const Tensor& self, int64_t n_sample, bool with_replaceme
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Eye.mm b/aten/src/ATen/native/mps/operations/Eye.mm
index bdbb361a8a..1696b09bdb 100644
--- a/aten/src/ATen/native/mps/operations/Eye.mm
+++ b/aten/src/ATen/native/mps/operations/Eye.mm
@@ -29,7 +29,7 @@
 //    g) Then call runMPSGraph() with input params and return the result.
 //
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor& eye_out_mps(int64_t n, Tensor& result) {
   // the default value of `m` equals to `n`
@@ -109,4 +109,4 @@
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Gamma.mm b/aten/src/ATen/native/mps/operations/Gamma.mm
index bf914cbdba..ab26a6db24 100644
--- a/aten/src/ATen/native/mps/operations/Gamma.mm
+++ b/aten/src/ATen/native/mps/operations/Gamma.mm
@@ -9,7 +9,7 @@
 #include <ATen/ops/lgamma_native.h>
 #include <ATen/ops/polygamma_native.h>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 /*
@@ -594,4 +594,4 @@ static void dispatch1DJob(id<MTLComputeCommandEncoder> commandEncoder,
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/GridSampler.mm b/aten/src/ATen/native/mps/operations/GridSampler.mm
index fc775333b6..0a13cf0902 100644
--- a/aten/src/ATen/native/mps/operations/GridSampler.mm
+++ b/aten/src/ATen/native/mps/operations/GridSampler.mm
@@ -11,7 +11,7 @@
 #include <ATen/ops/grid_sampler_2d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 static void grid_sampler_2d_mps_impl(Tensor& output,
                                      const Tensor& input,
@@ -150,4 +150,4 @@ Tensor grid_sampler_2d_mps(const Tensor& input,
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/HistogramKernel.mm b/aten/src/ATen/native/mps/operations/HistogramKernel.mm
index b1efb0ca08..e51ba5da6c 100644
--- a/aten/src/ATen/native/mps/operations/HistogramKernel.mm
+++ b/aten/src/ATen/native/mps/operations/HistogramKernel.mm
@@ -12,7 +12,7 @@
 #include <ATen/ops/sum.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 enum BIN_SELECTION_ALGORITHM {
@@ -413,4 +413,4 @@ static void histogram_select_outer_bin_edges_kernel(const Tensor& input,
 REGISTER_DISPATCH(histogramdd_stub, &histogramdd_kernel);
 REGISTER_DISPATCH(histogramdd_linear_stub, &histogramdd_linear_kernel);
 REGISTER_DISPATCH(histogram_select_outer_bin_edges_stub, &histogram_select_outer_bin_edges_kernel);
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Indexing.mm b/aten/src/ATen/native/mps/operations/Indexing.mm
index 397722f77f..9532e20530 100644
--- a/aten/src/ATen/native/mps/operations/Indexing.mm
+++ b/aten/src/ATen/native/mps/operations/Indexing.mm
@@ -45,7 +45,7 @@
 #include <MetalPerformanceShaders/MetalPerformanceShaders.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 static std::string getBitSizeString(ScalarType scalar_type) {
   size_t scalarBitSize = c10::elementSize(scalar_type) * 8;
diff --git a/aten/src/ATen/native/mps/operations/Inverse.mm b/aten/src/ATen/native/mps/operations/Inverse.mm
index 8081e84a2c..7e3a6f1b73 100644
--- a/aten/src/ATen/native/mps/operations/Inverse.mm
+++ b/aten/src/ATen/native/mps/operations/Inverse.mm
@@ -62,4 +62,4 @@
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Lerp.mm b/aten/src/ATen/native/mps/operations/Lerp.mm
index ca674336a9..3f5f385e05 100644
--- a/aten/src/ATen/native/mps/operations/Lerp.mm
+++ b/aten/src/ATen/native/mps/operations/Lerp.mm
@@ -9,10 +9,10 @@
 #include <ATen/ops/lerp_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 TORCH_IMPL_FUNC(lerp_Tensor_mps)(const Tensor& self, const Tensor& end, const Tensor& weight, const Tensor& out) {
   // TODO: Write a much better implementation
   at::add_out(const_cast<Tensor&>(out), self, weight.mul(end.sub(self)));
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Linear.mm b/aten/src/ATen/native/mps/operations/Linear.mm
index 4e556189b0..90b5da932f 100644
--- a/aten/src/ATen/native/mps/operations/Linear.mm
+++ b/aten/src/ATen/native/mps/operations/Linear.mm
@@ -5,7 +5,7 @@
 #include <ATen/ops/linear_backward_native.h>
 #include <ATen/ops/linear_native.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace mps;
 
@@ -304,4 +304,4 @@ static Tensor _mps_linear_backward_input(IntArrayRef input_size, const Tensor& g
   return std::tuple<Tensor, Tensor, Tensor>{grad_input, grad_weight, grad_bias};
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/LinearAlgebra.mm b/aten/src/ATen/native/mps/operations/LinearAlgebra.mm
index 9d86a90969..bcf908d616 100644
--- a/aten/src/ATen/native/mps/operations/LinearAlgebra.mm
+++ b/aten/src/ATen/native/mps/operations/LinearAlgebra.mm
@@ -20,7 +20,7 @@
 #include <ATen/ops/triangular_solve_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 /*
  * Helper functions to be used for mm/addmm for detecting the Transpositions
@@ -785,4 +785,4 @@ Tensor linalg_solve_triangular_mps(const Tensor& A, const Tensor& B, bool upper,
   result.copy_(out);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/LossOps.mm b/aten/src/ATen/native/mps/operations/LossOps.mm
index 5891e0864f..dde8e7a3f5 100644
--- a/aten/src/ATen/native/mps/operations/LossOps.mm
+++ b/aten/src/ATen/native/mps/operations/LossOps.mm
@@ -20,7 +20,7 @@
 #include <ATen/ops/smooth_l1_loss_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 static string reductionToString(int64_t reduction) {
@@ -1274,4 +1274,4 @@ Tensor nll_loss2d_backward_mps(const Tensor& grad_output,
   return grad_input;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Normalization.mm b/aten/src/ATen/native/mps/operations/Normalization.mm
index eb754ae597..2011ebc014 100644
--- a/aten/src/ATen/native/mps/operations/Normalization.mm
+++ b/aten/src/ATen/native/mps/operations/Normalization.mm
@@ -18,7 +18,7 @@
 #include <ATen/ops/native_layer_norm_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 static void get_shapes(MPSShape* input_shape_readonly,
                        NSMutableArray<NSNumber*>*& input_shape,
@@ -1163,4 +1163,4 @@ static string get_mem_string(c10::MemoryFormat memory_format) {
   return std::make_tuple(std::move(grad_input), std::move(grad_weight), std::move(grad_bias));
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Pad.mm b/aten/src/ATen/native/mps/operations/Pad.mm
index 377bbb236f..ca4c897e0f 100644
--- a/aten/src/ATen/native/mps/operations/Pad.mm
+++ b/aten/src/ATen/native/mps/operations/Pad.mm
@@ -21,7 +21,7 @@
 #include <ATen/ops/replication_pad3d_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 // Pad operations (1D/2D/3D forward and backward)
@@ -479,4 +479,4 @@ Tensor constant_pad_nd_mps(const Tensor& self, IntArrayRef pad, const Scalar& va
       output, self, pad, c10::nullopt, MPSGraphPaddingModeConstant, value.toDouble(), __func__);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/PixelShuffle.mm b/aten/src/ATen/native/mps/operations/PixelShuffle.mm
index 30e85bfde4..3157ce919c 100644
--- a/aten/src/ATen/native/mps/operations/PixelShuffle.mm
+++ b/aten/src/ATen/native/mps/operations/PixelShuffle.mm
@@ -5,7 +5,7 @@
 
 using namespace at::mps;
 
-namespace at::native {
+namespace at{ namespace native {
 
 static Tensor pixel_shuffle_helper(const Tensor& self, int64_t factor, bool upscale) {
   using namespace mps;
@@ -111,4 +111,4 @@ Tensor pixel_unshuffle_mps(const Tensor& self, int64_t downscale_factor) {
   return pixel_shuffle_helper(self, downscale_factor, /*upscale=*/false);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/PointwiseOps.mm b/aten/src/ATen/native/mps/operations/PointwiseOps.mm
index 364acb4323..4c344e62ce 100644
--- a/aten/src/ATen/native/mps/operations/PointwiseOps.mm
+++ b/aten/src/ATen/native/mps/operations/PointwiseOps.mm
@@ -9,7 +9,7 @@
 #include <ATen/ops/addcdiv_native.h>
 #include <ATen/ops/addcmul_native.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 // scope the MPS's internal methods to not expose them to at::native
 namespace mps {
 
@@ -106,4 +106,4 @@ static void addc_mul_div_out_mps(const Tensor& self,
   mps::addc_mul_div_out_mps(self, tensor1, tensor2, value, output, true, "addcdiv_out_mps");
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Pooling.mm b/aten/src/ATen/native/mps/operations/Pooling.mm
index 89d6a8a280..6cfa96355a 100644
--- a/aten/src/ATen/native/mps/operations/Pooling.mm
+++ b/aten/src/ATen/native/mps/operations/Pooling.mm
@@ -17,7 +17,7 @@
 #include <ATen/ops/max_pool2d_with_indices_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct PoolingCachedGraph : public MPSCachedGraph {
@@ -528,4 +528,4 @@ Tensor mps_max_pool2d_backward(const Tensor& grad_output,
                            "avg_pool2d_backward");
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/RangeFactories.mm b/aten/src/ATen/native/mps/operations/RangeFactories.mm
index 682679aa20..de8b8f5e3c 100644
--- a/aten/src/ATen/native/mps/operations/RangeFactories.mm
+++ b/aten/src/ATen/native/mps/operations/RangeFactories.mm
@@ -10,7 +10,7 @@
 #include <cmath>
 #include <limits>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 struct RangeCachedGraph : public mps::MPSCachedGraph {
@@ -271,4 +271,4 @@
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/ReduceOps.mm b/aten/src/ATen/native/mps/operations/ReduceOps.mm
index 5dd34a34b8..14cc20f124 100644
--- a/aten/src/ATen/native/mps/operations/ReduceOps.mm
+++ b/aten/src/ATen/native/mps/operations/ReduceOps.mm
@@ -37,7 +37,7 @@
 #include <ATen/ops/var_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 typedef MPSGraphTensor* (^NormOpBlock)(mps::MPSBinaryCachedGraph*, MPSGraphTensor*, MPSGraphTensor*);
 #define NormOpFn(graph, primary, secondary) \
@@ -1730,4 +1730,4 @@ static void median_out_mps(const Tensor& input_t,
   return std::tuple<Tensor&, Tensor&>{values, indices};
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/RenormKernel.mm b/aten/src/ATen/native/mps/operations/RenormKernel.mm
index 1c4453a830..b5751d75aa 100644
--- a/aten/src/ATen/native/mps/operations/RenormKernel.mm
+++ b/aten/src/ATen/native/mps/operations/RenormKernel.mm
@@ -12,7 +12,7 @@
 #include <ATen/ops/renorm_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 static const char* METAL_RENORM = R"RENORM_METAL(
@@ -137,4 +137,4 @@ void renorm_out_mps(const Tensor& self, const Scalar& p, int64_t dim, const Scal
 (const Tensor& self, const Scalar& p, int64_t dim, const Scalar& maxnorm, const Tensor& out) {
   renorm_out_mps(self, p, dim, maxnorm, out);
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Repeat.mm b/aten/src/ATen/native/mps/operations/Repeat.mm
index bf5c9d3e21..bd8780030f 100644
--- a/aten/src/ATen/native/mps/operations/Repeat.mm
+++ b/aten/src/ATen/native/mps/operations/Repeat.mm
@@ -14,7 +14,7 @@
 #include <MetalPerformanceShaders/MetalPerformanceShaders.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor permute_mps(const Tensor& self, IntArrayRef dims) {
   auto nDims = self.dim();
@@ -217,4 +217,4 @@ Tensor repeat_interleave_mps(const Tensor& repeat_, c10::optional<int64_t> outpu
   return output;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/RnnOps.mm b/aten/src/ATen/native/mps/operations/RnnOps.mm
index 56b6f3abad..024d4dbb8b 100644
--- a/aten/src/ATen/native/mps/operations/RnnOps.mm
+++ b/aten/src/ATen/native/mps/operations/RnnOps.mm
@@ -9,7 +9,7 @@
 #include <ATen/ops/lstm_mps_backward_native.h>
 #import <MetalPerformanceShadersGraph/MPSGraphRNNOps.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 static std::vector<long long> getTensorShape(MPSGraphTensor* mpsTensor) {
   std::vector<long long> output_dimensions = {};
@@ -771,4 +771,4 @@
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Scalar.mm b/aten/src/ATen/native/mps/operations/Scalar.mm
index f29cdf7a1c..60145c6325 100644
--- a/aten/src/ATen/native/mps/operations/Scalar.mm
+++ b/aten/src/ATen/native/mps/operations/Scalar.mm
@@ -11,7 +11,7 @@
 
 using namespace at::mps;
 
-namespace at::native {
+namespace at{ namespace native {
 
 Scalar _local_scalar_dense_mps(const Tensor& self) {
   Scalar r;
@@ -31,4 +31,4 @@ Scalar _local_scalar_dense_mps(const Tensor& self) {
   return r;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/ScatterGather.mm b/aten/src/ATen/native/mps/operations/ScatterGather.mm
index df6218054a..617793c369 100644
--- a/aten/src/ATen/native/mps/operations/ScatterGather.mm
+++ b/aten/src/ATen/native/mps/operations/ScatterGather.mm
@@ -11,7 +11,7 @@
 #include <ATen/ops/scatter_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 TORCH_IMPL_FUNC(gather_out_mps)
 (const Tensor& self_arg, int64_t dim, const Tensor& index, bool sparse_grad, const Tensor& output) {
@@ -350,4 +350,4 @@ static void scatter_mps_general(const Tensor& self_arg,
   scatter_mps_general(self, dim, index, src, output, "scatter_add_mps_out", "add");
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Shape.mm b/aten/src/ATen/native/mps/operations/Shape.mm
index e6148904ab..2e2b6e1efc 100644
--- a/aten/src/ATen/native/mps/operations/Shape.mm
+++ b/aten/src/ATen/native/mps/operations/Shape.mm
@@ -16,7 +16,7 @@
 #include <ATen/ops/topk_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 // Produces a shape with the `dim` dimension set to 0.
@@ -397,4 +397,4 @@ static void check_shape_except_dim(const Tensor& first, const Tensor& second, in
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/SoftMax.mm b/aten/src/ATen/native/mps/operations/SoftMax.mm
index 92531164fb..52825c83ba 100644
--- a/aten/src/ATen/native/mps/operations/SoftMax.mm
+++ b/aten/src/ATen/native/mps/operations/SoftMax.mm
@@ -15,7 +15,7 @@
 #include <ATen/ops/_softmax_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 static void get_shapes(MPSShape* input_shape_readonly,
                        NSMutableArray<NSNumber*>*& input_shape,
@@ -197,4 +197,4 @@ static void get_shapes(MPSShape* input_shape_readonly,
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Sort.mm b/aten/src/ATen/native/mps/operations/Sort.mm
index bb12aa657c..02acf97fe2 100644
--- a/aten/src/ATen/native/mps/operations/Sort.mm
+++ b/aten/src/ATen/native/mps/operations/Sort.mm
@@ -14,7 +14,7 @@
 #include <ATen/ops/sort.h>
 #include <ATen/ops/sort_native.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 
 // sort
 TORCH_IMPL_FUNC(sort_stable_out_mps)
@@ -99,4 +99,4 @@
     runMPSGraph(stream, cachedGraph->graph(), feeds, results);
   }
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/SummaryOps.mm b/aten/src/ATen/native/mps/operations/SummaryOps.mm
index 5c65fb3d0a..9cd9700986 100644
--- a/aten/src/ATen/native/mps/operations/SummaryOps.mm
+++ b/aten/src/ATen/native/mps/operations/SummaryOps.mm
@@ -2,7 +2,7 @@
 #define TORCH_ASSERT_ONLY_METHOD_OPERATORS
 #include <ATen/native/mps/OperationUtils.h>
 #include <ATen/ops/bincount_native.h>
-namespace at::native {
+namespace at{ namespace native {
 
 static Tensor& bincount_mps_impl(const Tensor& self, const Tensor& weights, Tensor& output) {
   using namespace mps;
@@ -116,4 +116,4 @@ Tensor _bincount_mps(const Tensor& self, const c10::optional<Tensor>& weights_op
   return bincount_mps_impl(self, weights_, output);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/TensorCompare.mm b/aten/src/ATen/native/mps/operations/TensorCompare.mm
index 781d13a27e..14fd23da84 100644
--- a/aten/src/ATen/native/mps/operations/TensorCompare.mm
+++ b/aten/src/ATen/native/mps/operations/TensorCompare.mm
@@ -16,7 +16,7 @@
 #include <ATen/ops/where_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct CachedGraph : public MPSCachedGraph {
@@ -527,4 +527,4 @@ Tensor where_mps(const Tensor& condition, const Tensor& self, const Tensor& othe
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/TriangularOps.mm b/aten/src/ATen/native/mps/operations/TriangularOps.mm
index 89eb5c3c37..e63ca50b6e 100644
--- a/aten/src/ATen/native/mps/operations/TriangularOps.mm
+++ b/aten/src/ATen/native/mps/operations/TriangularOps.mm
@@ -13,7 +13,7 @@
 
 #include <MetalPerformanceShaders/MetalPerformanceShaders.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 TORCH_IMPL_FUNC(triu_mps_out)
 (const Tensor& self, int64_t k, const Tensor& output) {
@@ -114,4 +114,4 @@
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/UnaryKernel.mm b/aten/src/ATen/native/mps/operations/UnaryKernel.mm
index bd7f2aa997..ea4691c070 100644
--- a/aten/src/ATen/native/mps/operations/UnaryKernel.mm
+++ b/aten/src/ATen/native/mps/operations/UnaryKernel.mm
@@ -12,7 +12,7 @@
 
 #include <fmt/format.h>
 
-namespace at::native {
+namespace at{ namespace native {
 static const std::string& getMetalType(const c10::ScalarType& t) {
   // Mapping from c10::ScalarType to integral type that can be used for unary ops
   static std::unordered_map<c10::ScalarType, std::string> scalar_to_metal_type = {
@@ -130,4 +130,4 @@
     output_.copy_(outputTensor);
   }
 }
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/UnaryOps.mm b/aten/src/ATen/native/mps/operations/UnaryOps.mm
index c48b22f265..f676f8a897 100644
--- a/aten/src/ATen/native/mps/operations/UnaryOps.mm
+++ b/aten/src/ATen/native/mps/operations/UnaryOps.mm
@@ -54,7 +54,7 @@
 #include <ATen/ops/view_as_real.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 enum class MPSCumulativeOpType : uint8_t {
   CUMSUM = 0,
@@ -498,4 +498,4 @@ static void cumulative_op_impl(const Tensor& self,
   mps::unary_op(realInput, realOutput, "sgn_out_mps", complex_sgn_op);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/Unique.mm b/aten/src/ATen/native/mps/operations/Unique.mm
index cda420da5c..f13be18489 100644
--- a/aten/src/ATen/native/mps/operations/Unique.mm
+++ b/aten/src/ATen/native/mps/operations/Unique.mm
@@ -17,7 +17,7 @@
 #include <ATen/ops/unique_dim_consecutive_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct UniqueCachedGraph : public MPSCachedGraph {
@@ -327,4 +327,4 @@ static void runUniqueGraph(UniqueCachedGraph* uniqueGraph,
   return _unique_impl_mps(self, return_inverse, return_counts, false, c10::nullopt);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/UpSample.mm b/aten/src/ATen/native/mps/operations/UpSample.mm
index 64fe89b7f5..5b5c854b02 100644
--- a/aten/src/ATen/native/mps/operations/UpSample.mm
+++ b/aten/src/ATen/native/mps/operations/UpSample.mm
@@ -29,7 +29,7 @@
 #include <ATen/ops/upsample_nearest2d_backward_native.h>
 #include <ATen/ops/upsample_nearest2d_native.h>
 #endif
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 // Upsampling operations (1D/2D forward and backward)
@@ -392,4 +392,4 @@ static bool check_mps_compatibility(const c10::string_view resize_mode_str, c10:
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/View.mm b/aten/src/ATen/native/mps/operations/View.mm
index 38ee31f747..58b1182eab 100644
--- a/aten/src/ATen/native/mps/operations/View.mm
+++ b/aten/src/ATen/native/mps/operations/View.mm
@@ -15,7 +15,7 @@
 #include <ATen/ops/view_as_real.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace mps {
 
 struct ViewCachedGraph : public MPSCachedGraph {
@@ -954,4 +954,4 @@ Tensor as_strided_tensorimpl_mps(const Tensor& self,
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/mps/operations/WeightNorm.mm b/aten/src/ATen/native/mps/operations/WeightNorm.mm
index 7ca63533ed..193da87be2 100644
--- a/aten/src/ATen/native/mps/operations/WeightNorm.mm
+++ b/aten/src/ATen/native/mps/operations/WeightNorm.mm
@@ -9,7 +9,7 @@
 #include <ATen/ops/_weight_norm_interface_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::native::mps;
 
@@ -189,4 +189,4 @@
   return std::tuple<Tensor, Tensor>{grad_v, grad_g};
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/quantized/ConvUtils.h b/aten/src/ATen/native/quantized/ConvUtils.h
index 092f68e7d5..b45847061e 100644
--- a/aten/src/ATen/native/quantized/ConvUtils.h
+++ b/aten/src/ATen/native/quantized/ConvUtils.h
@@ -2,7 +2,7 @@
 #include <ATen/core/List.h>
 #include <ATen/native/ConvUtils.h>
 
-namespace at::native::quantized {
+namespace at{ namespace native { namespace quantized {
 namespace {
 // MakeConvOutputShape used from both CPU and CUDA libraries
 // and exporting symbol from torch_cpu would probaby take more storage
@@ -59,4 +59,4 @@ at::SmallVector<int64_t, 5> MakeConvOutputShape<3>(
 
 #endif
 } // anonymous namespace
-} // namespace at::native::quantized
+}}} // namespace at::native::quantized
diff --git a/aten/src/ATen/native/quantized/cpu/qconv.cpp b/aten/src/ATen/native/quantized/cpu/qconv.cpp
index 9112fdd7f2..d876bd90d9 100644
--- a/aten/src/ATen/native/quantized/cpu/qconv.cpp
+++ b/aten/src/ATen/native/quantized/cpu/qconv.cpp
@@ -1678,7 +1678,7 @@ static at::Tensor _quantized_convolution_onednn(
 
 #endif // #if AT_MKLDNN_ENABLED()
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 /*
@@ -1952,4 +1952,4 @@ TORCH_LIBRARY_IMPL(onednn, MkldnnCPU, m) {
 }
 
 } // namespace
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/FlattenIndicesCommon.h b/aten/src/ATen/native/sparse/FlattenIndicesCommon.h
index 231da0e911..13826422e0 100644
--- a/aten/src/ATen/native/sparse/FlattenIndicesCommon.h
+++ b/aten/src/ATen/native/sparse/FlattenIndicesCommon.h
@@ -21,7 +21,7 @@
 #define NAME "flatten_indices_cpu"
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -103,4 +103,4 @@ Tensor _flatten_indices(const Tensor& indices, IntArrayRef size) {
 
 }
 
-} // at::native
+}} // at::native
diff --git a/aten/src/ATen/native/sparse/FlattenIndicesKernel.cpp b/aten/src/ATen/native/sparse/FlattenIndicesKernel.cpp
index 9473326352..78ad642c34 100644
--- a/aten/src/ATen/native/sparse/FlattenIndicesKernel.cpp
+++ b/aten/src/ATen/native/sparse/FlattenIndicesKernel.cpp
@@ -5,7 +5,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/AccumulateType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -28,4 +28,4 @@ REGISTER_AVX2_DISPATCH(flatten_indices_stub, &flatten_indices_cpu_kernel);
 REGISTER_VSX_DISPATCH(flatten_indices_stub, &flatten_indices_cpu_kernel);
 REGISTER_ZVECTOR_DISPATCH(flatten_indices_stub, &flatten_indices_cpu_kernel);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/ParamUtils.cpp b/aten/src/ATen/native/sparse/ParamUtils.cpp
index 1f2ee5932e..2f798de002 100644
--- a/aten/src/ATen/native/sparse/ParamUtils.cpp
+++ b/aten/src/ATen/native/sparse/ParamUtils.cpp
@@ -11,7 +11,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 std::tuple<Tensor, Tensor, int64_t> softmax_sparse_input_preprocessing(
     const Tensor& input_,
@@ -51,4 +51,4 @@ std::tuple<Tensor, Tensor, Tensor, int64_t> softmax_backward_sparse_input_prepro
   return std::make_tuple(grad_input, grad, output, dim);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SoftMax.cpp b/aten/src/ATen/native/sparse/SoftMax.cpp
index 883c2b9c4e..d10e0687a2 100644
--- a/aten/src/ATen/native/sparse/SoftMax.cpp
+++ b/aten/src/ATen/native/sparse/SoftMax.cpp
@@ -28,7 +28,7 @@
 
 #include <map>
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 int64_t get_nvalues(const IntArrayRef& sizes, int64_t sparse_dim) {
@@ -660,4 +660,4 @@ Tensor _sparse_log_softmax(const Tensor& self, Dimname dim, optional<ScalarType>
   return at::_sparse_log_softmax(self, dimname_to_position(self, dim), dtype);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseBinaryOpIntersectionKernel.cpp b/aten/src/ATen/native/sparse/SparseBinaryOpIntersectionKernel.cpp
index b48822e32f..6befff17a7 100644
--- a/aten/src/ATen/native/sparse/SparseBinaryOpIntersectionKernel.cpp
+++ b/aten/src/ATen/native/sparse/SparseBinaryOpIntersectionKernel.cpp
@@ -5,7 +5,7 @@
 #include <ATen/native/TensorIterator.h>
 #include <ATen/AccumulateType.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -173,4 +173,4 @@ REGISTER_AVX512_DISPATCH(sparse_mask_projection_out_stub, &sparse_mask_projectio
 REGISTER_AVX2_DISPATCH(sparse_mask_projection_out_stub, &sparse_mask_projection_out_cpu_kernel);
 REGISTER_VSX_DISPATCH(sparse_mask_projection_out_stub, &sparse_mask_projection_out_cpu_kernel);
 REGISTER_ZVECTOR_DISPATCH(sparse_mask_projection_out_stub, &sparse_mask_projection_out_cpu_kernel);
-}
+}} //namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseBlas.cpp b/aten/src/ATen/native/sparse/SparseBlas.cpp
index 07a7ad2b3e..d63529b7e6 100644
--- a/aten/src/ATen/native/sparse/SparseBlas.cpp
+++ b/aten/src/ATen/native/sparse/SparseBlas.cpp
@@ -24,7 +24,7 @@
 
 #include <c10/util/MaybeOwned.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 Tensor& addmv_out_sparse_compressed(
     const Tensor& self,
@@ -266,4 +266,4 @@ void sparse_sampled_addmm_check_inputs(
 
 DEFINE_DISPATCH(sampled_addmm_sparse_csr_stub);
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseBlasImpl.cpp b/aten/src/ATen/native/sparse/SparseBlasImpl.cpp
index e29a9208cb..5092f8f637 100644
--- a/aten/src/ATen/native/sparse/SparseBlasImpl.cpp
+++ b/aten/src/ATen/native/sparse/SparseBlasImpl.cpp
@@ -24,7 +24,7 @@
 #endif
 
 
-namespace at::native::sparse::impl {
+namespace at{ namespace native { namespace sparse{ namespace impl {
 
 namespace {
 
@@ -468,4 +468,4 @@ void triangular_solve_out_sparse_csr(
 }
 
 } // namespace cpu
-} // namespace at::native::sparse::impl
+}}}} // namespace at::native::sparse::impl
diff --git a/aten/src/ATen/native/sparse/SparseCsrTensor.cpp b/aten/src/ATen/native/sparse/SparseCsrTensor.cpp
index 1a7e2fad73..f1897fbdc3 100644
--- a/aten/src/ATen/native/sparse/SparseCsrTensor.cpp
+++ b/aten/src/ATen/native/sparse/SparseCsrTensor.cpp
@@ -56,7 +56,7 @@
 #include <ATen/ops/where.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::sparse_csr;
 
@@ -1126,4 +1126,4 @@ Tensor select_copy_sparse_csr(const Tensor& self, int64_t dim, int64_t index) {
   return select_sparse_csr_worker<false, true>(self, dim, index);
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseFactories.cpp b/aten/src/ATen/native/sparse/SparseFactories.cpp
index 6ee92320e1..64cad85e84 100644
--- a/aten/src/ATen/native/sparse/SparseFactories.cpp
+++ b/aten/src/ATen/native/sparse/SparseFactories.cpp
@@ -14,7 +14,7 @@
 #include <ATen/ops/where.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 DEFINE_DISPATCH(spdiags_kernel_stub);
 
@@ -92,4 +92,4 @@ Tensor spdiags(
   return result_coo;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseMatMul.cpp b/aten/src/ATen/native/sparse/SparseMatMul.cpp
index 39e2d82287..675ce23afd 100644
--- a/aten/src/ATen/native/sparse/SparseMatMul.cpp
+++ b/aten/src/ATen/native/sparse/SparseMatMul.cpp
@@ -20,7 +20,7 @@
 #include <ATen/ops/empty_like_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::sparse;
 
@@ -288,4 +288,4 @@ Tensor sparse_sparse_matmul_cpu(const Tensor& mat1_, const Tensor& mat2_) {
 }
 
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseTensor.cpp b/aten/src/ATen/native/sparse/SparseTensor.cpp
index 8a2956d76b..0682c19ecd 100644
--- a/aten/src/ATen/native/sparse/SparseTensor.cpp
+++ b/aten/src/ATen/native/sparse/SparseTensor.cpp
@@ -67,7 +67,7 @@
 #include <ATen/ops/ones.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::sparse;
 
@@ -856,4 +856,4 @@ Tensor empty_like_sparse_coo(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseTensorMath.cpp b/aten/src/ATen/native/sparse/SparseTensorMath.cpp
index bafbe44523..576ce3c41f 100644
--- a/aten/src/ATen/native/sparse/SparseTensorMath.cpp
+++ b/aten/src/ATen/native/sparse/SparseTensorMath.cpp
@@ -75,7 +75,7 @@
 
 #include <algorithm>
 
-namespace at::native {
+namespace at{ namespace native {
 
 using namespace at::sparse;
 // --------------------------------------------------------------------
@@ -2068,4 +2068,4 @@ Tensor& conj_physical_out_sparse(const Tensor& input, Tensor& result) {
   return result;
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/sparse/SparseUnaryOps.cpp b/aten/src/ATen/native/sparse/SparseUnaryOps.cpp
index ce6e3d4eac..6278e06dbf 100644
--- a/aten/src/ATen/native/sparse/SparseUnaryOps.cpp
+++ b/aten/src/ATen/native/sparse/SparseUnaryOps.cpp
@@ -73,7 +73,7 @@
 #include <ATen/ops/trunc_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 namespace {
 
 template <typename Ufunc>
@@ -280,4 +280,4 @@ Tensor& nan_to_num_sparse_(
   return nan_to_num_sparse_out(self, nan, posinf, neginf, self);
 }
 
-}  // namespace at::native
+}}  // namespace at::native
diff --git a/aten/src/ATen/native/sparse/ValidateCompressedIndicesKernel.cpp b/aten/src/ATen/native/sparse/ValidateCompressedIndicesKernel.cpp
index 34b0c3d229..b6c5808905 100644
--- a/aten/src/ATen/native/sparse/ValidateCompressedIndicesKernel.cpp
+++ b/aten/src/ATen/native/sparse/ValidateCompressedIndicesKernel.cpp
@@ -5,7 +5,7 @@
 #include <ATen/ops/_validate_compressed_sparse_indices_native.h>
 #endif
 
-namespace at::native {
+namespace at{ namespace native {
 
 namespace {
 
@@ -46,4 +46,4 @@ void _validate_compressed_sparse_indices_cpu(
       is_crow, cidx, idx, cdim, dim, nnz);
 }
 
-} //namespace at::native
+}} //namespace at::native
diff --git a/aten/src/ATen/native/sparse/cuda/SparseCUDABlas.cpp b/aten/src/ATen/native/sparse/cuda/SparseCUDABlas.cpp
index d1b169a351..2fe599b1c7 100644
--- a/aten/src/ATen/native/sparse/cuda/SparseCUDABlas.cpp
+++ b/aten/src/ATen/native/sparse/cuda/SparseCUDABlas.cpp
@@ -7,13 +7,7 @@
 
 #include <cusparse.h>
 
-// LIMITATION (cusparseSpMM):
-// The generic APIs are available on all platforms on CUDA 11.0
-// For CUDA 10.1+ it is available for all platforms except Windows.
-// Using these APIs in any other systems will result in compile-time or run-time failures.
-// Their support will be extended in the next releases.
-
-#if defined(CUDART_VERSION) && (CUSPARSE_VERSION >= 11000 || (!defined(_MSC_VER) && CUSPARSE_VERSION >= 10301))
+#if (defined(CUDART_VERSION) && (CUSPARSE_VERSION >= 11000 || (!defined(_MSC_VER) && CUSPARSE_VERSION >= 10301))) && !defined(__APPLE__) && !defined(__MACH__)
 #define IS_SPMM_AVAILABLE() 1
 #else
 #define IS_SPMM_AVAILABLE() 0
diff --git a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
index 8a6f134ffe..3ea75cc84d 100644
--- a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
+++ b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
@@ -3,7 +3,7 @@
 #include <ATen/cuda/CUDAUtils.h>
 #include <ATen/Dispatch.h>
 
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
 #include <cuda_runtime.h>
 #include <cutlass/cutlass.h>
 #include <cutlass/layout/layout.h>
@@ -11,10 +11,17 @@
 #include <cutlass/epilogue/thread/linear_combination.h>
 #include <cutlass/epilogue/thread/linear_combination_relu.h>
 #include <cutlass/epilogue/thread/linear_combination_silu.h>
+#include <cutlass/gemm/gemm.h>
 #include <cutlass/gemm/device/gemm_sparse_row_broadcast.h>
 #endif
 
 #include <type_traits>
+#if defined(__APPLE__) && defined(__MACH__)
+namespace std {
+    template< class T, class U >
+    inline constexpr bool is_same_v = is_same<T, U>::value;
+}
+#endif
 #include <tuple>
 
 #ifndef USE_ROCM
@@ -28,7 +35,7 @@
 namespace at {
 namespace native {
 
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
 // Wrapper function for CUTLASS sparse GEMM implementation, used
 // solely to simplify dispatching from
 // _sparse_semi_structured_linear() function below.
@@ -484,7 +491,7 @@ Tensor _sparse_semi_structured_linear(
       const Tensor& input, const Tensor& weight,
       const Tensor& meta, const c10::optional<Tensor>& bias_opt,
       const c10::optional<c10::string_view> activation_opt) {
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
     // No need to check that all tensors are on CUDA device, as this
     // is provided by dispatch.
 
@@ -577,31 +584,22 @@ Tensor _sparse_semi_structured_linear(
         AT_DISPATCH_CASE(
             at::ScalarType::Char,
             [&]() {
-                using ElementInputA = int8_t;
-                using ElementInputB = int8_t;
-                using ElementOutput = int32_t;
-                using ElementAccumulator = int32_t;
-                using ElementComputeEpilogue = int32_t;
-                using ThreadblockShape =
-                    cutlass::gemm::GemmShape<128, 128, 128>;
-                using WarpShape = cutlass::gemm::GemmShape<64, 64, 128>;
-                using InstructionShape = cutlass::gemm::GemmShape<16, 8, 64>;
-                const auto EnableRowMajorRowMajorLayouts = false;
-                const auto EnableRowMajorColumnMajorLayouts = true;
-                const auto EnableColumnMajorRowMajorLayouts = false;
-                const auto EnableColumnMajorColumnMajorLayouts = false;
-                const auto EnableActivationNone = true;
-                const auto EnableActivationReLU = true;
-                const auto EnableActivationSiLU = false;
+                const bool EnableRowMajorRowMajorLayouts = false;
+                const bool EnableRowMajorColumnMajorLayouts = true;
+                const bool EnableColumnMajorRowMajorLayouts = false;
+                const bool EnableColumnMajorColumnMajorLayouts = false;
+                const bool EnableActivationNone = true;
+                const bool EnableActivationReLU = true;
+                const bool EnableActivationSiLU = false;
                 output = two_four_sgemm_cutlass_dispatch_layouts_activation<
-                    ElementInputA,
-                    ElementInputB,
-                    ElementOutput,
-                    ElementAccumulator,
-                    ElementComputeEpilogue,
-                    ThreadblockShape,
-                    WarpShape,
-                    InstructionShape,
+                    int8_t,
+                    int8_t,
+                    int32_t,
+                    int32_t,
+                    int32_t,
+                    cutlass::gemm::GemmShape<128, 128, 128>,
+                    cutlass::gemm::GemmShape<64, 64, 128>,
+                    cutlass::gemm::GemmShape<16, 8, 64>,
                     EnableRowMajorRowMajorLayouts,
                     EnableRowMajorColumnMajorLayouts,
                     EnableColumnMajorRowMajorLayouts,
@@ -619,30 +617,22 @@ Tensor _sparse_semi_structured_linear(
         AT_DISPATCH_CASE(
             at::ScalarType::Half,
             [&]() {
-                using ElementInputA = cutlass::half_t;
-                using ElementInputB = cutlass::half_t;
-                using ElementOutput = cutlass::half_t;
-                using ElementAccumulator = float;
-                using ElementComputeEpilogue = float;
-                using ThreadblockShape = cutlass::gemm::GemmShape<128, 128, 64>;
-                using WarpShape = cutlass::gemm::GemmShape<64, 64, 64>;
-                using InstructionShape = cutlass::gemm::GemmShape<16, 8, 32>;
-                const auto EnableRowMajorRowMajorLayouts = true;
-                const auto EnableRowMajorColumnMajorLayouts = true;
-                const auto EnableColumnMajorRowMajorLayouts = true;
-                const auto EnableColumnMajorColumnMajorLayouts = true;
-                const auto EnableActivationNone = true;
-                const auto EnableActivationReLU = true;
-                const auto EnableActivationSiLU = true;
+                const bool EnableRowMajorRowMajorLayouts = true;
+                const bool EnableRowMajorColumnMajorLayouts = true;
+                const bool EnableColumnMajorRowMajorLayouts = true;
+                const bool EnableColumnMajorColumnMajorLayouts = true;
+                const bool EnableActivationNone = true;
+                const bool EnableActivationReLU = true;
+                const bool EnableActivationSiLU = true;
                 output = two_four_sgemm_cutlass_dispatch_layouts_activation<
-                    ElementInputA,
-                    ElementInputB,
-                    ElementOutput,
-                    ElementAccumulator,
-                    ElementComputeEpilogue,
-                    ThreadblockShape,
-                    WarpShape,
-                    InstructionShape,
+                    cutlass::half_t,
+                    cutlass::half_t,
+                    cutlass::half_t,
+                    float,
+                    float,
+                    cutlass::gemm::GemmShape<128, 128, 64>,
+                    cutlass::gemm::GemmShape<64, 64, 64>,
+                    cutlass::gemm::GemmShape<16, 8, 32>,
                     EnableRowMajorRowMajorLayouts,
                     EnableRowMajorColumnMajorLayouts,
                     EnableColumnMajorRowMajorLayouts,
@@ -657,33 +647,25 @@ Tensor _sparse_semi_structured_linear(
                     activation);
                 return;
             })
-            AT_DISPATCH_CASE(
+        AT_DISPATCH_CASE(
             at::ScalarType::BFloat16,
             [&]() {
-                using ElementInputA = cutlass::bfloat16_t;
-                using ElementInputB = cutlass::bfloat16_t;
-                using ElementOutput = cutlass::bfloat16_t;
-                using ElementAccumulator = float;
-                using ElementComputeEpilogue = float;
-                using ThreadblockShape = cutlass::gemm::GemmShape<128, 128, 64>;
-                using WarpShape = cutlass::gemm::GemmShape<64, 64, 64>;
-                using InstructionShape = cutlass::gemm::GemmShape<16, 8, 32>;
-                const auto EnableRowMajorRowMajorLayouts = true;
-                const auto EnableRowMajorColumnMajorLayouts = true;
-                const auto EnableColumnMajorRowMajorLayouts = true;
-                const auto EnableColumnMajorColumnMajorLayouts = true;
-                const auto EnableActivationNone = true;
-                const auto EnableActivationReLU = true;
-                const auto EnableActivationSiLU = true;
+                const bool EnableRowMajorRowMajorLayouts = true;
+                const bool EnableRowMajorColumnMajorLayouts = true;
+                const bool EnableColumnMajorRowMajorLayouts = true;
+                const bool EnableColumnMajorColumnMajorLayouts = true;
+                const bool EnableActivationNone = true;
+                const bool EnableActivationReLU = true;
+                const bool EnableActivationSiLU = true;
                 output = two_four_sgemm_cutlass_dispatch_layouts_activation<
-                    ElementInputA,
-                    ElementInputB,
-                    ElementOutput,
-                    ElementAccumulator,
-                    ElementComputeEpilogue,
-                    ThreadblockShape,
-                    WarpShape,
-                    InstructionShape,
+                    cutlass::bfloat16_t,
+                    cutlass::bfloat16_t,
+                    cutlass::bfloat16_t,
+                    float,
+                    float,
+                    cutlass::gemm::GemmShape<128, 128, 64>,
+                    cutlass::gemm::GemmShape<64, 64, 64>,
+                    cutlass::gemm::GemmShape<16, 8, 32>,
                     EnableRowMajorRowMajorLayouts,
                     EnableRowMajorColumnMajorLayouts,
                     EnableColumnMajorRowMajorLayouts,
@@ -697,7 +679,8 @@ Tensor _sparse_semi_structured_linear(
                     meta,
                     activation);
                 return;
-            }));
+            })
+    );
 
     // Re-introduce batch dimensions into the output, and return.
     auto output_sizes = input_sizes;
@@ -716,7 +699,7 @@ Tensor _sparse_semi_structured_linear(
 namespace at {
 namespace native {
 
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
 // Copied from tools/util/include/host_reorder.h, from CUTLASS source
 // tree.  This is for simplicity - namely, this file is not under
 // include/cutlass in this tree, as other CUTLASS include files
@@ -753,7 +736,7 @@ static void reorder_meta(cutlass::TensorRef<Element, LayoutDest> dest,
 
 std::tuple<Tensor, Tensor>
 _to_sparse_semi_structured(const Tensor& dense) {
-#ifndef USE_ROCM
+#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
   // Check dimensions of the dense matrix.
   TORCH_CHECK(dense.dim() == 2,
               "_to_sparse_semi_structured: Expected dense argument to be 2D "
diff --git a/aten/src/ATen/native/sparse/cuda/cuSPARSELtOps.cpp b/aten/src/ATen/native/sparse/cuda/cuSPARSELtOps.cpp
index 701aca63a4..8a16f52f95 100644
--- a/aten/src/ATen/native/sparse/cuda/cuSPARSELtOps.cpp
+++ b/aten/src/ATen/native/sparse/cuda/cuSPARSELtOps.cpp
@@ -16,7 +16,7 @@
 
 #include <cusparseLt.h>
 
-namespace at::native {
+namespace at{ namespace native {
 
 // Ideally we would use the same DeviceThreadHandlePool mechanism as used in aten/src/ATen/cuda/CuSparseHandlePool.cpp
 // which would handle this for us. However, the cuSPARSELt handle signature is different from that of cuSPARSE/cuBLAS,
@@ -311,11 +311,11 @@ at::Tensor _cslt_sparse_mm(
   return res;
 }
 
-} // namespace at::native
+}} // namespace at::native
 
 #else // No cuSPARSELt support, throw error if these functions are called.
 
-namespace at::native {
+namespace at{ namespace native {
 
 at::Tensor _cslt_compress(const Tensor& sparse_input){
     TORCH_CHECK(false, "cuSPARSELT not supported on your machine.");
@@ -332,6 +332,6 @@ at::Tensor _cslt_sparse_mm(
     TORCH_CHECK(false, "cuSPARSELT not supported on your machine.");
 }
 
-} // namespace at::native
+}} // namespace at::native
 
 #endif
diff --git a/aten/src/ATen/native/transformers/cuda/attention.cu b/aten/src/ATen/native/transformers/cuda/attention.cu
index 696d2ee8a4..d83cab2336 100644
--- a/aten/src/ATen/native/transformers/cuda/attention.cu
+++ b/aten/src/ATen/native/transformers/cuda/attention.cu
@@ -21,6 +21,7 @@
 #include <ATen/native/cuda/PersistentSoftmax.cuh>
 #include <ATen/native/cuda/block_reduce.cuh>
 #include <c10/util/Optional.h>
+#include <ATen/ops/arange.h>
 
 #ifndef AT_PER_OPERATOR_HEADERS
 #include <ATen/Functions.h>
@@ -676,6 +677,50 @@ std::tuple<Tensor, Tensor, Tensor, Tensor, c10::SymInt, c10::SymInt, Tensor, Ten
     bool is_causal,
     bool return_debug_mask,
     c10::optional<double> scale) {
+#if defined(__APPLE__) && defined(__MACH__)
+  // Used for tracking usage statistics
+  C10_LOG_API_USAGE_ONCE("torch.sdpa.flash_attention");
+  // Query (Batch x Num_heads x Q_seq_len  x Dim_per_head)
+  // Key   (Batch x Num_heads x KV_seq_len x Dim_per_head)
+  // Value (Batch x Num_heads x KV_seq_len x Dim_per_head)
+
+  const int64_t max_seqlen_batch_q = query.size(2);
+  const int64_t max_seqlen_batch_k = key.size(2);
+  const int64_t max_seqlen_batch_v = value.size(2);
+  TORCH_CHECK(
+      max_seqlen_batch_k == max_seqlen_batch_v,
+      "Key and Value must have the same sequence length");
+
+  // Query -> Query(Batch x Q_seq_len  x Num_heads x Dim_per_head)
+  // Key   -> Key  (Batch x KV_seq_len x Num_heads x Dim_per_head)
+  // Value -> Value(Batch x KV_seq_len x Num_heads x Dim_per_head)
+  Tensor q_t = query.transpose(1, 2);
+  Tensor k_t = key.transpose(1, 2);
+  Tensor v_t = value.transpose(1, 2);
+
+  Tensor output, logsumexp, philox_seed, philox_offset, debug_attn_mask;
+  std::tie(output,
+       logsumexp,
+       philox_seed,
+       philox_offset,
+       debug_attn_mask) =
+          at::_flash_attention_forward(
+              q_t,
+              k_t,
+              v_t,
+              c10::nullopt,
+              c10::nullopt,
+              max_seqlen_batch_q,
+              max_seqlen_batch_k,
+              dropout_p,
+              is_causal,
+              return_debug_mask,
+              scale);
+  // Reshape output to convert nnz to batch_size and seq_len
+  Tensor attention = output.transpose(1,2);
+
+  return std::make_tuple(attention, logsumexp, Tensor(), Tensor(), max_seqlen_batch_q, max_seqlen_batch_k, philox_seed, philox_offset, debug_attn_mask);
+#else
   // Used for tracking usage statistics
   C10_LOG_API_USAGE_ONCE("torch.sdpa.flash_attention");
   // Query (Batch x Num_heads x Q_seq_len  x Dim_per_head)
@@ -718,6 +763,7 @@ std::tuple<Tensor, Tensor, Tensor, Tensor, c10::SymInt, c10::SymInt, Tensor, Ten
   Tensor attention = output.transpose(1,2);
 
   return std::make_tuple(attention, logsumexp, Tensor(), Tensor(), max_seqlen_batch_q, max_seqlen_batch_k, philox_seed, philox_offset, debug_attn_mask);
+#endif
 }
 
 std::tuple<Tensor, Tensor, Tensor, Tensor> _scaled_dot_product_efficient_attention_cuda(
@@ -729,6 +775,37 @@ std::tuple<Tensor, Tensor, Tensor, Tensor> _scaled_dot_product_efficient_attenti
     double dropout_p,
     bool is_causal,
     c10::optional<double> scale) {
+#if defined(__APPLE__) && defined(__MACH__)
+  // Used for tracking usage statistics
+  C10_LOG_API_USAGE_ONCE("torch.sdpa.mem_efficient_attention");
+  // Query -> Query(Batch x Q_seq_len x Num_heads x Dim_per_head)
+  // Key   -> Key(Batch x KV_seq_len x Num_heads x Dim_per_head)
+  // Value -> Value(Batch x KV_seq_len x  Num_heads x Dim_per_head)
+  Tensor q_t = query.transpose(1, 2);
+  Tensor k_t = key.transpose(1, 2);
+  Tensor v_t = value.transpose(1, 2);
+
+  Tensor attention, log_sumexp, seed, offset;
+  c10::SymInt max_seqlen_batch_q, max_seqlen_batch_kv;
+  sdp::CustomMaskType custom_mask_type = is_causal
+      ? sdp::CustomMaskType::CausalFromTopLeft
+      : sdp::CustomMaskType::NoCustomMask;
+
+  std::tie(attention, log_sumexp, seed, offset, max_seqlen_batch_q, max_seqlen_batch_kv) = at::_efficient_attention_forward(
+      q_t,
+      k_t,
+      v_t,
+      attn_bias,
+      c10::nullopt,
+      c10::nullopt,
+      c10::nullopt,
+      dropout_p,
+      static_cast<int64_t>(custom_mask_type),
+      compute_log_sumexp,
+      scale);
+  attention = attention.transpose(1,2);
+  return std::make_tuple(std::move(attention), std::move(log_sumexp), std::move(seed), std::move(offset));
+#else
   // Used for tracking usage statistics
   C10_LOG_API_USAGE_ONCE("torch.sdpa.mem_efficient_attention");
   // Query -> Query(Batch x Q_seq_len x Num_heads x Dim_per_head)
@@ -757,6 +834,7 @@ std::tuple<Tensor, Tensor, Tensor, Tensor> _scaled_dot_product_efficient_attenti
 
   attention = attention.transpose(1, 2);
   return std::make_tuple(std::move(attention), std::move(log_sumexp), std::move(seed), std::move(offset));
+#endif
 }
 
 int64_t _fused_sdp_choice_cuda(const Tensor& query_, const Tensor& key, const Tensor& value,
diff --git a/aten/src/ATen/native/utils/ParamsHash.h b/aten/src/ATen/native/utils/ParamsHash.h
index 6b7894cb85..066c693120 100644
--- a/aten/src/ATen/native/utils/ParamsHash.h
+++ b/aten/src/ATen/native/utils/ParamsHash.h
@@ -4,7 +4,16 @@
 #include <memory>
 #include <mutex>
 
-namespace at::native {
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+// namespace std {
+//   // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+//   template <class T>
+//   constexpr bool is_standard_layout_v = std::is_standard_layout<T>::value;
+// }
+#endif
+
+namespace at{ namespace native {
 
 // Hashing machinery for Params
 // FowlerNollVo hash function
@@ -14,7 +23,7 @@ template <typename Params>
 struct ParamsHash {
   // Params must be a POD because we read out its memory
   // contents as char* when hashing
-  static_assert(std::is_standard_layout_v<Params>, "Params is not POD");
+  static_assert(std::is_standard_layout<Params>::value, "Params is not POD");
 
   size_t operator()(const Params& params) const {
     auto ptr = reinterpret_cast<const uint8_t*>(&params);
@@ -31,7 +40,7 @@ template <typename Params>
 struct ParamsEqual {
   // Params must be a POD because we read out its memory
   // contents as char* when comparing
-  static_assert(std::is_standard_layout_v<Params>, "Params is not POD");
+  static_assert(std::is_standard_layout<Params>::value, "Params is not POD");
 
   bool operator()(const Params& a, const Params& b) const {
     auto ptr1 = reinterpret_cast<const uint8_t*>(&a);
@@ -46,7 +55,7 @@ template <typename T>
 struct ParamsWrapper {
   T pod;
   static_assert(
-      std::is_standard_layout_v<T>,
+      std::is_standard_layout<T>::value,
       "ParamsWrapper cannot wrap non-POD data");
 
   ParamsWrapper() {
@@ -87,7 +96,7 @@ struct ParamsWrapperHash {
   // Params must be a POD because we read out its memory
   // contents as char* when hashing
   static_assert(
-      std::is_standard_layout_v<decltype(ParamsWrapper::pod)>,
+      std::is_standard_layout<decltype(ParamsWrapper::pod)>::value,
       "ParamsWrapper cannot wrap non-POD data");
 
   size_t operator()(const ParamsWrapper& params_wrapper) const {
@@ -101,4 +110,4 @@ struct ParamsWrapperHash {
   }
 };
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/vol2col.h b/aten/src/ATen/native/vol2col.h
index ccbfc69ce3..ff437fe773 100644
--- a/aten/src/ATen/native/vol2col.h
+++ b/aten/src/ATen/native/vol2col.h
@@ -2,7 +2,7 @@
 
 #include <cstring>
 
-namespace at::native {
+namespace at{ namespace native {
 
 template <typename T>
 static void vol2col(
@@ -106,4 +106,4 @@ static void col2vol(
   }
 }
 
-} // namespace at::native
+}} // namespace at::native
diff --git a/aten/src/ATen/native/xnnpack/AveragePooling.cpp b/aten/src/ATen/native/xnnpack/AveragePooling.cpp
index 2da8552cb5..d946f0efda 100644
--- a/aten/src/ATen/native/xnnpack/AveragePooling.cpp
+++ b/aten/src/ATen/native/xnnpack/AveragePooling.cpp
@@ -5,7 +5,7 @@
 #include <ATen/native/xnnpack/Engine.h>
 #include <ATen/native/xnnpack/Pooling.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 bool use_global_average_pool(
   const Tensor& input) {
@@ -78,6 +78,6 @@ Tensor global_average_pool(
   return output.to(input.suggest_memory_format());
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/ChannelShuffle.cpp b/aten/src/ATen/native/xnnpack/ChannelShuffle.cpp
index cfd29527ff..6f5374e494 100644
--- a/aten/src/ATen/native/xnnpack/ChannelShuffle.cpp
+++ b/aten/src/ATen/native/xnnpack/ChannelShuffle.cpp
@@ -4,7 +4,7 @@
 #include <ATen/native/xnnpack/Engine.h>
 #include <ATen/native/utils/Factory.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 bool use_channel_shuffle(
     const Tensor& input,
@@ -101,6 +101,6 @@ Tensor channel_shuffle(
   return output_padded_contig_nhwc.contiguous(input.suggest_memory_format());
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Common.h b/aten/src/ATen/native/xnnpack/Common.h
index 2ee8da9b83..5e80903d67 100644
--- a/aten/src/ATen/native/xnnpack/Common.h
+++ b/aten/src/ATen/native/xnnpack/Common.h
@@ -8,7 +8,7 @@
 #include <limits>
 #include <memory>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 struct Deleter final {
   void operator()(const xnn_operator_t op) const {
@@ -119,10 +119,10 @@ struct Layout final {
   };
 };
 } // namespace internal
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 bool available();
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
diff --git a/aten/src/ATen/native/xnnpack/Convolution.cpp b/aten/src/ATen/native/xnnpack/Convolution.cpp
index 7e27a0102a..63050711ba 100644
--- a/aten/src/ATen/native/xnnpack/Convolution.cpp
+++ b/aten/src/ATen/native/xnnpack/Convolution.cpp
@@ -10,7 +10,7 @@
 #include <ATen/native/xnnpack/Engine.h>
 #include <c10/util/irange.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal {
 namespace convolution2d {
 
@@ -494,6 +494,6 @@ Tensor convolution2d(
       ContextConv2D::kMax);
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Convolution.h b/aten/src/ATen/native/xnnpack/Convolution.h
index 0df4a6bcd4..72b9a51885 100644
--- a/aten/src/ATen/native/xnnpack/Convolution.h
+++ b/aten/src/ATen/native/xnnpack/Convolution.h
@@ -6,7 +6,7 @@
 #include <ATen/native/xnnpack/Common.h>
 #include <ATen/native/xnnpack/OpContext.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal::convolution2d {
 
 c10::intrusive_ptr<xnnpack::Conv2dOpContext>
@@ -67,6 +67,6 @@ Tensor convolution2d(
     const IntArrayRef stride,
     const IntArrayRef dilation,
     const int64_t groups);
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Engine.h b/aten/src/ATen/native/xnnpack/Engine.h
index 6ba244618a..50720ec568 100644
--- a/aten/src/ATen/native/xnnpack/Engine.h
+++ b/aten/src/ATen/native/xnnpack/Engine.h
@@ -3,7 +3,7 @@
 #include <ATen/core/Tensor.h>
 #include <limits>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 //
 // Convolution
@@ -92,4 +92,4 @@ bool use_hardswish(const Tensor& input);
 Tensor hardswish(const Tensor& input);
 Tensor& hardswish_(Tensor& input);
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
diff --git a/aten/src/ATen/native/xnnpack/Init.cpp b/aten/src/ATen/native/xnnpack/Init.cpp
index 5f8c5ecf89..81a41d7cb6 100644
--- a/aten/src/ATen/native/xnnpack/Init.cpp
+++ b/aten/src/ATen/native/xnnpack/Init.cpp
@@ -3,7 +3,7 @@
 #include <ATen/native/xnnpack/Common.h>
 #include <c10/util/Exception.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal {
 namespace {
 
@@ -55,6 +55,6 @@ bool available() {
   return internal::initialize();
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Linear.cpp b/aten/src/ATen/native/xnnpack/Linear.cpp
index 8104aff0bd..386407c10e 100644
--- a/aten/src/ATen/native/xnnpack/Linear.cpp
+++ b/aten/src/ATen/native/xnnpack/Linear.cpp
@@ -4,7 +4,7 @@
 #include <ATen/native/utils/Factory.h>
 #include <ATen/native/xnnpack/Linear.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal::linear {
 
 namespace {
@@ -215,6 +215,6 @@ Tensor linear(
       ContextLinear::kMax);
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Linear.h b/aten/src/ATen/native/xnnpack/Linear.h
index 32c9d93bf4..52264bdc6a 100644
--- a/aten/src/ATen/native/xnnpack/Linear.h
+++ b/aten/src/ATen/native/xnnpack/Linear.h
@@ -6,7 +6,7 @@
 #include <ATen/native/xnnpack/Common.h>
 #include <ATen/native/xnnpack/OpContext.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal::linear {
 
 c10::intrusive_ptr<xnnpack::LinearOpContext> createLinearClampPrePackOpContext(
@@ -39,6 +39,6 @@ Tensor linear(
     const Tensor& weight,
     const Tensor& bias);
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/MaxPooling.cpp b/aten/src/ATen/native/xnnpack/MaxPooling.cpp
index 2d658b0109..bd5361db03 100644
--- a/aten/src/ATen/native/xnnpack/MaxPooling.cpp
+++ b/aten/src/ATen/native/xnnpack/MaxPooling.cpp
@@ -6,7 +6,7 @@
 #include <ATen/native/xnnpack/Engine.h>
 #include <ATen/native/xnnpack/Pooling.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 // Supports NHWC and NCHW FP32 max pooling with any
 //  - kernel size
@@ -238,6 +238,6 @@ Tensor max_pool2d(
   return output_padded_contig_nhwc.contiguous(input.suggest_memory_format());
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/OpContext.cpp b/aten/src/ATen/native/xnnpack/OpContext.cpp
index 07f926cd8a..09a865c0fe 100644
--- a/aten/src/ATen/native/xnnpack/OpContext.cpp
+++ b/aten/src/ATen/native/xnnpack/OpContext.cpp
@@ -5,7 +5,7 @@
 
 #include <ATen/Context.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 c10::intrusive_ptr<LinearOpContext>
 XNNPackLinearOpContext::create_context(
@@ -154,6 +154,6 @@ void XNNPackTransposeConv2dOpContext::free_orig_weight_and_bias() {
   orig_bias_.reset();
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/OpContext.h b/aten/src/ATen/native/xnnpack/OpContext.h
index eecc8b11fa..654333a8c0 100644
--- a/aten/src/ATen/native/xnnpack/OpContext.h
+++ b/aten/src/ATen/native/xnnpack/OpContext.h
@@ -6,7 +6,7 @@
 #include <ATen/native/xnnpack/Common.h>
 #include <ATen/Tensor.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 using SerializationTypeLinearPrePack = std::tuple<
     Tensor,
@@ -243,6 +243,6 @@ class XNNPackTransposeConv2dOpContext final : public TransposeConv2dOpContext {
       const c10::optional<Scalar>& output_max);
 };
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Pooling.h b/aten/src/ATen/native/xnnpack/Pooling.h
index e170153855..0e197a1fc2 100644
--- a/aten/src/ATen/native/xnnpack/Pooling.h
+++ b/aten/src/ATen/native/xnnpack/Pooling.h
@@ -4,7 +4,7 @@
 
 #include <ATen/Tensor.h>
 
-namespace at::native::xnnpack::internal::pooling {
+namespace at{ namespace native { namespace xnnpack{ namespace internal{ namespace pooling {
 
 struct Parameters final {
 
@@ -37,6 +37,6 @@ private:
   }
 };
 
-} // namespace at::native::xnnpack::internal::pooling
+}}}}} // namespace at::native::xnnpack::internal::pooling
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/RegisterOpContextClass.cpp b/aten/src/ATen/native/xnnpack/RegisterOpContextClass.cpp
index e3a098e96b..92ae471303 100644
--- a/aten/src/ATen/native/xnnpack/RegisterOpContextClass.cpp
+++ b/aten/src/ATen/native/xnnpack/RegisterOpContextClass.cpp
@@ -6,7 +6,7 @@
 #include <ATen/native/xnnpack/OpContext.h>
 #include <torch/custom_class.h>
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 
 using internal::linear::createLinearClampPrePackOpContext;
 using internal::convolution2d::createConv2dClampPrePackOpContext;
@@ -90,6 +90,6 @@ TORCH_LIBRARY_IMPL(prepacked, CPU, m) {
   m.impl(TORCH_SELECTIVE_NAME("prepacked::conv2d_transpose_clamp_run"), TORCH_FN(internal::convolution2d::conv2d_transpose_clamp_run));
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/native/xnnpack/Shim.cpp b/aten/src/ATen/native/xnnpack/Shim.cpp
index 03030d7826..18498b9363 100644
--- a/aten/src/ATen/native/xnnpack/Shim.cpp
+++ b/aten/src/ATen/native/xnnpack/Shim.cpp
@@ -14,7 +14,7 @@
 // trigger an error.
 //
 
-namespace at::native::xnnpack {
+namespace at{ namespace native { namespace xnnpack {
 namespace internal {
 namespace {
 
@@ -89,6 +89,6 @@ Tensor max_pool2d(
   TORCH_CHECK(false, internal::kError);
 }
 
-} // namespace at::native::xnnpack
+}}} // namespace at::native::xnnpack
 
 #endif /* USE_XNNPACK */
diff --git a/aten/src/ATen/test/rng_test.h b/aten/src/ATen/test/rng_test.h
index c7ac20edec..26500b54bf 100644
--- a/aten/src/ATen/test/rng_test.h
+++ b/aten/src/ATen/test/rng_test.h
@@ -7,6 +7,14 @@
 #include <torch/all.h>
 #include <stdexcept>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <type_traits>
+namespace std{
+  template< class T, class U >
+  inline constexpr bool is_same_v = ::std::is_same<T, U>::value;
+}
+#endif
+
 namespace {
 
 constexpr auto int64_min_val = std::numeric_limits<int64_t>::lowest();
diff --git a/aten/src/ATen/test/vec_test_all_types.h b/aten/src/ATen/test/vec_test_all_types.h
index f8bd6cb838..9b4bf66b8c 100644
--- a/aten/src/ATen/test/vec_test_all_types.h
+++ b/aten/src/ATen/test/vec_test_all_types.h
@@ -20,8 +20,11 @@
 #if defined(__APPLE__) and defined(__MACH__)
 #include <type_traits>
 namespace std{
+  template< class T, class U >
+    inline constexpr bool is_same_v = is_same<T, U>::value;
   template< class T >
     inline constexpr bool is_integral_v = is_integral<T>::value;
+    
 }
 #endif
 
diff --git a/c10/util/C++17.h b/c10/util/C++17.h
index ebf9f7b449..09259ab840 100644
--- a/c10/util/C++17.h
+++ b/c10/util/C++17.h
@@ -22,9 +22,9 @@
     "You're trying to build PyTorch with a too old version of Clang. We need Clang 4 or later."
 #endif
 
-#if ((defined(_MSC_VER) && (!defined(_MSVC_LANG) || _MSVC_LANG < 201703L)) || \
-    (!defined(_MSC_VER) && __cplusplus < 201703L)) && !defined(__APPLE__)
-#error You need C++17 to compile PyTorch
+#if (defined(_MSC_VER) && (!defined(_MSVC_LANG) || _MSVC_LANG < 201402L)) || \
+    (!defined(_MSC_VER) && __cplusplus < 201402L)
+#error You need C++14 to compile PyTorch
 #endif
 
 #if defined(_WIN32) && (defined(min) || defined(max))
@@ -231,8 +231,237 @@ struct function_takes_identity_argument<
     Func,
     void_t<decltype(std::declval<Func>()(_identity()))>> : std::true_type {};
 #endif
+
+template <bool Condition>
+struct _if_constexpr;
+
+template <>
+struct _if_constexpr<true> final {
+  template <
+      class ThenCallback,
+      class ElseCallback,
+      std::enable_if_t<
+          function_takes_identity_argument<ThenCallback>::value,
+          void*> = nullptr>
+  static decltype(auto) call(
+      ThenCallback&& thenCallback,
+      ElseCallback&& /* elseCallback */) {
+    // The _identity instance passed in can be used to delay evaluation of an
+    // expression, because the compiler can't know that it's just the identity
+    // we're passing in.
+    return thenCallback(_identity());
+  }
+
+  template <
+      class ThenCallback,
+      class ElseCallback,
+      std::enable_if_t<
+          !function_takes_identity_argument<ThenCallback>::value,
+          void*> = nullptr>
+  static decltype(auto) call(
+      ThenCallback&& thenCallback,
+      ElseCallback&& /* elseCallback */) {
+    return thenCallback();
+  }
+};
+
+template <>
+struct _if_constexpr<false> final {
+  template <
+      class ThenCallback,
+      class ElseCallback,
+      std::enable_if_t<
+          function_takes_identity_argument<ElseCallback>::value,
+          void*> = nullptr>
+  static decltype(auto) call(
+      ThenCallback&& /* thenCallback */,
+      ElseCallback&& elseCallback) {
+    // The _identity instance passed in can be used to delay evaluation of an
+    // expression, because the compiler can't know that it's just the identity
+    // we're passing in.
+    return elseCallback(_identity());
+  }
+
+  template <
+      class ThenCallback,
+      class ElseCallback,
+      std::enable_if_t<
+          !function_takes_identity_argument<ElseCallback>::value,
+          void*> = nullptr>
+  static decltype(auto) call(
+      ThenCallback&& /* thenCallback */,
+      ElseCallback&& elseCallback) {
+    return elseCallback();
+  }
+};
 } // namespace detail
 
+/*
+ * Get something like C++17 if constexpr in C++14.
+ *
+ * Example 1: simple constexpr if/then/else
+ *   template<int arg> int increment_absolute_value() {
+ *     int result = arg;
+ *     if_constexpr<(arg > 0)>(
+ *       [&] { ++result; }  // then-case
+ *       [&] { --result; }  // else-case
+ *     );
+ *     return result;
+ *   }
+ *
+ * Example 2: without else case (i.e. conditionally prune code from assembly)
+ *   template<int arg> int decrement_if_positive() {
+ *     int result = arg;
+ *     if_constexpr<(arg > 0)>(
+ *       // This decrement operation is only present in the assembly for
+ *       // template instances with arg > 0.
+ *       [&] { --result; }
+ *     );
+ *     return result;
+ *   }
+ *
+ * Example 3: branch based on type (i.e. replacement for SFINAE)
+ *   struct MyClass1 {int value;};
+ *   struct MyClass2 {int val};
+ *   template <class T>
+ *   int func(T t) {
+ *     return if_constexpr<std::is_same<T, MyClass1>::value>(
+ *       [&](auto _) { return _(t).value; }, // this code is invalid for T ==
+ * MyClass2, so a regular non-constexpr if statement wouldn't compile
+ *       [&](auto _) { return _(t).val; }    // this code is invalid for T ==
+ * MyClass1
+ *     );
+ *   }
+ *
+ * Note: The _ argument passed in Example 3 is the identity function, i.e. it
+ * does nothing. It is used to force the compiler to delay type checking,
+ * because the compiler doesn't know what kind of _ is passed in. Without it,
+ * the compiler would fail when you try to access t.value but the member doesn't
+ * exist.
+ *
+ * Note: In Example 3, both branches return int, so func() returns int. This is
+ * not necessary. If func() had a return type of "auto", then both branches
+ * could return different types, say func<MyClass1>() could return int and
+ * func<MyClass2>() could return string.
+ *
+ * Note: if_constexpr<cond, t, f> is *eager* w.r.t. template expansion - meaning
+ * this polyfill does not behave like a true "if statement at compilation time".
+ *       The `_` trick above only defers typechecking, which happens after
+ * templates have been expanded. (Of course this is all that's necessary for
+ * many use cases).
+ */
+template <bool Condition, class ThenCallback, class ElseCallback>
+decltype(auto) if_constexpr(
+    ThenCallback&& thenCallback,
+    ElseCallback&& elseCallback) {
+#if defined(__cpp_if_constexpr)
+  // If we have C++17, just use it's "if constexpr" feature instead of wrapping
+  // it. This will give us better error messages.
+  if constexpr (Condition) {
+    if constexpr (detail::function_takes_identity_argument<
+                      ThenCallback>::value) {
+      // Note that we use static_cast<T&&>(t) instead of std::forward (or
+      // ::std::forward) because using the latter produces some compilation
+      // errors about ambiguous `std` on MSVC when using C++17. This static_cast
+      // is just what std::forward is doing under the hood, and is equivalent.
+      return static_cast<ThenCallback&&>(thenCallback)(detail::_identity());
+    } else {
+      return static_cast<ThenCallback&&>(thenCallback)();
+    }
+  } else {
+    if constexpr (detail::function_takes_identity_argument<
+                      ElseCallback>::value) {
+      return static_cast<ElseCallback&&>(elseCallback)(detail::_identity());
+    } else {
+      return static_cast<ElseCallback&&>(elseCallback)();
+    }
+  }
+#else
+  // C++14 implementation of if constexpr
+  return detail::_if_constexpr<Condition>::call(
+      static_cast<ThenCallback&&>(thenCallback),
+      static_cast<ElseCallback&&>(elseCallback));
+#endif
+}
+
+template <bool Condition, class ThenCallback>
+decltype(auto) if_constexpr(ThenCallback&& thenCallback) {
+#if defined(__cpp_if_constexpr)
+  // If we have C++17, just use it's "if constexpr" feature instead of wrapping
+  // it. This will give us better error messages.
+  if constexpr (Condition) {
+    if constexpr (detail::function_takes_identity_argument<
+                      ThenCallback>::value) {
+      // Note that we use static_cast<T&&>(t) instead of std::forward (or
+      // ::std::forward) because using the latter produces some compilation
+      // errors about ambiguous `std` on MSVC when using C++17. This static_cast
+      // is just what std::forward is doing under the hood, and is equivalent.
+      return static_cast<ThenCallback&&>(thenCallback)(detail::_identity());
+    } else {
+      return static_cast<ThenCallback&&>(thenCallback)();
+    }
+  }
+#else
+  // C++14 implementation of if constexpr
+  return if_constexpr<Condition>(
+      static_cast<ThenCallback&&>(thenCallback), [](auto) {});
+#endif
+}
+
+// GCC 4.8 doesn't define std::to_string, even though that's in C++11. Let's
+// define it.
+namespace detail {
+class DummyClassForToString final {};
+} // namespace detail
+} // namespace guts
+} // namespace c10
+namespace std {
+// We use SFINAE to detect if std::to_string exists for a type, but that only
+// works if the function name is defined. So let's define a std::to_string for a
+// dummy type. If you're getting an error here saying that this overload doesn't
+// match your std::to_string() call, then you're calling std::to_string() but
+// should be calling c10::guts::to_string().
+inline std::string to_string(c10::guts::detail::DummyClassForToString) {
+  return "";
+}
+
+} // namespace std
+namespace c10 {
+namespace guts {
+namespace detail {
+
+template <class T, class Enable = void>
+struct to_string_ final {
+  static std::string call(T value) {
+    std::ostringstream str;
+    str << value;
+    return str.str();
+  }
+};
+// If a std::to_string exists, use that instead
+template <class T>
+struct to_string_<T, void_t<decltype(std::to_string(std::declval<T>()))>>
+    final {
+  static std::string call(T value) {
+    return std::to_string(value);
+  }
+};
+} // namespace detail
+template <class T>
+inline std::string to_string(T value) {
+  return detail::to_string_<T>::call(value);
+}
+
+template <class T>
+constexpr const T& min(const T& a, const T& b) {
+  return (b < a) ? b : a;
+}
+
+template <class T>
+constexpr const T& max(const T& a, const T& b) {
+  return (a < b) ? b : a;
+}
+
 } // namespace guts
 } // namespace c10
 
diff --git a/c10/util/FunctionRef.h b/c10/util/FunctionRef.h
index 2c681dbd95..e792a3b003 100644
--- a/c10/util/FunctionRef.h
+++ b/c10/util/FunctionRef.h
@@ -48,6 +48,19 @@ class function_ref<Ret(Params...)> {
   function_ref() = default;
   function_ref(std::nullptr_t) {}
 
+#if defined(__APPLE__) && defined(__clang__)
+  template <typename Callable>
+  function_ref(
+      Callable&& callable,
+      typename std::enable_if<!std::is_same<
+          typename std::remove_reference<Callable>::type,
+          function_ref>::value>::type* = nullptr,
+      typename std::enable_if<std::is_convertible<
+          typename c10::invoke_result_t<Callable, Params...>,
+          Ret>::value>::type* = nullptr)
+      : callback(callback_fn<typename std::remove_reference<Callable>::type>),
+        callable(reinterpret_cast<intptr_t>(&callable)) {}
+#else
   template <typename Callable>
   function_ref(
       Callable&& callable,
@@ -59,6 +72,7 @@ class function_ref<Ret(Params...)> {
           Ret>::value>::type* = nullptr)
       : callback(callback_fn<typename std::remove_reference<Callable>::type>),
         callable(reinterpret_cast<intptr_t>(&callable)) {}
+#endif
 
   Ret operator()(Params... params) const {
     return callback(callable, std::forward<Params>(params)...);
diff --git a/c10/util/safe_numerics.h b/c10/util/safe_numerics.h
index 81c46aa23d..41e9230bd4 100644
--- a/c10/util/safe_numerics.h
+++ b/c10/util/safe_numerics.h
@@ -56,7 +56,7 @@ C10_ALWAYS_INLINE bool mul_overflows(uint64_t a, uint64_t b, uint64_t* out) {
 }
 
 C10_ALWAYS_INLINE bool mul_overflows(int64_t a, int64_t b, int64_t* out) {
-#if C10_HAS_BUILTIN_OVERFLOW()
+#if C10_HAS_BUILTIN_OVERFLOW() and !defined(__APPLE__) and !defined(__MACH__)
   return __builtin_mul_overflow(a, b, out);
 #else
   volatile int64_t tmp = a * b;
diff --git a/caffe2/CMakeLists.txt b/caffe2/CMakeLists.txt
index 9bdfbd10f3..3db1d8672f 100644
--- a/caffe2/CMakeLists.txt
+++ b/caffe2/CMakeLists.txt
@@ -93,16 +93,23 @@ if(INTERN_BUILD_ATEN_OPS)
   list(APPEND Caffe2_CPU_TEST_SRCS ${ATen_CORE_TEST_SRCS})
   list(APPEND Caffe2_VULKAN_TEST_SRCS ${ATen_VULKAN_TEST_SRCS})
   list(APPEND Caffe2_CPU_INCLUDE ${ATen_CPU_INCLUDE})
-  list(APPEND Caffe2_CPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include)
+  # list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include)
   list(APPEND Caffe2_HIP_INCLUDE ${ATen_HIP_INCLUDE})
   list(APPEND Caffe2_VULKAN_INCLUDE ${ATen_VULKAN_INCLUDE})
   list(APPEND Caffe2_DEPENDENCY_LIBS ${ATen_CPU_DEPENDENCY_LIBS} /Users/llv23/opt/miniconda3/lib/libomp.dylib)
   list(APPEND Caffe2_CUDA_DEPENDENCY_LIBS ${ATen_CUDA_DEPENDENCY_LIBS} /Users/llv23/opt/miniconda3/lib/libomp.dylib)
   list(APPEND Caffe2_HIP_DEPENDENCY_LIBS ${ATen_HIP_DEPENDENCY_LIBS})
-  list(APPEND Caffe2_DEPENDENCY_INCLUDE ${ATen_THIRD_PARTY_INCLUDE})
+  # list(APPEND Caffe2_DEPENDENCY_INCLUDE ${ATen_THIRD_PARTY_INCLUDE} ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
   set(Caffe2_CUDA_DEPENDENCY_LIBS ${Caffe2_CUDA_DEPENDENCY_LIBS} PARENT_SCOPE)
 endif()
 
+
+# if(USE_FLASH_ATTENTION AND NOT MSVC)
+#   list(APPEND Caffe2_CPU_INCLUDE ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+#   include_directories(${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+# endif()
+
 # ---[ Caffe2 build
 # Note: the folders that are being commented out have not been properly
 # addressed yet.
diff --git a/caffe2/serialize/inline_container_test.cc b/caffe2/serialize/inline_container_test.cc
index 4e027f6819..4fe2c236e0 100644
--- a/caffe2/serialize/inline_container_test.cc
+++ b/caffe2/serialize/inline_container_test.cc
@@ -464,16 +464,19 @@ TEST_P(ChunkRecordIteratorTest, ChunkRead) {
   LOG(INFO) << "Testing chunk size " << chunkSize;
   PyTorchStreamReader reader(fileName);
   ASSERT_TRUE(reader.hasRecord(recordName));
-  auto chunkIterator = reader.createChunkReaderIter(
+  #if !defined(__APPLE__) && !defined(__MACH__)
+  //see: to avoid "error: call to implicitly-deleted copy constructor of 'caffe2::serialize::ChunkRecordIterator'"
+  caffe2::serialize::ChunkRecordIterator chunkIterator = reader.createChunkReaderIter(
       recordName, tensorDataSizeInBytes, chunkSize);
   std::vector<uint8_t> buffer(chunkSize);
   size_t totalReadSize = 0;
-  while (auto readSize = chunkIterator.next(buffer.data())) {
-    auto expectedData = std::vector<uint8_t>(readSize, 1);
+  while (size_t readSize = chunkIterator.next(buffer.data())) {
+    std::vector<uint8_t> expectedData = std::vector<uint8_t>(readSize, 1);
     ASSERT_EQ(memcmp(expectedData.data(), buffer.data(), readSize), 0);
     totalReadSize += readSize;
   }
   ASSERT_EQ(totalReadSize, tensorDataSizeInBytes);
+  #endif
   // clean up
   remove(fileName);
 }
diff --git a/migration_note.md b/migration_note.md
index 1b595d9612..f063e72d4a 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -7,7 +7,6 @@ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=cl
 MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
 ```
 
-
 ## 1, Missing ATen cuda
 
 /usr/local/bin/ccache /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DUSE_CUDA_MPI=1 -DUSE_EXTERNAL_MZCRC -D_FILE_OFFSET_BITS=64 -Dcaffe2_nvrtc_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -D_LIBCPP_DISABLE_AVAILABILITY -fvisibility-inlines-hidden -DUSE_PTHREADPOOL -DNDEBUG -DUSE_KINETO -DLIBKINETO_NOCUPTI -DLIBKINETO_NOROCTRACER -DUSE_FBGEMM -DUSE_QNNPACK -DUSE_PYTORCH_QNNPACK -DUSE_XNNPACK -DSYMBOLICATE_MOBILE_DEBUG_HANDLE -O2 -fPIC -Wall -Wextra -Werror=return-type -Werror=non-virtual-dtor -Werror=braced-scalar-init -Wnarrowing -Wno-missing-field-initializers -Wno-type-limits -Wno-array-bounds -Wno-unknown-pragmas -Wno-unused-parameter -Wno-unused-function -Wno-unused-result -Wno-strict-overflow -Wno-strict-aliasing -Wvla-extension -Wnewline-eof -Winconsistent-missing-override -Winconsistent-missing-destructor-override -Wno-pass-failed -Wno-error=pedantic -Wno-error=old-style-cast -Wno-error=inconsistent-missing-override -Wno-error=inconsistent-missing-destructor-override -Wconstant-conversion -Wno-invalid-partial-specialization -Wno-aligned-allocation-unavailable -Wno-missing-braces -Qunused-arguments -fcolor-diagnostics -faligned-new -fno-math-errno -fno-trapping-math -Werror=format -Wno-unused-private-field -Wno-missing-braces -DHAVE_AVX2_CPU_DEFINITION -O3 -DNDEBUG -DNDEBUG -std=gnu++14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -mmacosx-version-min=10.9 -fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -MD -MT caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -MF caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o.d -o caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp
@@ -67,3 +66,26 @@ MetadataShape compute_variant_shape(const at::Tensor& input) {
   return MetadataShape{std::in_place_type<SymIntSmallVec>, input.sym_sizes()};
 #endif
 }
+
+## 3, Issue of loading include headers
+
+```bash
+[1075/1631] Building CUDA object caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu.o
+FAILED: caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu.o 
+/usr/local/bin/ccache /usr/local/cuda/bin/nvcc -forward-unknown-to-host-compiler -ccbin=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -DAT_PER_OPERATOR_HEADERS -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DTORCH_CUDA_BUILD_MAIN_LIB -DUSE_C10D_GLOO -DUSE_CUDA -DUSE_DISTRIBUTED -DUSE_EXPERIMENTAL_CUDNN_V8_API -DUSE_EXTERNAL_MZCRC -DUSE_RPC -DUSE_TENSORPIPE -D_FILE_OFFSET_BITS=64 -Dtorch_cuda_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/c10/cuda/../.. -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/c10/.. -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cutlass/include  -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/tensorpipe/third_party/libnop/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/torch/csrc/api -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/torch/csrc/api/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /usr/local/cuda/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cudnn_frontend/include -isystem /usr/local/lib/magma2.6.1-cu101/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cutlass/include -Xfatbin -compress-all -DONNX_NAMESPACE=onnx_torch -gencode arch=compute_61,code=sm_61 -Xcudafe --diag_suppress=cc_clobber_ignored,--diag_suppress=field_without_dll_interface,--diag_suppress=base_class_has_different_dll_interface,--diag_suppress=dll_interface_conflict_none_assumed,--diag_suppress=dll_interface_conflict_dllexport_assumed,--diag_suppress=bad_friend_decl --expt-relaxed-constexpr --expt-extended-lambda  -Wno-deprecated-gpu-targets --expt-extended-lambda -DCUDA_HAS_FP16=1 -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -g -std=c++14 -Xcompiler=-fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -Xcompiler=-Wall,-Wextra,-Wdeprecated,-Wno-unused-parameter,-Wno-unused-function,-Wno-missing-field-initializers,-Wno-unknown-pragmas,-Wno-type-limits,-Wno-array-bounds,-Wno-unknown-pragmas,-Wno-strict-overflow,-Wno-strict-aliasing -MD -MT caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu.o -MF caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu.o.d -x cu -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu -o caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu.o
+/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu:8:10: fatal error: 'cutlass/cutlass.h' file not found
+#include <cutlass/cutlass.h>
+         ^~~~~~~~~~~~~~~~~~~
+1 error generated.
+[1076/1631] Building CUDA object caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu.o
+FAILED: caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu.o 
+/usr/local/bin/ccache /usr/local/cuda/bin/nvcc -forward-unknown-to-host-compiler -ccbin=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -DAT_PER_OPERATOR_HEADERS -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DTORCH_CUDA_BUILD_MAIN_LIB -DUSE_C10D_GLOO -DUSE_CUDA -DUSE_DISTRIBUTED -DUSE_EXPERIMENTAL_CUDNN_V8_API -DUSE_EXTERNAL_MZCRC -DUSE_RPC -DUSE_TENSORPIPE -D_FILE_OFFSET_BITS=64 -Dtorch_cuda_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/c10/cuda/../.. -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/c10/.. -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/tensorpipe/third_party/libnop/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/torch/csrc/api -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/torch/csrc/api/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /usr/local/cuda/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cudnn_frontend/include -isystem /usr/local/lib/magma2.6.1-cu101/include -Xfatbin -compress-all -DONNX_NAMESPACE=onnx_torch -gencode arch=compute_61,code=sm_61 -Xcudafe --diag_suppress=cc_clobber_ignored,--diag_suppress=field_without_dll_interface,--diag_suppress=base_class_has_different_dll_interface,--diag_suppress=dll_interface_conflict_none_assumed,--diag_suppress=dll_interface_conflict_dllexport_assumed,--diag_suppress=bad_friend_decl --expt-relaxed-constexpr --expt-extended-lambda  -Wno-deprecated-gpu-targets --expt-extended-lambda -DCUDA_HAS_FP16=1 -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -g -std=c++14 -Xcompiler=-fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -Xcompiler=-Wall,-Wextra,-Wdeprecated,-Wno-unused-parameter,-Wno-unused-function,-Wno-missing-field-initializers,-Wno-unknown-pragmas,-Wno-type-limits,-Wno-array-bounds,-Wno-unknown-pragmas,-Wno-strict-overflow,-Wno-strict-aliasing -MD -MT caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu.o -MF caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu.o.d -x cu -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu -o caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu.o
+/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/native/nested/cuda/NestedTensorMatmul.cu:22:10: fatal error: 'cutlass/gemm/device/default_gemm_configuration.h' file not found
+#include <cutlass/gemm/device/default_gemm_configuration.h>
+```
+
+solution: correct the caffe2/CMakeLists.txt in Line 96 by 
+
+```cmake
+ list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+```
diff --git a/test/cpp/jit/test_flatbuffer.cpp b/test/cpp/jit/test_flatbuffer.cpp
index 2a631bf79e..3a2ba3b08f 100644
--- a/test/cpp/jit/test_flatbuffer.cpp
+++ b/test/cpp/jit/test_flatbuffer.cpp
@@ -65,8 +65,12 @@ TEST(FlatbufferTest, LoadMalformedModule) {
       torch::jit::load(bad_data), "Malformed Flatbuffer module");
 
   // Check guard at parse_and_initialize_mobile_module.
+  std::string str = bad_data.str(); // Assuming bad_data.str() returns a std::string
+  const void* cvptr = static_cast<const void*>(str.data()); // Safe: No cast away const-ness
+  // If you really need a non-const void* (be careful with this, as it allows modification which is unsafe)
+  void* vptr = const_cast<void*>(cvptr);
   ASSERT_THROWS_WITH_MESSAGE(
-      parse_mobile_module(bad_data.str().data(), bad_data.str().size()),
+      torch::jit::parse_mobile_module(vptr, bad_data.str().size()),
       "Malformed Flatbuffer module");
 }
 
diff --git a/test/cpp_extensions/open_registration_extension.cpp b/test/cpp_extensions/open_registration_extension.cpp
index 5818d647bc..6057393429 100644
--- a/test/cpp_extensions/open_registration_extension.cpp
+++ b/test/cpp_extensions/open_registration_extension.cpp
@@ -58,12 +58,12 @@ void quantize_tensor_per_tensor_affine_privateuse1(
     // do nothing
 }
 
-namespace at::native {
+namespace at{ namespace native {
 
 REGISTER_PRIVATEUSE1_DISPATCH(abs_stub, &abs_kernel);
 REGISTER_PRIVATEUSE1_DISPATCH(quantize_tensor_per_tensor_affine_stub, &quantize_tensor_per_tensor_affine_privateuse1);
 
-} // namespace at::native
+}} // namespace at::native
 struct CustomBackendMetadata : public c10::BackendMeta {
   // for testing this field will mutate when clone() is called by shallow_copy_from.
   int backend_version_format_{-1};
diff --git a/third_party/cutlass b/third_party/cutlass
index 44c704eae8..5a586c30b8 160000
--- a/third_party/cutlass
+++ b/third_party/cutlass
@@ -1 +1 @@
-Subproject commit 44c704eae85da352d277d6f092f41412772f70e4
+Subproject commit 5a586c30b81629fcf391c16f4314bb85dc5f23ff
diff --git a/third_party/pocketfft b/third_party/pocketfft
index ea778e3771..ad1eec0fb2 160000
--- a/third_party/pocketfft
+++ b/third_party/pocketfft
@@ -1 +1 @@
-Subproject commit ea778e37710c07723435b1be58235996d1d43a5a
+Subproject commit ad1eec0fb2f8bfb28e287c559a29bc16d059abf0
diff --git a/torch/csrc/Exceptions.cpp b/torch/csrc/Exceptions.cpp
index e9e3a74eb0..fd42fa73ae 100644
--- a/torch/csrc/Exceptions.cpp
+++ b/torch/csrc/Exceptions.cpp
@@ -286,7 +286,11 @@ PyObject* map_warning_to_python_type(const c10::Warning& warning) {
       return PyExc_DeprecationWarning;
     }
   };
+#if defined(__APPLE__) && defined(__MACH__)
+  return c10::visit(Visitor(), warning.type());
+#else
   return std::visit(Visitor(), warning.type());
+#endif
 }
 
 /// See NOTE [ Conversion Cpp Python Warning ] for noexcept justification
diff --git a/torch/csrc/Generator.cpp b/torch/csrc/Generator.cpp
index 4da08d8bac..a8267893cd 100644
--- a/torch/csrc/Generator.cpp
+++ b/torch/csrc/Generator.cpp
@@ -94,7 +94,11 @@ static PyObject* THPGenerator_getState(PyObject* _self, PyObject* noargs) {
   auto& gen = ((THPGenerator*)_self)->cdata;
 
   // See Note [Acquire lock when using random generators]
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(gen.mutex());
+#else
   std::scoped_lock<std::mutex> lock(gen.mutex());
+#endif
   auto state_tensor = gen.get_state();
 
   return THPVariable_Wrap(std::move(state_tensor));
@@ -115,7 +119,11 @@ static PyObject* THPGenerator_setState(PyObject* _self, PyObject* _new_state) {
   const auto& new_state_tensor = THPVariable_Unpack(_new_state);
 
   // See Note [Acquire lock when using random generators]
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(gen.mutex());
+#else
   std::scoped_lock<std::mutex> lock(gen.mutex());
+#endif
   gen.set_state(new_state_tensor);
 
   Py_INCREF(self);
@@ -154,7 +162,11 @@ static PyObject* THPGenerator_manualSeed(PyObject* _self, PyObject* seed) {
       THPUtils_typename(seed));
   uint64_t unsigned_seed = unpack_uint64(seed);
   // See Note [Acquire lock when using random generators]
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(generator.mutex());
+#else
   std::scoped_lock<std::mutex> lock(generator.mutex());
+#endif
   generator.set_current_seed(unsigned_seed);
   Py_INCREF(self);
   return (PyObject*)self;
@@ -172,7 +184,11 @@ static PyObject* THPGenerator_setOffset(PyObject* _self, PyObject* offset) {
       THPUtils_typename(offset));
   uint64_t unsigned_offset = unpack_uint64(offset);
   // See Note [Acquire lock when using random generators]
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(generator.mutex());
+#else
   std::scoped_lock<std::mutex> lock(generator.mutex());
+#endif
   generator.set_offset(unsigned_offset);
   Py_INCREF(self);
   return (PyObject*)self;
@@ -183,7 +199,11 @@ static PyObject* THPGenerator_seed(PyObject* _self, PyObject* noargs) {
   HANDLE_TH_ERRORS
   // See Note [Acquire lock when using random generators]
   auto self = (THPGenerator*)_self;
+#if defined(__APPLE__) && defined(__MACH__)
+  std::unique_lock<std::mutex> lock(self->cdata.mutex());
+#else
   std::scoped_lock<std::mutex> lock(self->cdata.mutex());
+#endif
   uint64_t seed_val = self->cdata.seed();
   return THPUtils_packUInt64(seed_val);
   END_HANDLE_TH_ERRORS
diff --git a/torch/csrc/PyInterpreter.cpp b/torch/csrc/PyInterpreter.cpp
index 3cd16ea7b9..2f28226d04 100644
--- a/torch/csrc/PyInterpreter.cpp
+++ b/torch/csrc/PyInterpreter.cpp
@@ -677,7 +677,7 @@ static c10::ArrayRef<T> get_set_cached_attr(
     TORCH_INTERNAL_ASSERT(curr_buffer_size >= new_size);
     for (auto it = obj.begin(); it != obj.end(); ++it, ++idx) {
       auto actual_val = py::cast<T>(*it);
-      if constexpr (std::is_same_v<T, c10::SymInt>) {
+      if constexpr (std::is_same<T, c10::SymInt>::value) {
         // if our SymInts are symbolic, we are *not* doing an equality check on
         // the symints. we just want to see if the nodes are the same. this is
         // because we don't want to introduce any guards here.
diff --git a/torch/csrc/api/include/torch/all.h b/torch/csrc/api/include/torch/all.h
index 0d2eca3188..0da9122bc5 100644
--- a/torch/csrc/api/include/torch/all.h
+++ b/torch/csrc/api/include/torch/all.h
@@ -1,7 +1,8 @@
 #pragma once
 
-#if !defined(_MSC_VER) && __cplusplus < 201703L
-#error C++17 or later compatible compiler is required to use PyTorch.
+// see: refer to https://stackoverflow.com/questions/26089319/is-there-a-standard-definition-for-cplusplus-in-c14
+#if !defined(_MSC_VER) && __cplusplus < 201402L
+#error C++14 or later compatible compiler is required to use PyTorch.
 #endif
 
 #include <torch/autograd.h>
diff --git a/torch/csrc/autograd/profiler_python.cpp b/torch/csrc/autograd/profiler_python.cpp
index da1cedfdb5..982c745d24 100644
--- a/torch/csrc/autograd/profiler_python.cpp
+++ b/torch/csrc/autograd/profiler_python.cpp
@@ -1076,7 +1076,11 @@ std::vector<std::shared_ptr<Result>> PythonTracer::getEvents(
 
   PythonIDVisitor id_visitor;
   for (auto& i : out) {
+#if defined(__APPLE__) && defined(__MACH__)
+    c10::visit(id_visitor, i->extra_fields_);
+#else
     std::visit(id_visitor, i->extra_fields_);
+#endif
   }
 
   return out;
diff --git a/torch/csrc/dynamo/guards.cpp b/torch/csrc/dynamo/guards.cpp
index 45b0e1f77f..4fe400d2ff 100644
--- a/torch/csrc/dynamo/guards.cpp
+++ b/torch/csrc/dynamo/guards.cpp
@@ -8,6 +8,10 @@
 #include <torch/extension.h>
 #include <sstream>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#endif
+
 namespace {
 
 struct LocalState {
@@ -30,8 +34,8 @@ class TensorCheck {
       const LocalState& state,
       PyTypeObject* pt,
       const at::Tensor& v,
-      std::vector<std::optional<c10::SymInt>> dynamic_dims_sizes,
-      std::vector<std::optional<c10::SymInt>> dynamic_dims_strides)
+      std::vector<c10::optional<c10::SymInt>> dynamic_dims_sizes,
+      std::vector<c10::optional<c10::SymInt>> dynamic_dims_strides)
       : pytype(pt),
         dispatch_key_(state.apply(v.key_set()).raw_repr()),
         dtype_(v.dtype().toScalarType()),
@@ -146,8 +150,8 @@ class TensorCheck {
   at::DeviceIndex device_index_;
   bool requires_grad_;
   // NB: These are unset if dynamic shapes is enabled.
-  std::vector<std::optional<c10::SymInt>> sizes_;
-  std::vector<std::optional<c10::SymInt>> strides_;
+  std::vector<c10::optional<c10::SymInt>> sizes_;
+  std::vector<c10::optional<c10::SymInt>> strides_;
   // Not strictly required for dense tensors, but nested tensors need it.
   int64_t dim_;
 };
@@ -178,26 +182,26 @@ static PyObject* TensorGuards_new(
   return (PyObject*)self;
 }
 
-static std::vector<std::optional<c10::SymInt>> wrapIntegersInOptional(
+static std::vector<c10::optional<c10::SymInt>> wrapIntegersInOptional(
     const c10::SymIntArrayRef& intArray) {
-  std::vector<std::optional<c10::SymInt>> optVec(intArray.size());
+  std::vector<c10::optional<c10::SymInt>> optVec(intArray.size());
   std::transform(
       intArray.begin(),
       intArray.end(),
       optVec.begin(),
-      [](const c10::SymInt& value) { return std::make_optional(value); });
+      [](const c10::SymInt& value) { return c10::make_optional(value); });
   return optVec;
 }
 
-static std::vector<std::optional<c10::SymInt>> pyListToVecOptInt(
+static std::vector<c10::optional<c10::SymInt>> pyListToVecOptInt(
     PyObject* pyList) {
-  std::vector<std::optional<c10::SymInt>> vec;
+  std::vector<c10::optional<c10::SymInt>> vec;
   Py_ssize_t size = PyList_Size(pyList);
   for (Py_ssize_t i = 0; i < size; i++) {
     PyObject* item = PyList_GetItem(pyList, i);
     auto handle = py::handle(item);
     if (item == Py_None) {
-      vec.emplace_back(std::nullopt);
+      vec.emplace_back(c10::nullopt);
     } else if (torch::is_symint(handle)) {
       vec.emplace_back(py::cast<c10::SymInt>(handle));
     } else {
@@ -214,14 +218,14 @@ static std::vector<std::optional<c10::SymInt>> pyListToVecOptInt(
   return vec;
 }
 
-static std::vector<std::vector<std::optional<c10::SymInt>>> get_dynamic_dims(
+static std::vector<std::vector<c10::optional<c10::SymInt>>> get_dynamic_dims(
     PyObject* dynamic_dims_py) {
-  std::vector<std::vector<std::optional<c10::SymInt>>> per_tensor_dynamic_dims;
+  std::vector<std::vector<c10::optional<c10::SymInt>>> per_tensor_dynamic_dims;
   if (dynamic_dims_py != Py_None) {
     Py_ssize_t size = PyList_Size(dynamic_dims_py);
     for (Py_ssize_t i = 0; i < size; i++) {
       PyObject* py_list = PyList_GetItem(dynamic_dims_py, i);
-      std::vector<std::optional<c10::SymInt>> vec = pyListToVecOptInt(py_list);
+      std::vector<c10::optional<c10::SymInt>> vec = pyListToVecOptInt(py_list);
       per_tensor_dynamic_dims.push_back(std::move(vec));
     }
   }
@@ -252,9 +256,9 @@ static int TensorGuards_init(
 
   // dynamic_dims_strides/sizes_py is None when dynamic_shapes=False - this is
   // an optimization to avoid invoking .size()/.stride() in python needlessly
-  std::vector<std::vector<std::optional<c10::SymInt>>>
+  std::vector<std::vector<c10::optional<c10::SymInt>>>
       per_tensor_dynamic_dims_sizes = get_dynamic_dims(dynamic_dims_sizes_py);
-  std::vector<std::vector<std::optional<c10::SymInt>>>
+  std::vector<std::vector<c10::optional<c10::SymInt>>>
       per_tensor_dynamic_dims_strides =
           get_dynamic_dims(dynamic_dims_strides_py);
 
@@ -270,11 +274,11 @@ static int TensorGuards_init(
       return -1;
     }
     auto tensor = THPVariable_Unpack(item);
-    std::vector<std::optional<c10::SymInt>> tensor_dims_size =
+    std::vector<c10::optional<c10::SymInt>> tensor_dims_size =
         per_tensor_dynamic_dims_sizes.empty()
         ? wrapIntegersInOptional(tensor.sym_sizes())
         : per_tensor_dynamic_dims_sizes[i];
-    std::vector<std::optional<c10::SymInt>> tensor_dims_stride =
+    std::vector<c10::optional<c10::SymInt>> tensor_dims_stride =
         per_tensor_dynamic_dims_strides.empty()
         ? wrapIntegersInOptional(tensor.sym_strides())
         : per_tensor_dynamic_dims_strides[i];
diff --git a/torch/csrc/jit/runtime/static/ops.cpp b/torch/csrc/jit/runtime/static/ops.cpp
index 028bd2fff3..4e53a65882 100644
--- a/torch/csrc/jit/runtime/static/ops.cpp
+++ b/torch/csrc/jit/runtime/static/ops.cpp
@@ -48,7 +48,7 @@ C10_DEFINE_bool(
     "If on, static runtime may use use optimizations that cause accuracy loss "
     "vs the jit interpreter");
 
-namespace at::native {
+namespace at{ namespace native {
 
 static void repeat_out(
     at::Tensor& result,
@@ -374,7 +374,7 @@ static at::Tensor& dequantize_copy_out(Tensor& out, const Tensor& self) {
   }
   return get_qtensorimpl(self)->quantizer()->dequantize_out(out, self);
 }
-} // namespace at::native
+}} // namespace at::native
 
 namespace torch::jit {
 
diff --git a/torch/csrc/jit/runtime/static/ops.h b/torch/csrc/jit/runtime/static/ops.h
index 53aa0dc787..39ef1972de 100644
--- a/torch/csrc/jit/runtime/static/ops.h
+++ b/torch/csrc/jit/runtime/static/ops.h
@@ -4,7 +4,7 @@
 #include <torch/csrc/jit/ir/ir.h>
 #include <torch/csrc/jit/runtime/static/impl.h>
 
-namespace at::native {
+namespace at{ namespace native {
 at::Tensor& reshape_copy_out(
     at::Tensor& out,
     const at::Tensor& self,
@@ -16,7 +16,7 @@ at::Tensor& to_copy_out(
     bool non_blocking,
     bool copy_strides,
     c10::optional<MemoryFormat> memory_format);
-} // namespace at::native
+}} // namespace at::native
 
 namespace torch::jit {
 
diff --git a/torch/csrc/monitor/python_init.cpp b/torch/csrc/monitor/python_init.cpp
index d6ac4f312c..0e301d113a 100644
--- a/torch/csrc/monitor/python_init.cpp
+++ b/torch/csrc/monitor/python_init.cpp
@@ -13,6 +13,10 @@
 #include <torch/csrc/monitor/counters.h>
 #include <torch/csrc/monitor/events.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#endif
+
 namespace pybind11 {
 namespace detail {
 template <>
@@ -42,18 +46,18 @@ struct type_caster<torch::monitor::data_value_t> {
       torch::monitor::data_value_t src,
       return_value_policy /* policy */,
       handle /* parent */) {
-    if (std::holds_alternative<double>(src)) {
-      return PyFloat_FromDouble(std::get<double>(src));
-    } else if (std::holds_alternative<int64_t>(src)) {
-      return THPUtils_packInt64(std::get<int64_t>(src));
-    } else if (std::holds_alternative<bool>(src)) {
-      if (std::get<bool>(src)) {
+    if (c10::holds_alternative<double>(src)) {
+      return PyFloat_FromDouble(c10::get<double>(src));
+    } else if (c10::holds_alternative<int64_t>(src)) {
+      return THPUtils_packInt64(c10::get<int64_t>(src));
+    } else if (c10::holds_alternative<bool>(src)) {
+      if (c10::get<bool>(src)) {
         Py_RETURN_TRUE;
       } else {
         Py_RETURN_FALSE;
       }
-    } else if (std::holds_alternative<std::string>(src)) {
-      std::string str = std::get<std::string>(src);
+    } else if (c10::holds_alternative<std::string>(src)) {
+      std::string str = c10::get<std::string>(src);
       return THPUtils_packString(str);
     }
     throw std::runtime_error("unknown data_value_t type");
diff --git a/torch/csrc/profiler/collection.h b/torch/csrc/profiler/collection.h
index b6cbd27b32..bf35d6a1f9 100644
--- a/torch/csrc/profiler/collection.h
+++ b/torch/csrc/profiler/collection.h
@@ -384,7 +384,7 @@ struct TORCH_API Result : public std::enable_shared_from_this<Result> {
       using extra_fields_t = typename std::remove_cv_t<
           typename std::remove_reference_t<decltype(extra_fields)>>;
 
-      if constexpr (std::is_base_of_v<T, extra_fields_t>) {
+      if constexpr (std::is_base_of<T, extra_fields_t>::value) {
         fn(extra_fields);
       }
     });
diff --git a/torch/csrc/profiler/containers.h b/torch/csrc/profiler/containers.h
index 3de4930ad9..a5e368fac9 100644
--- a/torch/csrc/profiler/containers.h
+++ b/torch/csrc/profiler/containers.h
@@ -48,7 +48,7 @@ class AppendOnlyList {
  public:
   using array_t = block_t<T, ChunkSize>;
   static_assert(
-      std::is_base_of_v<std::array<T, ChunkSize>, array_t>,
+      std::is_base_of<std::array<T, ChunkSize>, array_t>::value,
       "AppendOnlyList expects raw low level pointer storage.");
   static_assert(ChunkSize > 0, "Block cannot be empty.");
 
@@ -64,8 +64,8 @@ class AppendOnlyList {
   T* emplace_back(Args&&... args) {
     maybe_grow();
     if constexpr (
-        std::is_trivially_destructible_v<T> &&
-        std::is_trivially_destructible_v<array_t>) {
+        std::is_trivially_destructible<T>::value &&
+        std::is_trivially_destructible<array_t>::value) {
       ::new ((void*)next_) T{std::forward<Args>(args)...};
     } else {
       *next_ = T{std::forward<Args>(args)...};
diff --git a/torch/csrc/profiler/python/init.cpp b/torch/csrc/profiler/python/init.cpp
index e6254c323a..2c5635c720 100644
--- a/torch/csrc/profiler/python/init.cpp
+++ b/torch/csrc/profiler/python/init.cpp
@@ -10,6 +10,10 @@
 #include <torch/csrc/profiler/standalone/execution_trace_observer.h>
 #include <torch/csrc/utils/pybind.h>
 
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#endif
+
 struct THPCapturedTraceback {
   PyObject_HEAD std::shared_ptr<torch::CapturedTraceback> data;
 };
@@ -389,6 +393,16 @@ void initPythonBindings(PyObject* module) {
           [](const torch_op_t& op) {
             py::list out;
             for (const auto& input : op.inputs_) {
+#if defined(__APPLE__) && defined(__MACH__)
+              c10::visit(
+                  c10::overloaded(
+                      [&](const c10::IValue& v) {
+                        out.append(torch::jit::toPyObject(v));
+                      },
+                      [&](const c10::nullopt_t&) { out.append(py::none()); },
+                      [&](const auto& v) { out.append(py::cast(v)); }),
+                  input);
+#else
               std::visit(
                   c10::overloaded(
                       [&](const c10::IValue& v) {
@@ -397,6 +411,7 @@ void initPythonBindings(PyObject* module) {
                       [&](const c10::nullopt_t&) { out.append(py::none()); },
                       [&](const auto& v) { out.append(py::cast(v)); }),
                   input);
+#endif
             }
             return out;
           })
diff --git a/torch/csrc/utils/python_raii.h b/torch/csrc/utils/python_raii.h
index 70a5ddfeb5..abbc5f7737 100644
--- a/torch/csrc/utils/python_raii.h
+++ b/torch/csrc/utils/python_raii.h
@@ -1,6 +1,11 @@
 #include <c10/util/Optional.h>
 #include <torch/csrc/utils/pybind.h>
 #include <tuple>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/C++17.h>
+#include <tuple>
+#include <c10/util/variant.h>
+#endif
 
 namespace torch {
 namespace impl {
@@ -14,7 +19,7 @@ struct RAIIContextManager {
     auto emplace = [&](Args... args) {
       guard_.emplace(std::forward<Args>(args)...);
     };
-    std::apply(std::move(emplace), args_);
+    c10::guts::apply(std::move(emplace), args_);
   }
 
   void exit() {
-- 
2.17.2 (Apple Git-113)


From 39798de17b24a19ee22bb74b40c2a57ab8718c65 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Mon, 12 Feb 2024 22:28:43 -0800
Subject: [PATCH 03/14] orlando - for updates of settings

---
 third_party/cutlass | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/third_party/cutlass b/third_party/cutlass
index 5a586c30b8..63fc6f05ff 160000
--- a/third_party/cutlass
+++ b/third_party/cutlass
@@ -1 +1 @@
-Subproject commit 5a586c30b81629fcf391c16f4314bb85dc5f23ff
+Subproject commit 63fc6f05ffbfa66ca9e5548a041517bb6100e52c
-- 
2.17.2 (Apple Git-113)


From 294eccdd7cdd9d2ac8c9758290c423fedf8dd277 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Tue, 13 Feb 2024 10:06:23 -0800
Subject: [PATCH 04/14] orlando - for updates of tensorpipe settings

---
 migration_note.md | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/migration_note.md b/migration_note.md
index f063e72d4a..d0cf1e1d10 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -1,5 +1,7 @@
 # Migration note
 
+Preparation of building library:
+
 ```bash
 export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
 export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
@@ -9,11 +11,14 @@ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=cl
 
 ## 1, Missing ATen cuda
 
+```bash
 /usr/local/bin/ccache /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DUSE_CUDA_MPI=1 -DUSE_EXTERNAL_MZCRC -D_FILE_OFFSET_BITS=64 -Dcaffe2_nvrtc_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -D_LIBCPP_DISABLE_AVAILABILITY -fvisibility-inlines-hidden -DUSE_PTHREADPOOL -DNDEBUG -DUSE_KINETO -DLIBKINETO_NOCUPTI -DLIBKINETO_NOROCTRACER -DUSE_FBGEMM -DUSE_QNNPACK -DUSE_PYTORCH_QNNPACK -DUSE_XNNPACK -DSYMBOLICATE_MOBILE_DEBUG_HANDLE -O2 -fPIC -Wall -Wextra -Werror=return-type -Werror=non-virtual-dtor -Werror=braced-scalar-init -Wnarrowing -Wno-missing-field-initializers -Wno-type-limits -Wno-array-bounds -Wno-unknown-pragmas -Wno-unused-parameter -Wno-unused-function -Wno-unused-result -Wno-strict-overflow -Wno-strict-aliasing -Wvla-extension -Wnewline-eof -Winconsistent-missing-override -Winconsistent-missing-destructor-override -Wno-pass-failed -Wno-error=pedantic -Wno-error=old-style-cast -Wno-error=inconsistent-missing-override -Wno-error=inconsistent-missing-destructor-override -Wconstant-conversion -Wno-invalid-partial-specialization -Wno-aligned-allocation-unavailable -Wno-missing-braces -Qunused-arguments -fcolor-diagnostics -faligned-new -fno-math-errno -fno-trapping-math -Werror=format -Wno-unused-private-field -Wno-missing-braces -DHAVE_AVX2_CPU_DEFINITION -O3 -DNDEBUG -DNDEBUG -std=gnu++14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -mmacosx-version-min=10.9 -fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -MD -MT caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -MF caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o.d -o caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp
+```
 
 ## 2, Migrating from c10 to std
 
-#if defined(__APPLE__) && defined(__MACH__)
+```c++
+# if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 namespace std {
   using ::c10::variant;
@@ -25,8 +30,9 @@ namespace std {
 #else
 #include <variant>
 #endif
+```
 
-
+```c++
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/Optional.h>
 namespace std {
@@ -35,22 +41,30 @@ namespace std {
 #else
 #include <optional>
 #endif
+```
 
+```c++
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 #endif
+```
 
+```c++
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 #else
 #include <variant>
 #endif
+```
 
+```c++
 #if defined(__APPLE__) && defined(__MACH__)
 c10::visit
 #else
 #endif 
+```
 
+```c++
 MetadataShape compute_variant_shape(const at::Tensor& input) {
   if (input.is_nested() && !input.unsafeGetTensorImpl()->is_python_dispatch()) {
     auto nested_size = input._nested_tensor_size();
@@ -66,6 +80,7 @@ MetadataShape compute_variant_shape(const at::Tensor& input) {
   return MetadataShape{std::in_place_type<SymIntSmallVec>, input.sym_sizes()};
 #endif
 }
+```
 
 ## 3, Issue of loading include headers
 
@@ -84,7 +99,7 @@ FAILED: caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/Nes
 #include <cutlass/gemm/device/default_gemm_configuration.h>
 ```
 
-solution: correct the caffe2/CMakeLists.txt in Line 96 by 
+Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.11.0, a prior version to 3.0.0 for CUDA 11.x
 
 ```cmake
  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
-- 
2.17.2 (Apple Git-113)


From 49f18e626e3c2a1c7e18fdca0dece3bf92b04d03 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Fri, 16 Feb 2024 23:01:56 -0800
Subject: [PATCH 05/14] orlando - for updates of torch 2.2.0, but meeting with
 issues

---
 aten/src/ATen/cuda/CUDABlas.cpp               | 177 ++++++++++++++++--
 .../sparse/cuda/SparseSemiStructuredLinear.cu |   4 +-
 c10/util/Optional.cpp                         |  17 ++
 c10/util/Optional.h                           |   6 +-
 migration_note.md                             |  59 +++++-
 third_party/cutlass                           |   2 +-
 torch/csrc/distributed/c10d/init.cpp          |  10 +-
 torch/csrc/distributed/rpc/init.cpp           |   6 +-
 8 files changed, 256 insertions(+), 25 deletions(-)

diff --git a/aten/src/ATen/cuda/CUDABlas.cpp b/aten/src/ATen/cuda/CUDABlas.cpp
index a161786074..c58a987680 100644
--- a/aten/src/ATen/cuda/CUDABlas.cpp
+++ b/aten/src/ATen/cuda/CUDABlas.cpp
@@ -15,6 +15,27 @@
 // added bf16 support
 #if !defined(USE_ROCM) && !defined(_MSC_VER)
 #include <cublasLt.h>
+
+#if defined(__APPLE__) && defined(__MACH__)
+/** Semi-opaque descriptor for cublasLtMatmul() operation details
+ */
+typedef struct {
+  uint64_t data[32];
+} cublasLtMatmulDescOpaque_t;
+
+/** Semi-opaque descriptor for matrix memory layout
+ */
+typedef struct {
+  uint64_t data[8];
+} cublasLtMatrixLayoutOpaque_t;
+
+/** Semi-opaque descriptor for cublasLtMatmulPreference() operation details
+ */
+typedef struct {
+  uint64_t data[8];
+} cublasLtMatmulPreferenceOpaque_t;
+#endif
+
 #endif
 
 // refer to http://www.jcuda.org/jcuda/jcublas/doc/constant-values.html#jcuda.jcublas.cublasMath.CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION
@@ -205,10 +226,60 @@ static size_t _getWorkspaceSize() {
 
 } // anonymous namespace
 
-namespace at::cuda::blas {
+namespace at{ namespace cuda{ namespace blas {
 
 /* LEVEL 3 BLAS FUNCTIONS */
 
+#ifndef USE_ROCM
+#if defined(CUDA_VERSION) && CUDA_VERSION >= 11020
+#define cublasGemmStridedBatchedExFix cublasGemmStridedBatchedEx
+#else
+// Workaround for https://github.com/pytorch/pytorch/issues/45724
+cublasStatus_t cublasGemmStridedBatchedExFix(cublasHandle_t &handle,
+  cublasOperation_t transa,
+  cublasOperation_t transb,
+  int m,
+  int n,
+  int k,
+  const void    *alpha,
+  const void     *A,
+  cudaDataType Atype,
+  int lda,
+  long long int strideA,
+  const void     *B,
+  cudaDataType Btype,
+  int ldb,
+  long long int strideB,
+  const void    *beta,
+  void           *C,
+  cudaDataType Ctype,
+  int ldc,
+  long long int strideC,
+  int64_t batchCount,
+  cudaDataType computeType,
+  cublasGemmAlgo_t algo)
+{
+  cudaDeviceProp* prop = at::cuda::getCurrentDeviceProperties();
+  if (prop->major != 7) {
+    return cublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, strideA, B, Btype, ldb, strideB, beta, C, Ctype, ldc, strideC, batchCount, computeType, algo);
+  }
+  cublasStatus_t result;
+  constexpr int64_t split = 63 * 1024;
+  for(int64_t i = 0; i < batchCount; i += split) {
+    int64_t count = std::min<int64_t>(split, batchCount - i);
+    result = cublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha,
+      (char *)A + i * strideA * 2, Atype, lda, strideA,
+      (char *)B + i * strideB * 2, Btype, ldb, strideB,
+      beta,
+      (char *)C + i * strideC * 2, Ctype, ldc, strideC,
+      (int)count, computeType, algo);
+    TORCH_CUDABLAS_CHECK(result);
+  }
+  return result;
+}
+#endif
+#endif
+
 #define GEMM_CHECK_ARGVALUES(Dtype)           \
   do {                                        \
     CUDABLAS_NONNEGINT_CHECK(gemm<Dtype>, m); \
@@ -527,7 +598,43 @@ void gemm<at::Half>(CUDABLAS_GEMM_ARGTYPES(at::Half)) {
 #endif
 }
 
-#if !defined(USE_ROCM)
+#ifdef defined(USE_ROCM)
+template <>
+void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
+  cublasHandle_t handle = at::cuda::getCurrentCUDABlasHandle();
+  cublasOperation_t opa = _cublasOpFromChar(transa);
+  cublasOperation_t opb = _cublasOpFromChar(transb);
+  float falpha = alpha;
+  float fbeta = beta;
+  _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
+  GEMM_CHECK_ARGVALUES(at::BFloat16);
+  TORCH_CUDABLAS_CHECK(rocblas_gemm_ex(
+      handle,
+      opa,
+      opb,
+      m,
+      n,
+      k,
+      &falpha,
+      a,
+      rocblas_datatype_bf16_r,
+      lda,
+      b,
+      rocblas_datatype_bf16_r,
+      ldb,
+      &fbeta,
+      c,
+      rocblas_datatype_bf16_r,
+      ldc,
+      c,
+      rocblas_datatype_bf16_r,
+      ldc,
+      rocblas_datatype_f32_r,
+      rocblas_gemm_algo_standard,
+      0,
+      0));
+}
+#else
 template <>
 void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
   globalContext().alertCuBLASConfigNotDeterministic();
@@ -567,7 +674,7 @@ void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
 }
 #endif // !defined(USE_ROCM)
 
-#if !defined(USE_ROCM) && !defined(_MSC_VER) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
+#if !defined(USE_ROCM) && !defined(_MSC_VER)
 
 namespace {
 // Following the pattern of CuSparseDescriptor
@@ -597,6 +704,24 @@ class CuBlasLtDescriptor {
   std::unique_ptr<T, CuBlasLtDeleter<T, destructor>> descriptor_;
 };
 
+#if defined(__APPLE__) && defined(__MACH__)
+class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
+                                     cublasLtMatmulDescStruct,
+                                     &cublasLtMatmulDescDestroy> {
+ public:
+  CuBlasLtMatmulDescriptor(
+      cudaDataType_t scale_type) {
+    cublasLtMatmulDesc_t raw_descriptor = nullptr;
+    TORCH_CUDABLAS_CHECK(
+        cublasLtMatmulDescCreate(&raw_descriptor, scale_type));
+    descriptor_.reset(raw_descriptor);
+  }
+  template <typename T>
+  inline void setAttribute(cublasLtMatmulDescAttributes_t attr, const T value) {
+    TORCH_CUDABLAS_CHECK(::cublasLtMatmulDescSetAttribute(descriptor(), attr, &value, sizeof(T)));
+  }
+};
+#else
 class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
                                      cublasLtMatmulDescOpaque_t,
                                      &cublasLtMatmulDescDestroy> {
@@ -614,9 +739,10 @@ class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
     TORCH_CUDABLAS_CHECK(::cublasLtMatmulDescSetAttribute(descriptor(), attr, &value, sizeof(T)));
   }
 };
+#endif
 
 class CuBlasLtMatrixLayout : public CuBlasLtDescriptor<
-                                 cublasLtMatrixLayoutOpaque_t,
+                                 cublasLtMatrixLayoutStruct,
                                  &cublasLtMatrixLayoutDestroy> {
  public:
   CuBlasLtMatrixLayout(
@@ -633,7 +759,7 @@ class CuBlasLtMatrixLayout : public CuBlasLtDescriptor<
 };
 
 class CuBlasLtMatmulPreference : public CuBlasLtDescriptor<
-                                     cublasLtMatmulPreferenceOpaque_t,
+                                     cublasLtMatmulPreferenceStruct,
                                      &cublasLtMatmulPreferenceDestroy> {
  public:
   CuBlasLtMatmulPreference() {
@@ -648,8 +774,6 @@ class CuBlasLtMatmulPreference : public CuBlasLtDescriptor<
 };
 } // namespace
 
-
-#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
 template <typename Dtype>
 void gemm_and_bias(
     bool transpose_mat1,
@@ -670,24 +794,38 @@ void gemm_and_bias(
   opmath_t beta_val = 0; // bias is added in epilogue
 
   cudaDataType_t abcType = CUDA_R_32F;
+#if !defined(__APPLE__) && !defined(__MACH__)
   cublasComputeType_t computeType = CUBLAS_COMPUTE_32F;
+#endif
   cudaDataType_t scaleType = CUDA_R_32F;
-  if constexpr (std::is_same_v<Dtype, double>) {
+  if constexpr (std::is_same<Dtype, double>::value) {
     abcType = CUDA_R_64F;
+#if !defined(__APPLE__) && !defined(__MACH__)
     computeType = CUBLAS_COMPUTE_64F;
+#endif
     scaleType = CUDA_R_64F;
-  } else if constexpr (std::is_same_v<Dtype, float>) {
+  } else if constexpr (std::is_same<Dtype, float>::value) {
+#if !defined(__APPLE__) && !defined(__MACH__)
     if (at::globalContext().allowTF32CuBLAS()) {
       computeType = CUBLAS_COMPUTE_32F_FAST_TF32;
     }
+#endif
     abcType = CUDA_R_32F;
-  } else if constexpr (std::is_same_v<Dtype, at::Half>) {
+  } else if constexpr (std::is_same<Dtype, at::Half>::value) {
     abcType = CUDA_R_16F;
-  } else if constexpr (std::is_same_v<Dtype, at::BFloat16>) {
+  } else if constexpr (std::is_same<Dtype, at::BFloat16>::value) {
+#if !defined(__APPLE__) && !defined(__MACH__)
     abcType = CUDA_R_16BF;
+#else
+    abcType = CUDA_R_16F;
+#endif
   }
 
+#if defined(__APPLE__) && defined(__MACH__)
+  CuBlasLtMatmulDescriptor computeDesc(scaleType);
+#else
   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
+#endif
   cublasOperation_t transa = transpose_mat1 ? CUBLAS_OP_T : CUBLAS_OP_N;
   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, transa);
   cublasOperation_t transb = transpose_mat2 ? CUBLAS_OP_T : CUBLAS_OP_N;
@@ -783,8 +921,10 @@ void gemm_and_bias(
       result_ld,
       " abcType ",
       abcType,
+#if !defined(__APPLE__) && !defined(__MACH__)
       " computeType ",
       computeType,
+#endif
       " scaleType ",
       scaleType);
 }
@@ -852,7 +992,6 @@ template void gemm_and_bias(
     at::BFloat16* result_ptr,
     int64_t result_ld,
     GEMMAndBiasActivationEpilogue activation);
-#endif
 
 void scaled_gemm(
     char transa,
@@ -880,7 +1019,11 @@ void scaled_gemm(
   const auto computeType = CUBLAS_COMPUTE_32F;
   const auto scaleType = CUDA_R_32F;
   const int8_t fastAccuMode = use_fast_accum ? 1 : 0;
+#if defined(__APPLE__) && defined(__MACH__)
+  CuBlasLtMatmulDescriptor computeDesc(scaleType);
+#else
   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
+#endif
   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, _cublasOpFromChar(transa));
   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSB, _cublasOpFromChar(transb));
   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_A_SCALE_POINTER, mat1_scale_ptr);
@@ -982,13 +1125,19 @@ void int8_gemm(
     int32_t* result_ptr,
     int64_t result_ld) {
 
+#if !defined(__APPLE__) && !defined(__MACH__)
   cublasComputeType_t computeType = CUBLAS_COMPUTE_32I;
+#endif
   cudaDataType_t scaleType = CUDA_R_32I;
 
   cudaDataType_t abType = CUDA_R_8I;
   cudaDataType_t cType = CUDA_R_32I;
 
+#if defined(__APPLE__) && defined(__MACH__)
+  CuBlasLtMatmulDescriptor computeDesc(scaleType);
+#else
   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
+#endif
   cublasOperation_t transa = transpose_mat1 ? CUBLAS_OP_T : CUBLAS_OP_N;
   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, transa);
   cublasOperation_t transb = transpose_mat2 ? CUBLAS_OP_T : CUBLAS_OP_N;
@@ -1047,8 +1196,10 @@ void int8_gemm(
       abType,
       " cType ",
       cType,
+#if !defined(__APPLE__) && !defined(__MACH__)
       " computeType ",
       computeType,
+#endif
       " scaleType ",
       scaleType);
 }
@@ -1591,4 +1742,4 @@ void gelsBatched<c10::complex<float>>(CUDABLAS_GELS_BATCHED_ARGTYPES(c10::comple
       batchSize));
 }
 
-} // namespace at::cuda::blas
+}}} // namespace at::cuda::blas
diff --git a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
index 3ea75cc84d..03d1c4319e 100644
--- a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
+++ b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
@@ -3,7 +3,7 @@
 #include <ATen/cuda/CUDAUtils.h>
 #include <ATen/Dispatch.h>
 
-#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
+#if !defined(USE_ROCM)
 #include <cuda_runtime.h>
 #include <cutlass/cutlass.h>
 #include <cutlass/layout/layout.h>
@@ -12,8 +12,10 @@
 #include <cutlass/epilogue/thread/linear_combination_relu.h>
 #include <cutlass/epilogue/thread/linear_combination_silu.h>
 #include <cutlass/gemm/gemm.h>
+#if !defined(__APPLE__) && !defined(__MACH__)
 #include <cutlass/gemm/device/gemm_sparse_row_broadcast.h>
 #endif
+#endif
 
 #include <type_traits>
 #if defined(__APPLE__) && defined(__MACH__)
diff --git a/c10/util/Optional.cpp b/c10/util/Optional.cpp
index 7389393e66..c83614d448 100644
--- a/c10/util/Optional.cpp
+++ b/c10/util/Optional.cpp
@@ -1 +1,18 @@
+#include <c10/util/ArrayRef.h>
 #include <c10/util/Optional.h>
+
+#include <type_traits>
+
+static_assert(
+    C10_IS_TRIVIALLY_COPYABLE(c10::optional<int>),
+    "c10::optional<int> should be trivially copyable");
+static_assert(
+    C10_IS_TRIVIALLY_COPYABLE(c10::optional<bool>),
+    "c10::optional<bool> should be trivially copyable");
+static_assert(
+    C10_IS_TRIVIALLY_COPYABLE(c10::optional<c10::IntArrayRef>),
+    "c10::optional<IntArrayRef> should be trivially copyable");
+static_assert(
+    sizeof(c10::optional<c10::IntArrayRef>) == sizeof(c10::IntArrayRef),
+    "c10::optional<IntArrayRef> should be size-optimized");
+
diff --git a/c10/util/Optional.h b/c10/util/Optional.h
index 45d58282e3..23eac9e0ec 100644
--- a/c10/util/Optional.h
+++ b/c10/util/Optional.h
@@ -1,7 +1,7 @@
 #ifndef C10_UTIL_OPTIONAL_H_
 #define C10_UTIL_OPTIONAL_H_
 
-#if defined(__APPLE__) && defined(__MACH__)
+// #if defined(__APPLE__) && defined(__MACH__)
 
 #include <c10/macros/Macros.h>
 #include <c10/util/ArrayRef.h>
@@ -1235,7 +1235,7 @@ struct hash<c10::optional<T&>> {
 
 C10_CLANG_DIAGNOSTIC_POP()
 
-#else
+#if !defined(__APPLE__) && !defined(__MACH__)
 
 #include <optional>
 #include <type_traits>
@@ -1281,6 +1281,6 @@ constexpr T value_or_else(optional<T>&& v, F&& func) {
 }
 } // namespace c10
 
-#endif // defined(__APPLE__) && defined(__MACH__)
+#endif // !defined(__APPLE__) && !defined(__MACH__)
 
 #endif // C10_UTIL_OPTIONAL_H_
diff --git a/migration_note.md b/migration_note.md
index d0cf1e1d10..4ea0691f13 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -6,7 +6,9 @@ Preparation of building library:
 export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
 export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
 MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean # prepare
-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=OFF USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py develop
 ```
 
 ## 1, Missing ATen cuda
@@ -104,3 +106,58 @@ Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.1
 ```cmake
  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
 ```
+
+## 4. Runtime issue
+
+torch 2.2.0
+
+```bash
+(base) Orlando:gpu-magma2.6.1-distributed-all-2.2.0-py3.10 llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
+/Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib:
+	@rpath/libtorch_python.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libshm.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libtorch.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libtorch_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libnvToolsExt.1.dylib (compatibility version 0.0.0, current version 1.0.0)
+	@rpath/libtorch_cpu.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_intel_lp64.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_intel_thread.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_core.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libomp.dylib (compatibility version 5.0.0, current version 5.0.0)
+	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)
+	@rpath/libc10_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libc10.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libcudart.10.2.dylib (compatibility version 0.0.0, current version 10.2.89)
+	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
+	/usr/local/opt/open-mpi/lib/libmpi.40.dylib (compatibility version 71.0.0, current version 71.1.0)
+	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
+```
+
+torch 2.0.0
+
+```bash
+(base) Orlando:lib llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
+/Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib:
+	@rpath/libtorch_python.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libshm.dylib (compatibility version 0.0.0, current version 0.0.0)
+	/usr/local/opt/open-mpi/lib/libmpi.40.dylib (compatibility version 71.0.0, current version 71.1.0)
+	@rpath/libtorch.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libtorch_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libnvrtc.10.1.dylib (compatibility version 0.0.0, current version 10.1.243)
+	@rpath/libnvToolsExt.1.dylib (compatibility version 0.0.0, current version 1.0.0)
+	@rpath/libtorch_cpu.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_intel_lp64.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_intel_thread.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libmkl_core.2.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libomp.dylib (compatibility version 5.0.0, current version 5.0.0)
+	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)
+	@rpath/libc10_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libc10.dylib (compatibility version 0.0.0, current version 0.0.0)
+	@rpath/libcudart.10.1.dylib (compatibility version 0.0.0, current version 10.1.243)
+	@rpath/libcufft.10.dylib (compatibility version 0.0.0, current version 10.1.1)
+	@rpath/libcurand.10.dylib (compatibility version 0.0.0, current version 10.1.1)
+	@rpath/libcublas.10.dylib (compatibility version 0.0.0, current version 10.2.1)
+	@rpath/libcublasLt.10.dylib (compatibility version 0.0.0, current version 10.2.1)
+	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
+	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
+```
diff --git a/third_party/cutlass b/third_party/cutlass
index 63fc6f05ff..b72cbf957d 160000
--- a/third_party/cutlass
+++ b/third_party/cutlass
@@ -1 +1 @@
-Subproject commit 63fc6f05ffbfa66ca9e5548a041517bb6100e52c
+Subproject commit b72cbf957df8cf84a6d0ff91c190ad51a9c1d24a
diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
index 3296bd3754..0206be063d 100644
--- a/torch/csrc/distributed/c10d/init.cpp
+++ b/torch/csrc/distributed/c10d/init.cpp
@@ -1726,8 +1726,8 @@ Arguments:
               },
               py::arg("device"),
               py::arg("backend_type"),
-              py::arg("backend") =
-                  c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+            //   py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+              py::arg("backend"),
               py::call_guard<py::gil_scoped_release>())
           .def(
               "_get_backend",
@@ -2589,7 +2589,8 @@ Example::
       py::arg("bucket_size"),
       py::arg("expect_sparse_gradient") = std::vector<bool>(),
       py::arg("tensor_indices") = std::vector<int64_t>(),
-      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+      py::arg("logger"),
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
@@ -2607,7 +2608,8 @@ Example::
       },
       py::arg("process_group"),
       py::arg("params"),
-      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+      py::arg("logger"),
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
index 7b8a2d1f18..69ac2a13ce 100644
--- a/torch/csrc/distributed/rpc/init.cpp
+++ b/torch/csrc/distributed/rpc/init.cpp
@@ -544,8 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
               std::unordered_map<std::string, DeviceMap>,
               std::vector<c10::Device>>(),
           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
-          py::arg("_transports") = optional<std::vector<std::string>>(),
-          py::arg("_channels") = optional<std::vector<std::string>>(),
+        //   py::arg("_transports") = optional<std::vector<std::string>>(),
+          py::arg("_transports"),
+        //   py::arg("_channels") = optional<std::vector<std::string>>(),
+          py::arg("_channels"),
           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
           py::arg("init_method") = kDefaultInitMethod,
           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
-- 
2.17.2 (Apple Git-113)


From 46b15b281dabf8ea5974ceb12670d113bdc94cf5 Mon Sep 17 00:00:00 2001
From: orlando <xiandao.airs@gmail.com>
Date: Sun, 18 Feb 2024 21:07:47 -0800
Subject: [PATCH 06/14] Update intrusive_ptr.h

updates of headers
---
 c10/util/intrusive_ptr.h | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/c10/util/intrusive_ptr.h b/c10/util/intrusive_ptr.h
index 8e43dbd876..704cc486bb 100644
--- a/c10/util/intrusive_ptr.h
+++ b/c10/util/intrusive_ptr.h
@@ -1,10 +1,13 @@
 #pragma once
 
+#include <c10/util/C++17.h>
 #include <c10/util/Exception.h>
+#include <c10/util/ExclusivelyOwned.h>
 #include <c10/util/MaybeOwned.h>
 #include <atomic>
 #include <climits>
 #include <memory>
+#include <stdexcept>
 
 namespace pybind11 {
 template <typename, typename...>
-- 
2.17.2 (Apple Git-113)


From 9c9075760717f51df205bc16623abee398131651 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Thu, 22 Feb 2024 14:20:26 -0800
Subject: [PATCH 07/14] orlando - for fixing the issue of pocketfft invalid url

---
 migration_note.md                    |  4 ++--
 third_party/pocketfft                |  2 +-
 torch/csrc/distributed/c10d/init.cpp | 12 ++++++------
 torch/csrc/distributed/rpc/init.cpp  |  8 ++++----
 4 files changed, 13 insertions(+), 13 deletions(-)

diff --git a/migration_note.md b/migration_note.md
index 4ea0691f13..6907bf5c79 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -5,9 +5,9 @@ Preparation of building library:
 ```bash
 export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
 export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean # prepare
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean
 MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 DEBUG=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel # current running
 MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=OFF USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py develop
 ```
 
diff --git a/third_party/pocketfft b/third_party/pocketfft
index ad1eec0fb2..81d171a6d5 160000
--- a/third_party/pocketfft
+++ b/third_party/pocketfft
@@ -1 +1 @@
-Subproject commit ad1eec0fb2f8bfb28e287c559a29bc16d059abf0
+Subproject commit 81d171a6d5562e3aaa2c73489b70f564c633ff81
diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
index 0206be063d..a9662a975d 100644
--- a/torch/csrc/distributed/c10d/init.cpp
+++ b/torch/csrc/distributed/c10d/init.cpp
@@ -1726,8 +1726,8 @@ Arguments:
               },
               py::arg("device"),
               py::arg("backend_type"),
-            //   py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
-              py::arg("backend"),
+              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+            //   py::arg("backend"),
               py::call_guard<py::gil_scoped_release>())
           .def(
               "_get_backend",
@@ -2589,8 +2589,8 @@ Example::
       py::arg("bucket_size"),
       py::arg("expect_sparse_gradient") = std::vector<bool>(),
       py::arg("tensor_indices") = std::vector<int64_t>(),
-    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
-      py::arg("logger"),
+      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+    //   py::arg("logger"), 
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
@@ -2608,8 +2608,8 @@ Example::
       },
       py::arg("process_group"),
       py::arg("params"),
-    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
-      py::arg("logger"),
+      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+    //   py::arg("logger"),
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
index 69ac2a13ce..aa8f0d7a87 100644
--- a/torch/csrc/distributed/rpc/init.cpp
+++ b/torch/csrc/distributed/rpc/init.cpp
@@ -544,10 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
               std::unordered_map<std::string, DeviceMap>,
               std::vector<c10::Device>>(),
           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
-        //   py::arg("_transports") = optional<std::vector<std::string>>(),
-          py::arg("_transports"),
-        //   py::arg("_channels") = optional<std::vector<std::string>>(),
-          py::arg("_channels"),
+          py::arg("_transports") = optional<std::vector<std::string>>(),
+        //   py::arg("_transports"),
+          py::arg("_channels") = optional<std::vector<std::string>>(),
+        //   py::arg("_channels"),
           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
           py::arg("init_method") = kDefaultInitMethod,
           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
-- 
2.17.2 (Apple Git-113)


From 43ad1043be66454df9c5fc9eb3ce7679a2ee8baa Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Sat, 24 Feb 2024 22:58:08 -0800
Subject: [PATCH 08/14] orlando - for fixing issues of init.cpp and avoid issue

---
 c10/util/Optional.h                       |  7 +++----
 caffe2/serialize/inline_container.cc      |  4 +++-
 caffe2/serialize/inline_container.h       |  4 ++--
 caffe2/serialize/inline_container_test.cc |  4 ++--
 torch/csrc/distributed/c10d/init.cpp      |  5 ++++-
 torch/csrc/distributed/rpc/init.cpp       | 10 +++++-----
 6 files changed, 19 insertions(+), 15 deletions(-)

diff --git a/c10/util/Optional.h b/c10/util/Optional.h
index 23eac9e0ec..e2ae1f81e5 100644
--- a/c10/util/Optional.h
+++ b/c10/util/Optional.h
@@ -1,7 +1,7 @@
 #ifndef C10_UTIL_OPTIONAL_H_
 #define C10_UTIL_OPTIONAL_H_
 
-// #if defined(__APPLE__) && defined(__MACH__)
+#if defined(__APPLE__) && defined(__MACH__)
 
 #include <c10/macros/Macros.h>
 #include <c10/util/ArrayRef.h>
@@ -1235,7 +1235,7 @@ struct hash<c10::optional<T&>> {
 
 C10_CLANG_DIAGNOSTIC_POP()
 
-#if !defined(__APPLE__) && !defined(__MACH__)
+#else // !defined(__APPLE__) && !defined(__MACH__)
 
 #include <optional>
 #include <type_traits>
@@ -1250,7 +1250,6 @@ namespace c10 {
 using std::bad_optional_access;
 using std::in_place;
 using std::in_place_t;
-using std::make_optional;
 using std::nullopt;
 using std::nullopt_t;
 using std::optional;
@@ -1281,6 +1280,6 @@ constexpr T value_or_else(optional<T>&& v, F&& func) {
 }
 } // namespace c10
 
-#endif // !defined(__APPLE__) && !defined(__MACH__)
+#endif // defined(__APPLE__) && defined(__MACH__)
 
 #endif // C10_UTIL_OPTIONAL_H_
diff --git a/caffe2/serialize/inline_container.cc b/caffe2/serialize/inline_container.cc
index 533fd42a04..20ea4e6923 100644
--- a/caffe2/serialize/inline_container.cc
+++ b/caffe2/serialize/inline_container.cc
@@ -34,12 +34,14 @@ constexpr c10::string_view kDebugPklSuffix(".debug_pkl");
 struct MzZipReaderIterWrapper {
   MzZipReaderIterWrapper(mz_zip_reader_extract_iter_state* iter) : impl(iter) {}
   mz_zip_reader_extract_iter_state* impl;
+  // Disable the move constructor
+  MzZipReaderIterWrapper(MzZipReaderIterWrapper&& other) = delete;
 };
 
 ChunkRecordIterator::ChunkRecordIterator(
     size_t recordSize,
     size_t chunkSize,
-    std::unique_ptr<MzZipReaderIterWrapper> iter)
+    std::shared_ptr<MzZipReaderIterWrapper> iter)
     : recordSize_(recordSize),
       chunkSize_(chunkSize),
       offset_(0),
diff --git a/caffe2/serialize/inline_container.h b/caffe2/serialize/inline_container.h
index aa0cb8e043..d4b98b41a6 100644
--- a/caffe2/serialize/inline_container.h
+++ b/caffe2/serialize/inline_container.h
@@ -109,12 +109,12 @@ class TORCH_API ChunkRecordIterator {
  ChunkRecordIterator(
       size_t recordSize,
       size_t chunkSize,
-      std::unique_ptr<MzZipReaderIterWrapper> iter);
+      std::shared_ptr<MzZipReaderIterWrapper> iter);
 
   const size_t recordSize_;
   const size_t chunkSize_;
   size_t offset_;
-  std::unique_ptr<MzZipReaderIterWrapper> iter_;
+  std::shared_ptr<MzZipReaderIterWrapper> iter_;
 
   friend class PyTorchStreamReader;
 };
diff --git a/caffe2/serialize/inline_container_test.cc b/caffe2/serialize/inline_container_test.cc
index 4fe2c236e0..2e597a01fc 100644
--- a/caffe2/serialize/inline_container_test.cc
+++ b/caffe2/serialize/inline_container_test.cc
@@ -464,7 +464,7 @@ TEST_P(ChunkRecordIteratorTest, ChunkRead) {
   LOG(INFO) << "Testing chunk size " << chunkSize;
   PyTorchStreamReader reader(fileName);
   ASSERT_TRUE(reader.hasRecord(recordName));
-  #if !defined(__APPLE__) && !defined(__MACH__)
+  // #if !defined(__APPLE__) && !defined(__MACH__)
   //see: to avoid "error: call to implicitly-deleted copy constructor of 'caffe2::serialize::ChunkRecordIterator'"
   caffe2::serialize::ChunkRecordIterator chunkIterator = reader.createChunkReaderIter(
       recordName, tensorDataSizeInBytes, chunkSize);
@@ -476,7 +476,7 @@ TEST_P(ChunkRecordIteratorTest, ChunkRead) {
     totalReadSize += readSize;
   }
   ASSERT_EQ(totalReadSize, tensorDataSizeInBytes);
-  #endif
+  // #endif
   // clean up
   remove(fileName);
 }
diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
index a9662a975d..d81f7c2087 100644
--- a/torch/csrc/distributed/c10d/init.cpp
+++ b/torch/csrc/distributed/c10d/init.cpp
@@ -107,6 +107,9 @@ namespace c10d {
 
 namespace {
 
+using ::c10::in_place;
+using ::c10::in_place_t;
+
 template <typename T>
 using shared_ptr_class_ = py::class_<T, std::shared_ptr<T>>;
 
@@ -1726,8 +1729,8 @@ Arguments:
               },
               py::arg("device"),
               py::arg("backend_type"),
-              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
             //   py::arg("backend"),
+              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
               py::call_guard<py::gil_scoped_release>())
           .def(
               "_get_backend",
diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
index aa8f0d7a87..b90fe6c387 100644
--- a/torch/csrc/distributed/rpc/init.cpp
+++ b/torch/csrc/distributed/rpc/init.cpp
@@ -537,16 +537,16 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
       .def(
           py::init<
               int,
-              optional<std::vector<std::string>>,
-              optional<std::vector<std::string>>,
+              c10::optional<std::vector<std::string>>,
+              c10::optional<std::vector<std::string>>,
               float,
               std::string,
               std::unordered_map<std::string, DeviceMap>,
               std::vector<c10::Device>>(),
           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
-          py::arg("_transports") = optional<std::vector<std::string>>(),
+          py::arg("_transports") = c10::optional<std::vector<std::string>>(),
         //   py::arg("_transports"),
-          py::arg("_channels") = optional<std::vector<std::string>>(),
+          py::arg("_channels") = c10::optional<std::vector<std::string>>(),
         //   py::arg("_channels"),
           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
           py::arg("init_method") = kDefaultInitMethod,
@@ -579,7 +579,7 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
               [](const c10::intrusive_ptr<::c10d::Store>& store,
                  std::string selfName,
                  worker_id_t selfId,
-                 optional<int> worldSize,
+                 c10::optional<int> worldSize,
                  TensorPipeRpcBackendOptions opts,
                  std::unordered_map<std::string, DeviceMap> reverseDeviceMaps,
                  std::vector<c10::Device> devices) {
-- 
2.17.2 (Apple Git-113)


From 3322cd3fa1d8189275f6e4b96fdee2526f9358d5 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Sun, 25 Feb 2024 22:24:58 -0800
Subject: [PATCH 09/14] orlando - for updates of torch init.cpp and library.h

---
 aten/src/ATen/functorch/Interpreter.h         |  2 +-
 aten/src/ATen/native/LinearAlgebra.cpp        |  1 +
 c10/util/Exception.h                          |  4 ---
 migration_note.md                             | 10 ++++++-
 .../include/torch/nn/functional/upsampling.h  |  1 -
 torch/csrc/api/include/torch/nn/init.h        | 17 ------------
 .../csrc/api/include/torch/nn/modules/conv.h  |  1 -
 .../torch/nn/options/transformerlayer.h       |  8 +-----
 .../api/include/torch/nn/options/upsampling.h | 26 +++----------------
 torch/csrc/api/src/nn/modules/conv.cpp        |  1 -
 torch/csrc/autograd/profiler_kineto.cpp       |  1 -
 torch/csrc/distributed/c10d/init.cpp          |  6 ++---
 torch/csrc/distributed/rpc/init.cpp           |  8 +++---
 torch/csrc/profiler/python/init.cpp           |  4 ---
 torch/csrc/profiler/util.h                    |  2 --
 torch/csrc/utils/pybind.h                     | 14 ++++++++++
 torch/library.h                               |  1 +
 17 files changed, 38 insertions(+), 69 deletions(-)

diff --git a/aten/src/ATen/functorch/Interpreter.h b/aten/src/ATen/functorch/Interpreter.h
index 11cb41ee79..c4ccbee17c 100644
--- a/aten/src/ATen/functorch/Interpreter.h
+++ b/aten/src/ATen/functorch/Interpreter.h
@@ -9,8 +9,8 @@
 #include <c10/util/variant.h>
 namespace std {
   using ::c10::variant;
-  using ::c10::get;
   using ::c10::holds_alternative;
+  using ::c10::get;
 } // namespace std
 #else
 #include <variant>
diff --git a/aten/src/ATen/native/LinearAlgebra.cpp b/aten/src/ATen/native/LinearAlgebra.cpp
index 530f2ed3ca..c1ebcb2fd1 100644
--- a/aten/src/ATen/native/LinearAlgebra.cpp
+++ b/aten/src/ATen/native/LinearAlgebra.cpp
@@ -26,6 +26,7 @@ namespace std {
   // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
   using ::c10::variant;
   using ::c10::get_if;
+  using ::c10::get;
 }// namespace std
 #else
 #include <variant>
diff --git a/c10/util/Exception.h b/c10/util/Exception.h
index fa5e67ddda..9f003c7730 100644
--- a/c10/util/Exception.h
+++ b/c10/util/Exception.h
@@ -122,11 +122,7 @@ class C10_API Warning {
   class C10_API UserWarning {};
   class C10_API DeprecationWarning {};
 
-#if defined(__APPLE__) && defined(__MACH__)
-  using warning_variant_t = c10::variant<UserWarning, DeprecationWarning>;
-#else
   using warning_variant_t = std::variant<UserWarning, DeprecationWarning>;
-#endif
 
   Warning(
       warning_variant_t type,
diff --git a/migration_note.md b/migration_note.md
index 6907bf5c79..d26c6c2100 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -109,7 +109,13 @@ Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.1
 
 ## 4. Runtime issue
 
-torch 2.2.0
+torch 2.2.0's bash script result:
+
+```bash
+In [1]: import torch
+libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: arg(): could not convert default argument 'backend: c10::optional<c10::intrusive_ptr<c10d::Backend, c10::detail::intrusive_target_default_null_type<c10d::Backend> > >' in method '<class 'torch._C._distributed_c10d.ProcessGroup'>._register_backend' into a Python object (type not registered yet?)
+Abort trap: 6
+```
 
 ```bash
 (base) Orlando:gpu-magma2.6.1-distributed-all-2.2.0-py3.10 llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
@@ -161,3 +167,5 @@ torch 2.0.0
 	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
 	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
 ```
+
+change torch/csrc/utils/pybind.h with 
\ No newline at end of file
diff --git a/torch/csrc/api/include/torch/nn/functional/upsampling.h b/torch/csrc/api/include/torch/nn/functional/upsampling.h
index fb8a343f44..a8ad434cbb 100644
--- a/torch/csrc/api/include/torch/nn/functional/upsampling.h
+++ b/torch/csrc/api/include/torch/nn/functional/upsampling.h
@@ -10,7 +10,6 @@
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 namespace std {
-  using ::c10::variant;
   using ::c10::holds_alternative;
   using ::c10::get_if;
 }// namespace std
diff --git a/torch/csrc/api/include/torch/nn/init.h b/torch/csrc/api/include/torch/nn/init.h
index 7f36db896d..2ff0a51146 100644
--- a/torch/csrc/api/include/torch/nn/init.h
+++ b/torch/csrc/api/include/torch/nn/init.h
@@ -20,22 +20,6 @@ namespace nn {
 namespace init {
 
 
-#if defined(__APPLE__) && defined(__MACH__)
-using NonlinearityType = c10::variant<
-    enumtype::kLinear,
-    enumtype::kConv1D,
-    enumtype::kConv2D,
-    enumtype::kConv3D,
-    enumtype::kConvTranspose1D,
-    enumtype::kConvTranspose2D,
-    enumtype::kConvTranspose3D,
-    enumtype::kSigmoid,
-    enumtype::kTanh,
-    enumtype::kReLU,
-    enumtype::kLeakyReLU>;
-
-using FanModeType = c10::variant<enumtype::kFanIn, enumtype::kFanOut>;
-#else
 using NonlinearityType = std::variant<
     enumtype::kLinear,
     enumtype::kConv1D,
@@ -50,7 +34,6 @@ using NonlinearityType = std::variant<
     enumtype::kLeakyReLU>;
 
 using FanModeType = std::variant<enumtype::kFanIn, enumtype::kFanOut>;
-#endif
 
 } // namespace init
 } // namespace nn
diff --git a/torch/csrc/api/include/torch/nn/modules/conv.h b/torch/csrc/api/include/torch/nn/modules/conv.h
index f61a9fab2d..2b7809d18e 100644
--- a/torch/csrc/api/include/torch/nn/modules/conv.h
+++ b/torch/csrc/api/include/torch/nn/modules/conv.h
@@ -20,7 +20,6 @@
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 namespace std {
-  using ::c10::variant;
   using ::c10::holds_alternative;
   using ::c10::get_if;
 }// namespace std
diff --git a/torch/csrc/api/include/torch/nn/options/transformerlayer.h b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
index 84e6221588..ded2018806 100644
--- a/torch/csrc/api/include/torch/nn/options/transformerlayer.h
+++ b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
@@ -17,17 +17,11 @@ namespace std {
 namespace torch {
 namespace nn {
 
-#if defined(__APPLE__) && defined(__MACH__)
-using activation_t = c10::variant<
-    enumtype::kReLU,
-    enumtype::kGELU,
-    std::function<Tensor(const Tensor&)>>;
-#else
+
 using activation_t = std::variant<
     enumtype::kReLU,
     enumtype::kGELU,
     std::function<Tensor(const Tensor&)>>;
-#endif
 
 /// Options for the `TransformerEncoderLayer`
 ///
diff --git a/torch/csrc/api/include/torch/nn/options/upsampling.h b/torch/csrc/api/include/torch/nn/options/upsampling.h
index 122df40912..898280ae85 100644
--- a/torch/csrc/api/include/torch/nn/options/upsampling.h
+++ b/torch/csrc/api/include/torch/nn/options/upsampling.h
@@ -10,6 +10,9 @@
 
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
+namespace std {
+  using ::c10::variant;
+}// namespace std
 #else
 #include <variant>
 #endif
@@ -33,15 +36,6 @@ struct TORCH_API UpsampleOptions {
 
   /// the upsampling algorithm: one of "nearest", "linear", "bilinear",
   /// "bicubic" and "trilinear". Default: "nearest"
-#if defined(__APPLE__) && defined(__MACH__)
-  typedef c10::variant<
-      enumtype::kNearest,
-      enumtype::kLinear,
-      enumtype::kBilinear,
-      enumtype::kBicubic,
-      enumtype::kTrilinear>
-      mode_t;
-#else
   typedef std::variant<
       enumtype::kNearest,
       enumtype::kLinear,
@@ -49,7 +43,7 @@ struct TORCH_API UpsampleOptions {
       enumtype::kBicubic,
       enumtype::kTrilinear>
       mode_t;
-#endif
+  
   TORCH_ARG(mode_t, mode) = torch::kNearest;
 
   /// if "True", the corner pixels of the input and output tensors are
@@ -70,17 +64,6 @@ namespace functional {
 /// F::InterpolateFuncOptions().size(std::vector<int64_t>({4})).mode(torch::kNearest));
 /// ```
 struct TORCH_API InterpolateFuncOptions {
-#if defined(__APPLE__) && defined(__MACH__)
-  typedef c10::variant<
-      enumtype::kNearest,
-      enumtype::kLinear,
-      enumtype::kBilinear,
-      enumtype::kBicubic,
-      enumtype::kTrilinear,
-      enumtype::kArea,
-      enumtype::kNearestExact>
-      mode_t;
-#else
   typedef std::variant<
       enumtype::kNearest,
       enumtype::kLinear,
@@ -90,7 +73,6 @@ struct TORCH_API InterpolateFuncOptions {
       enumtype::kArea,
       enumtype::kNearestExact>
       mode_t;
-#endif
 
   /// output spatial sizes.
   TORCH_ARG(c10::optional<std::vector<int64_t>>, size) = c10::nullopt;
diff --git a/torch/csrc/api/src/nn/modules/conv.cpp b/torch/csrc/api/src/nn/modules/conv.cpp
index b1a9ddb116..4cb106546f 100644
--- a/torch/csrc/api/src/nn/modules/conv.cpp
+++ b/torch/csrc/api/src/nn/modules/conv.cpp
@@ -18,7 +18,6 @@
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 namespace std {
-  using ::c10::variant;
   using ::c10::holds_alternative;
   using ::c10::get_if;
 }// namespace std
diff --git a/torch/csrc/autograd/profiler_kineto.cpp b/torch/csrc/autograd/profiler_kineto.cpp
index 3bb25ecc0e..02670dad96 100644
--- a/torch/csrc/autograd/profiler_kineto.cpp
+++ b/torch/csrc/autograd/profiler_kineto.cpp
@@ -31,7 +31,6 @@
 #if defined(__APPLE__) && defined(__MACH__)
 #include <c10/util/variant.h>
 namespace std {
-  using ::c10::variant;
   using ::c10::holds_alternative;
   using ::c10::get;
   using ::c10::get_if;
diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
index d81f7c2087..4a8edf3356 100644
--- a/torch/csrc/distributed/c10d/init.cpp
+++ b/torch/csrc/distributed/c10d/init.cpp
@@ -1729,7 +1729,7 @@ Arguments:
               },
               py::arg("device"),
               py::arg("backend_type"),
-            //   py::arg("backend"),
+              //see: pybind11 backend with optional
               py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
               py::call_guard<py::gil_scoped_release>())
           .def(
@@ -2592,8 +2592,8 @@ Example::
       py::arg("bucket_size"),
       py::arg("expect_sparse_gradient") = std::vector<bool>(),
       py::arg("tensor_indices") = std::vector<int64_t>(),
+      //see: pybind11 Logger
       py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
-    //   py::arg("logger"), 
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
@@ -2611,8 +2611,8 @@ Example::
       },
       py::arg("process_group"),
       py::arg("params"),
+      //see: pybind11 Logger
       py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
-    //   py::arg("logger"),
       py::call_guard<py::gil_scoped_release>());
 
   module.def(
diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
index b90fe6c387..e7529bb53c 100644
--- a/torch/csrc/distributed/rpc/init.cpp
+++ b/torch/csrc/distributed/rpc/init.cpp
@@ -544,10 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
               std::unordered_map<std::string, DeviceMap>,
               std::vector<c10::Device>>(),
           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
-          py::arg("_transports") = c10::optional<std::vector<std::string>>(),
-        //   py::arg("_transports"),
-          py::arg("_channels") = c10::optional<std::vector<std::string>>(),
-        //   py::arg("_channels"),
+        //  see: pybind11 py::arg("_transports"),
+          py::arg("_transports") = optional<std::vector<std::string>>(),
+        //  see: pybind11 py::arg("_channels"),
+          py::arg("_channels") = optional<std::vector<std::string>>(),
           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
           py::arg("init_method") = kDefaultInitMethod,
           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
diff --git a/torch/csrc/profiler/python/init.cpp b/torch/csrc/profiler/python/init.cpp
index 2c5635c720..5bc1354eeb 100644
--- a/torch/csrc/profiler/python/init.cpp
+++ b/torch/csrc/profiler/python/init.cpp
@@ -10,10 +10,6 @@
 #include <torch/csrc/profiler/standalone/execution_trace_observer.h>
 #include <torch/csrc/utils/pybind.h>
 
-#if defined(__APPLE__) && defined(__MACH__)
-#include <c10/util/variant.h>
-#endif
-
 struct THPCapturedTraceback {
   PyObject_HEAD std::shared_ptr<torch::CapturedTraceback> data;
 };
diff --git a/torch/csrc/profiler/util.h b/torch/csrc/profiler/util.h
index c35da5a16d..161b912d32 100644
--- a/torch/csrc/profiler/util.h
+++ b/torch/csrc/profiler/util.h
@@ -18,8 +18,6 @@
 #include <c10/util/variant.h>
 namespace std {
   using ::c10::variant;
-  using ::c10::holds_alternative;
-  using ::c10::get;
 }// namespace std
 #else
 #include <variant>
diff --git a/torch/csrc/utils/pybind.h b/torch/csrc/utils/pybind.h
index 4f3871d3ea..9dc45109d3 100644
--- a/torch/csrc/utils/pybind.h
+++ b/torch/csrc/utils/pybind.h
@@ -5,6 +5,9 @@
 #include <ATen/core/Tensor.h>
 #include <ATen/core/jit_type_base.h>
 #include <c10/util/irange.h>
+#if defined(__APPLE__) && defined(__MACH__)
+#include <c10/util/variant.h>
+#endif
 #include <pybind11/pybind11.h>
 #include <pybind11/stl.h>
 
@@ -324,6 +327,17 @@ struct type_caster<c10::complex<T>> {
   }
 };
 
+#if defined(__APPLE__) && defined(__MACH__)
+// Pybind11 bindings for our optional and variant types.
+// http://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#c-17-library-containers
+template <typename T>
+struct type_caster<c10::optional<T>> : optional_caster<c10::optional<T>> {};
+
+template <typename... Ts>
+struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
+    : variant_caster<c10::variant<Ts...>> {};
+#endif
+
 } // namespace detail
 } // namespace pybind11
 
diff --git a/torch/library.h b/torch/library.h
index e74b409bcc..8e584e6222 100644
--- a/torch/library.h
+++ b/torch/library.h
@@ -73,6 +73,7 @@
 namespace std {
   // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
   using ::c10::holds_alternative;
+  using ::c10::get;
 }
 #endif
 
-- 
2.17.2 (Apple Git-113)


From c3959b7600acba1f44dac58c81691131877bc836 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Mon, 26 Feb 2024 18:02:36 -0800
Subject: [PATCH 10/14] orlando - for updates of support 2.2.0

---
 migration_note.md            | 17 ++++++++++++++++-
 torch/csrc/utils/pybind.h    |  9 +++++----
 torch/utils/cpp_extension.py |  2 +-
 3 files changed, 22 insertions(+), 6 deletions(-)

diff --git a/migration_note.md b/migration_note.md
index d26c6c2100..e847b0be6b 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -168,4 +168,19 @@ torch 2.0.0
 	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
 ```
 
-change torch/csrc/utils/pybind.h with 
\ No newline at end of file
+change torch/csrc/utils/pybind.h with cast_type.
+
+## 5. Building pytorch.vision 0.17.1
+
+Issue: not found  /usr/local/cuda/lib/libcudnn.a
+
+Try with the following solution:
+
+```bash
+sudo ln -s  /usr/local/torch/lib/libdnnl.a /usr/local/lib/libdnnl.a
+sudo ln -s  /usr/local/torch/lib/libc10_cuda.dylib /usr/local/lib/libc10_cuda.dylib
+sudo ln -s  /usr/local/torch/lib/libc10.dylib /usr/local/lib/libc10.dylib
+sudo ln -s  /usr/local/torch/lib/libtorch_cpu.dylib /usr/local/lib/libtorch_cpu.dylib
+sudo ln -s  /usr/local/torch/lib/libtorch_cuda.dylib  /usr/local/lib/libtorch_cuda.dylib
+sudo ln -s  /usr/local/torch/lib/libtorch.dylib  /usr/local/lib/libtorch.dylib
+```
diff --git a/torch/csrc/utils/pybind.h b/torch/csrc/utils/pybind.h
index 9dc45109d3..da7175bd4f 100644
--- a/torch/csrc/utils/pybind.h
+++ b/torch/csrc/utils/pybind.h
@@ -333,10 +333,11 @@ struct type_caster<c10::complex<T>> {
 template <typename T>
 struct type_caster<c10::optional<T>> : optional_caster<c10::optional<T>> {};
 
-template <typename... Ts>
-struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
-    : variant_caster<c10::variant<Ts...>> {};
-#endif
+//see: redefinition /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/include/pybind11/stl.h:441:8: note: previous definition is here
+// template <typename... Ts>
+// struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
+//     : variant_caster<c10::variant<Ts...>> {};
+// #endif
 
 } // namespace detail
 } // namespace pybind11
diff --git a/torch/utils/cpp_extension.py b/torch/utils/cpp_extension.py
index b490d262a4..7feb1774aa 100644
--- a/torch/utils/cpp_extension.py
+++ b/torch/utils/cpp_extension.py
@@ -2312,7 +2312,7 @@ def _write_ninja_file(path,
         
     def replace_std17_with_std14(options):
             options = [c for c in options if c != "-std=c++17"]
-            if options.find("-std=c++14") == -1:
+            if "-std=c++14" not in options:
                 options.append("-std=c++14")
             return options
 
-- 
2.17.2 (Apple Git-113)


From 967e0c8586a1767611cf5184d4a2713a150b7d3b Mon Sep 17 00:00:00 2001
From: orlando <xiandao.airs@gmail.com>
Date: Mon, 26 Feb 2024 18:07:44 -0800
Subject: [PATCH 11/14] Update README.md

---
 README.md | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/README.md b/README.md
index f6023ceb6d..f1791556bf 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,37 @@
+<!-- markdownlint-disable MD033 -->
+<!-- markdownlint-disable MD004 -->
+<!-- markdownlint-disable MD029 -->
+# Pytorch 2.0.0 with Nvidia GPU on macOS
+--------------------------------------------------------------------------------
+[Features of pytorch 2.0](https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/) requires trions of [openAI triton](https://github.com/openai/triton), which needs NVIDIA GPUs (Compute Capability 7.0+, refer to https://developer.nvidia.com/cuda-gpus). In order to support the compilation via cuda, the hardware of eGPU needs to upgrade to 2080i +, like sales in [gaming box of 2080i](https://www.amazon.com/Embedded-Thunderbolt-Waterforce-Controller-Gv-N208TIXEB-11GC/dp/B07ZS9GZRY/ref=sr_1_5?crid=38RK3T5BAKIGN&keywords=gigabyte+gaming+box&qid=1679248280&s=pc&sprefix=gigabyte+gaming+box%2Ccomputers%2C147&sr=1-5). 
+
+--------------------------------------------------------------------------------
+As officially Pytorch doesn't support for macOS cuda, I used this repository to build pytorch on macOS cuda. **This branch v2.2.0-tensorpipe-fixed branch is the current stable branch** with MPI+CUDA enabled.
+
+- macOS 10.13.6, cuda 10.1/10.2, cudnn 7.6.5 (cuda and cudnn is the last official version which Nvidia released to support macOS, now I setup cuda10.1 and cuda10.2 side by side in order to allow torch to access the memory management API exposed by cuda 10.2)
+- [NCCL on macOS 2.9.6.1](https://github.com/llv22/nccl-osx) and [test suite](https://github.com/llv22/nccl-tests-macOS-cuda)
+- Xcode 10.1, libuv 1.2.6
+- magma 2.6 built on macOS, providing by [cloned magma repository from The University of Tennessee, Knoxville](https://github.com/llv22/magma-macOS)
+- support distributed options with TENSORPIPE, which has been fixed via [Orlando's tensorpipe](https://github.com/llv22/tensorpipe-macos-cuda/tree/v2.0.0-tensorpipe-fixed)
+
+```bash
+--   USE_DISTRIBUTED       : ON
+--     USE_MPI               : ON
+--     USE_GLOO              : ON
+--     USE_TENSORPIPE        : ON
+--     USE_CUDA_MPI          : ON
+```
+
+Consolidating [torch-2.0.0-mac-with-tensorpipe-cuda-mpi-enabling.patch](https://github.com/llv22/pytorch-macOS-cuda/blob/v2.0.0-tensorpipe-fixed/torch-2.0.0-mac-with-tensorpipe-cuda-mpi-enabling.patch)) by
+
+```bash
+git format-patch -8 --stdout > torch-2.2.0-mac-with-tensorpipe-cuda10.1-10.2-support-memory-mpi-enabling.patch
+```
+
++refer to <https://www.ivankristianto.com/create-patch-files-from-multiple-commits-in-git/>
+
+--------------------------------------------------------------------------------
+
 ![PyTorch Logo](https://github.com/pytorch/pytorch/blob/main/docs/source/_static/img/pytorch-logo-dark.png)
 
 --------------------------------------------------------------------------------
-- 
2.17.2 (Apple Git-113)


From c37785a275625b7e6778ad22f75b60537ec8c05f Mon Sep 17 00:00:00 2001
From: orlando <xiandao.airs@gmail.com>
Date: Mon, 26 Feb 2024 18:07:57 -0800
Subject: [PATCH 12/14] Update README.md

---
 README.md | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/README.md b/README.md
index f1791556bf..276d02ef5d 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,7 @@
 <!-- markdownlint-disable MD033 -->
 <!-- markdownlint-disable MD004 -->
 <!-- markdownlint-disable MD029 -->
-# Pytorch 2.0.0 with Nvidia GPU on macOS
+# Pytorch 2.2.0 with Nvidia GPU on macOS
 --------------------------------------------------------------------------------
 [Features of pytorch 2.0](https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/) requires trions of [openAI triton](https://github.com/openai/triton), which needs NVIDIA GPUs (Compute Capability 7.0+, refer to https://developer.nvidia.com/cuda-gpus). In order to support the compilation via cuda, the hardware of eGPU needs to upgrade to 2080i +, like sales in [gaming box of 2080i](https://www.amazon.com/Embedded-Thunderbolt-Waterforce-Controller-Gv-N208TIXEB-11GC/dp/B07ZS9GZRY/ref=sr_1_5?crid=38RK3T5BAKIGN&keywords=gigabyte+gaming+box&qid=1679248280&s=pc&sprefix=gigabyte+gaming+box%2Ccomputers%2C147&sr=1-5). 
 
-- 
2.17.2 (Apple Git-113)


From 1bd8199f615b1bdcd77e138f1828166e19e9c6c8 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Mon, 26 Feb 2024 18:09:07 -0800
Subject: [PATCH 13/14] orlando - for updates the cuda 10.1 and 10.2
 side-by-side to support memory api acessing

---
 ...0.1-10.2-support-memory-mpi-enabling.patch | 1432 +++++++++++++++++
 1 file changed, 1432 insertions(+)
 create mode 100644 torch-2.2.0-mac-with-tensorpipe-cuda10.1-10.2-support-memory-mpi-enabling.patch

diff --git a/torch-2.2.0-mac-with-tensorpipe-cuda10.1-10.2-support-memory-mpi-enabling.patch b/torch-2.2.0-mac-with-tensorpipe-cuda10.1-10.2-support-memory-mpi-enabling.patch
new file mode 100644
index 0000000000..d5ea19e47a
--- /dev/null
+++ b/torch-2.2.0-mac-with-tensorpipe-cuda10.1-10.2-support-memory-mpi-enabling.patch
@@ -0,0 +1,1432 @@
+From 39798de17b24a19ee22bb74b40c2a57ab8718c65 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Mon, 12 Feb 2024 22:28:43 -0800
+Subject: [PATCH 1/8] orlando - for updates of settings
+
+---
+ third_party/cutlass | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/third_party/cutlass b/third_party/cutlass
+index 5a586c30b8..63fc6f05ff 160000
+--- a/third_party/cutlass
++++ b/third_party/cutlass
+@@ -1 +1 @@
+-Subproject commit 5a586c30b81629fcf391c16f4314bb85dc5f23ff
++Subproject commit 63fc6f05ffbfa66ca9e5548a041517bb6100e52c
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 294eccdd7cdd9d2ac8c9758290c423fedf8dd277 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Tue, 13 Feb 2024 10:06:23 -0800
+Subject: [PATCH 2/8] orlando - for updates of tensorpipe settings
+
+---
+ migration_note.md | 21 ++++++++++++++++++---
+ 1 file changed, 18 insertions(+), 3 deletions(-)
+
+diff --git a/migration_note.md b/migration_note.md
+index f063e72d4a..d0cf1e1d10 100644
+--- a/migration_note.md
++++ b/migration_note.md
+@@ -1,5 +1,7 @@
+ # Migration note
+ 
++Preparation of building library:
++
+ ```bash
+ export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
+ export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
+@@ -9,11 +11,14 @@ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=cl
+ 
+ ## 1, Missing ATen cuda
+ 
++```bash
+ /usr/local/bin/ccache /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -DHAVE_MMAP=1 -DHAVE_SHM_OPEN=1 -DHAVE_SHM_UNLINK=1 -DIDEEP_USE_MKL -DMINIZ_DISABLE_ZIP_READER_CRC32_CHECKS -DONNXIFI_ENABLE_EXT=1 -DONNX_ML=1 -DONNX_NAMESPACE=onnx_torch -DUSE_CUDA_MPI=1 -DUSE_EXTERNAL_MZCRC -D_FILE_OFFSET_BITS=64 -Dcaffe2_nvrtc_EXPORTS -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/benchmark/include -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/onnx -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/foxi -I/Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/foxi -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/build/third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/gloo -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/tensorpipe/third_party/libuv/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googlemock/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/googletest/googletest/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/protobuf/src -isystem /Users/llv23/opt/miniconda3/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/gemmlowp -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/neon2sse -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/XNNPACK/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ittapi/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/eigen -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/cmake/../third_party/cub -isystem /usr/local/include -isystem /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/third_party/ideep/include -D_LIBCPP_DISABLE_AVAILABILITY -fvisibility-inlines-hidden -DUSE_PTHREADPOOL -DNDEBUG -DUSE_KINETO -DLIBKINETO_NOCUPTI -DLIBKINETO_NOROCTRACER -DUSE_FBGEMM -DUSE_QNNPACK -DUSE_PYTORCH_QNNPACK -DUSE_XNNPACK -DSYMBOLICATE_MOBILE_DEBUG_HANDLE -O2 -fPIC -Wall -Wextra -Werror=return-type -Werror=non-virtual-dtor -Werror=braced-scalar-init -Wnarrowing -Wno-missing-field-initializers -Wno-type-limits -Wno-array-bounds -Wno-unknown-pragmas -Wno-unused-parameter -Wno-unused-function -Wno-unused-result -Wno-strict-overflow -Wno-strict-aliasing -Wvla-extension -Wnewline-eof -Winconsistent-missing-override -Winconsistent-missing-destructor-override -Wno-pass-failed -Wno-error=pedantic -Wno-error=old-style-cast -Wno-error=inconsistent-missing-override -Wno-error=inconsistent-missing-destructor-override -Wconstant-conversion -Wno-invalid-partial-specialization -Wno-aligned-allocation-unavailable -Wno-missing-braces -Qunused-arguments -fcolor-diagnostics -faligned-new -fno-math-errno -fno-trapping-math -Werror=format -Wno-unused-private-field -Wno-missing-braces -DHAVE_AVX2_CPU_DEFINITION -O3 -DNDEBUG -DNDEBUG -std=gnu++14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -mmacosx-version-min=10.9 -fPIC -DMKL_HAS_SBGEMM -DTORCH_USE_LIBUV -DCAFFE2_USE_GLOO -MD -MT caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -MF caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o.d -o caffe2/CMakeFiles/caffe2_nvrtc.dir/__/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp.o -c /Users/llv23/Documents/05_machine_learning/dl_gpu_mac/pytorch-2.2.0-tensorpipe/aten/src/ATen/cuda/nvrtc_stub/ATenNVRTC.cpp
++```
+ 
+ ## 2, Migrating from c10 to std
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
++```c++
++# if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ namespace std {
+   using ::c10::variant;
+@@ -25,8 +30,9 @@ namespace std {
+ #else
+ #include <variant>
+ #endif
++```
+ 
+-
++```c++
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/Optional.h>
+ namespace std {
+@@ -35,22 +41,30 @@ namespace std {
+ #else
+ #include <optional>
+ #endif
++```
+ 
++```c++
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ #endif
++```
+ 
++```c++
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ #else
+ #include <variant>
+ #endif
++```
+ 
++```c++
+ #if defined(__APPLE__) && defined(__MACH__)
+ c10::visit
+ #else
+ #endif 
++```
+ 
++```c++
+ MetadataShape compute_variant_shape(const at::Tensor& input) {
+   if (input.is_nested() && !input.unsafeGetTensorImpl()->is_python_dispatch()) {
+     auto nested_size = input._nested_tensor_size();
+@@ -66,6 +80,7 @@ MetadataShape compute_variant_shape(const at::Tensor& input) {
+   return MetadataShape{std::in_place_type<SymIntSmallVec>, input.sym_sizes()};
+ #endif
+ }
++```
+ 
+ ## 3, Issue of loading include headers
+ 
+@@ -84,7 +99,7 @@ FAILED: caffe2/CMakeFiles/torch_cuda.dir/__/aten/src/ATen/native/nested/cuda/Nes
+ #include <cutlass/gemm/device/default_gemm_configuration.h>
+ ```
+ 
+-solution: correct the caffe2/CMakeLists.txt in Line 96 by 
++Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.11.0, a prior version to 3.0.0 for CUDA 11.x
+ 
+ ```cmake
+  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 49f18e626e3c2a1c7e18fdca0dece3bf92b04d03 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Fri, 16 Feb 2024 23:01:56 -0800
+Subject: [PATCH 3/8] orlando - for updates of torch 2.2.0, but meeting with
+ issues
+
+---
+ aten/src/ATen/cuda/CUDABlas.cpp               | 177 ++++++++++++++++--
+ .../sparse/cuda/SparseSemiStructuredLinear.cu |   4 +-
+ c10/util/Optional.cpp                         |  17 ++
+ c10/util/Optional.h                           |   6 +-
+ migration_note.md                             |  59 +++++-
+ third_party/cutlass                           |   2 +-
+ torch/csrc/distributed/c10d/init.cpp          |  10 +-
+ torch/csrc/distributed/rpc/init.cpp           |   6 +-
+ 8 files changed, 256 insertions(+), 25 deletions(-)
+
+diff --git a/aten/src/ATen/cuda/CUDABlas.cpp b/aten/src/ATen/cuda/CUDABlas.cpp
+index a161786074..c58a987680 100644
+--- a/aten/src/ATen/cuda/CUDABlas.cpp
++++ b/aten/src/ATen/cuda/CUDABlas.cpp
+@@ -15,6 +15,27 @@
+ // added bf16 support
+ #if !defined(USE_ROCM) && !defined(_MSC_VER)
+ #include <cublasLt.h>
++
++#if defined(__APPLE__) && defined(__MACH__)
++/** Semi-opaque descriptor for cublasLtMatmul() operation details
++ */
++typedef struct {
++  uint64_t data[32];
++} cublasLtMatmulDescOpaque_t;
++
++/** Semi-opaque descriptor for matrix memory layout
++ */
++typedef struct {
++  uint64_t data[8];
++} cublasLtMatrixLayoutOpaque_t;
++
++/** Semi-opaque descriptor for cublasLtMatmulPreference() operation details
++ */
++typedef struct {
++  uint64_t data[8];
++} cublasLtMatmulPreferenceOpaque_t;
++#endif
++
+ #endif
+ 
+ // refer to http://www.jcuda.org/jcuda/jcublas/doc/constant-values.html#jcuda.jcublas.cublasMath.CUBLAS_MATH_DISALLOW_REDUCED_PRECISION_REDUCTION
+@@ -205,10 +226,60 @@ static size_t _getWorkspaceSize() {
+ 
+ } // anonymous namespace
+ 
+-namespace at::cuda::blas {
++namespace at{ namespace cuda{ namespace blas {
+ 
+ /* LEVEL 3 BLAS FUNCTIONS */
+ 
++#ifndef USE_ROCM
++#if defined(CUDA_VERSION) && CUDA_VERSION >= 11020
++#define cublasGemmStridedBatchedExFix cublasGemmStridedBatchedEx
++#else
++// Workaround for https://github.com/pytorch/pytorch/issues/45724
++cublasStatus_t cublasGemmStridedBatchedExFix(cublasHandle_t &handle,
++  cublasOperation_t transa,
++  cublasOperation_t transb,
++  int m,
++  int n,
++  int k,
++  const void    *alpha,
++  const void     *A,
++  cudaDataType Atype,
++  int lda,
++  long long int strideA,
++  const void     *B,
++  cudaDataType Btype,
++  int ldb,
++  long long int strideB,
++  const void    *beta,
++  void           *C,
++  cudaDataType Ctype,
++  int ldc,
++  long long int strideC,
++  int64_t batchCount,
++  cudaDataType computeType,
++  cublasGemmAlgo_t algo)
++{
++  cudaDeviceProp* prop = at::cuda::getCurrentDeviceProperties();
++  if (prop->major != 7) {
++    return cublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha, A, Atype, lda, strideA, B, Btype, ldb, strideB, beta, C, Ctype, ldc, strideC, batchCount, computeType, algo);
++  }
++  cublasStatus_t result;
++  constexpr int64_t split = 63 * 1024;
++  for(int64_t i = 0; i < batchCount; i += split) {
++    int64_t count = std::min<int64_t>(split, batchCount - i);
++    result = cublasGemmStridedBatchedEx(handle, transa, transb, m, n, k, alpha,
++      (char *)A + i * strideA * 2, Atype, lda, strideA,
++      (char *)B + i * strideB * 2, Btype, ldb, strideB,
++      beta,
++      (char *)C + i * strideC * 2, Ctype, ldc, strideC,
++      (int)count, computeType, algo);
++    TORCH_CUDABLAS_CHECK(result);
++  }
++  return result;
++}
++#endif
++#endif
++
+ #define GEMM_CHECK_ARGVALUES(Dtype)           \
+   do {                                        \
+     CUDABLAS_NONNEGINT_CHECK(gemm<Dtype>, m); \
+@@ -527,7 +598,43 @@ void gemm<at::Half>(CUDABLAS_GEMM_ARGTYPES(at::Half)) {
+ #endif
+ }
+ 
+-#if !defined(USE_ROCM)
++#ifdef defined(USE_ROCM)
++template <>
++void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
++  cublasHandle_t handle = at::cuda::getCurrentCUDABlasHandle();
++  cublasOperation_t opa = _cublasOpFromChar(transa);
++  cublasOperation_t opb = _cublasOpFromChar(transb);
++  float falpha = alpha;
++  float fbeta = beta;
++  _cublasAdjustLdLevel3(transa, transb, m, n, k, &lda, &ldb, &ldc);
++  GEMM_CHECK_ARGVALUES(at::BFloat16);
++  TORCH_CUDABLAS_CHECK(rocblas_gemm_ex(
++      handle,
++      opa,
++      opb,
++      m,
++      n,
++      k,
++      &falpha,
++      a,
++      rocblas_datatype_bf16_r,
++      lda,
++      b,
++      rocblas_datatype_bf16_r,
++      ldb,
++      &fbeta,
++      c,
++      rocblas_datatype_bf16_r,
++      ldc,
++      c,
++      rocblas_datatype_bf16_r,
++      ldc,
++      rocblas_datatype_f32_r,
++      rocblas_gemm_algo_standard,
++      0,
++      0));
++}
++#else
+ template <>
+ void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
+   globalContext().alertCuBLASConfigNotDeterministic();
+@@ -567,7 +674,7 @@ void gemm<at::BFloat16>(CUDABLAS_GEMM_ARGTYPES(at::BFloat16)) {
+ }
+ #endif // !defined(USE_ROCM)
+ 
+-#if !defined(USE_ROCM) && !defined(_MSC_VER) && defined(CUDA_VERSION) && CUDA_VERSION >= 11000
++#if !defined(USE_ROCM) && !defined(_MSC_VER)
+ 
+ namespace {
+ // Following the pattern of CuSparseDescriptor
+@@ -597,6 +704,24 @@ class CuBlasLtDescriptor {
+   std::unique_ptr<T, CuBlasLtDeleter<T, destructor>> descriptor_;
+ };
+ 
++#if defined(__APPLE__) && defined(__MACH__)
++class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
++                                     cublasLtMatmulDescStruct,
++                                     &cublasLtMatmulDescDestroy> {
++ public:
++  CuBlasLtMatmulDescriptor(
++      cudaDataType_t scale_type) {
++    cublasLtMatmulDesc_t raw_descriptor = nullptr;
++    TORCH_CUDABLAS_CHECK(
++        cublasLtMatmulDescCreate(&raw_descriptor, scale_type));
++    descriptor_.reset(raw_descriptor);
++  }
++  template <typename T>
++  inline void setAttribute(cublasLtMatmulDescAttributes_t attr, const T value) {
++    TORCH_CUDABLAS_CHECK(::cublasLtMatmulDescSetAttribute(descriptor(), attr, &value, sizeof(T)));
++  }
++};
++#else
+ class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
+                                      cublasLtMatmulDescOpaque_t,
+                                      &cublasLtMatmulDescDestroy> {
+@@ -614,9 +739,10 @@ class CuBlasLtMatmulDescriptor : public CuBlasLtDescriptor<
+     TORCH_CUDABLAS_CHECK(::cublasLtMatmulDescSetAttribute(descriptor(), attr, &value, sizeof(T)));
+   }
+ };
++#endif
+ 
+ class CuBlasLtMatrixLayout : public CuBlasLtDescriptor<
+-                                 cublasLtMatrixLayoutOpaque_t,
++                                 cublasLtMatrixLayoutStruct,
+                                  &cublasLtMatrixLayoutDestroy> {
+  public:
+   CuBlasLtMatrixLayout(
+@@ -633,7 +759,7 @@ class CuBlasLtMatrixLayout : public CuBlasLtDescriptor<
+ };
+ 
+ class CuBlasLtMatmulPreference : public CuBlasLtDescriptor<
+-                                     cublasLtMatmulPreferenceOpaque_t,
++                                     cublasLtMatmulPreferenceStruct,
+                                      &cublasLtMatmulPreferenceDestroy> {
+  public:
+   CuBlasLtMatmulPreference() {
+@@ -648,8 +774,6 @@ class CuBlasLtMatmulPreference : public CuBlasLtDescriptor<
+ };
+ } // namespace
+ 
+-
+-#if !defined(USE_ROCM) && CUDA_VERSION >= 11000
+ template <typename Dtype>
+ void gemm_and_bias(
+     bool transpose_mat1,
+@@ -670,24 +794,38 @@ void gemm_and_bias(
+   opmath_t beta_val = 0; // bias is added in epilogue
+ 
+   cudaDataType_t abcType = CUDA_R_32F;
++#if !defined(__APPLE__) && !defined(__MACH__)
+   cublasComputeType_t computeType = CUBLAS_COMPUTE_32F;
++#endif
+   cudaDataType_t scaleType = CUDA_R_32F;
+-  if constexpr (std::is_same_v<Dtype, double>) {
++  if constexpr (std::is_same<Dtype, double>::value) {
+     abcType = CUDA_R_64F;
++#if !defined(__APPLE__) && !defined(__MACH__)
+     computeType = CUBLAS_COMPUTE_64F;
++#endif
+     scaleType = CUDA_R_64F;
+-  } else if constexpr (std::is_same_v<Dtype, float>) {
++  } else if constexpr (std::is_same<Dtype, float>::value) {
++#if !defined(__APPLE__) && !defined(__MACH__)
+     if (at::globalContext().allowTF32CuBLAS()) {
+       computeType = CUBLAS_COMPUTE_32F_FAST_TF32;
+     }
++#endif
+     abcType = CUDA_R_32F;
+-  } else if constexpr (std::is_same_v<Dtype, at::Half>) {
++  } else if constexpr (std::is_same<Dtype, at::Half>::value) {
+     abcType = CUDA_R_16F;
+-  } else if constexpr (std::is_same_v<Dtype, at::BFloat16>) {
++  } else if constexpr (std::is_same<Dtype, at::BFloat16>::value) {
++#if !defined(__APPLE__) && !defined(__MACH__)
+     abcType = CUDA_R_16BF;
++#else
++    abcType = CUDA_R_16F;
++#endif
+   }
+ 
++#if defined(__APPLE__) && defined(__MACH__)
++  CuBlasLtMatmulDescriptor computeDesc(scaleType);
++#else
+   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
++#endif
+   cublasOperation_t transa = transpose_mat1 ? CUBLAS_OP_T : CUBLAS_OP_N;
+   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, transa);
+   cublasOperation_t transb = transpose_mat2 ? CUBLAS_OP_T : CUBLAS_OP_N;
+@@ -783,8 +921,10 @@ void gemm_and_bias(
+       result_ld,
+       " abcType ",
+       abcType,
++#if !defined(__APPLE__) && !defined(__MACH__)
+       " computeType ",
+       computeType,
++#endif
+       " scaleType ",
+       scaleType);
+ }
+@@ -852,7 +992,6 @@ template void gemm_and_bias(
+     at::BFloat16* result_ptr,
+     int64_t result_ld,
+     GEMMAndBiasActivationEpilogue activation);
+-#endif
+ 
+ void scaled_gemm(
+     char transa,
+@@ -880,7 +1019,11 @@ void scaled_gemm(
+   const auto computeType = CUBLAS_COMPUTE_32F;
+   const auto scaleType = CUDA_R_32F;
+   const int8_t fastAccuMode = use_fast_accum ? 1 : 0;
++#if defined(__APPLE__) && defined(__MACH__)
++  CuBlasLtMatmulDescriptor computeDesc(scaleType);
++#else
+   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
++#endif
+   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, _cublasOpFromChar(transa));
+   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSB, _cublasOpFromChar(transb));
+   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_A_SCALE_POINTER, mat1_scale_ptr);
+@@ -982,13 +1125,19 @@ void int8_gemm(
+     int32_t* result_ptr,
+     int64_t result_ld) {
+ 
++#if !defined(__APPLE__) && !defined(__MACH__)
+   cublasComputeType_t computeType = CUBLAS_COMPUTE_32I;
++#endif
+   cudaDataType_t scaleType = CUDA_R_32I;
+ 
+   cudaDataType_t abType = CUDA_R_8I;
+   cudaDataType_t cType = CUDA_R_32I;
+ 
++#if defined(__APPLE__) && defined(__MACH__)
++  CuBlasLtMatmulDescriptor computeDesc(scaleType);
++#else
+   CuBlasLtMatmulDescriptor computeDesc(computeType, scaleType);
++#endif
+   cublasOperation_t transa = transpose_mat1 ? CUBLAS_OP_T : CUBLAS_OP_N;
+   computeDesc.setAttribute(CUBLASLT_MATMUL_DESC_TRANSA, transa);
+   cublasOperation_t transb = transpose_mat2 ? CUBLAS_OP_T : CUBLAS_OP_N;
+@@ -1047,8 +1196,10 @@ void int8_gemm(
+       abType,
+       " cType ",
+       cType,
++#if !defined(__APPLE__) && !defined(__MACH__)
+       " computeType ",
+       computeType,
++#endif
+       " scaleType ",
+       scaleType);
+ }
+@@ -1591,4 +1742,4 @@ void gelsBatched<c10::complex<float>>(CUDABLAS_GELS_BATCHED_ARGTYPES(c10::comple
+       batchSize));
+ }
+ 
+-} // namespace at::cuda::blas
++}}} // namespace at::cuda::blas
+diff --git a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
+index 3ea75cc84d..03d1c4319e 100644
+--- a/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
++++ b/aten/src/ATen/native/sparse/cuda/SparseSemiStructuredLinear.cu
+@@ -3,7 +3,7 @@
+ #include <ATen/cuda/CUDAUtils.h>
+ #include <ATen/Dispatch.h>
+ 
+-#if !defined(USE_ROCM) && !defined(__APPLE__) && !defined(__MACH__)
++#if !defined(USE_ROCM)
+ #include <cuda_runtime.h>
+ #include <cutlass/cutlass.h>
+ #include <cutlass/layout/layout.h>
+@@ -12,8 +12,10 @@
+ #include <cutlass/epilogue/thread/linear_combination_relu.h>
+ #include <cutlass/epilogue/thread/linear_combination_silu.h>
+ #include <cutlass/gemm/gemm.h>
++#if !defined(__APPLE__) && !defined(__MACH__)
+ #include <cutlass/gemm/device/gemm_sparse_row_broadcast.h>
+ #endif
++#endif
+ 
+ #include <type_traits>
+ #if defined(__APPLE__) && defined(__MACH__)
+diff --git a/c10/util/Optional.cpp b/c10/util/Optional.cpp
+index 7389393e66..c83614d448 100644
+--- a/c10/util/Optional.cpp
++++ b/c10/util/Optional.cpp
+@@ -1 +1,18 @@
++#include <c10/util/ArrayRef.h>
+ #include <c10/util/Optional.h>
++
++#include <type_traits>
++
++static_assert(
++    C10_IS_TRIVIALLY_COPYABLE(c10::optional<int>),
++    "c10::optional<int> should be trivially copyable");
++static_assert(
++    C10_IS_TRIVIALLY_COPYABLE(c10::optional<bool>),
++    "c10::optional<bool> should be trivially copyable");
++static_assert(
++    C10_IS_TRIVIALLY_COPYABLE(c10::optional<c10::IntArrayRef>),
++    "c10::optional<IntArrayRef> should be trivially copyable");
++static_assert(
++    sizeof(c10::optional<c10::IntArrayRef>) == sizeof(c10::IntArrayRef),
++    "c10::optional<IntArrayRef> should be size-optimized");
++
+diff --git a/c10/util/Optional.h b/c10/util/Optional.h
+index 45d58282e3..23eac9e0ec 100644
+--- a/c10/util/Optional.h
++++ b/c10/util/Optional.h
+@@ -1,7 +1,7 @@
+ #ifndef C10_UTIL_OPTIONAL_H_
+ #define C10_UTIL_OPTIONAL_H_
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
++// #if defined(__APPLE__) && defined(__MACH__)
+ 
+ #include <c10/macros/Macros.h>
+ #include <c10/util/ArrayRef.h>
+@@ -1235,7 +1235,7 @@ struct hash<c10::optional<T&>> {
+ 
+ C10_CLANG_DIAGNOSTIC_POP()
+ 
+-#else
++#if !defined(__APPLE__) && !defined(__MACH__)
+ 
+ #include <optional>
+ #include <type_traits>
+@@ -1281,6 +1281,6 @@ constexpr T value_or_else(optional<T>&& v, F&& func) {
+ }
+ } // namespace c10
+ 
+-#endif // defined(__APPLE__) && defined(__MACH__)
++#endif // !defined(__APPLE__) && !defined(__MACH__)
+ 
+ #endif // C10_UTIL_OPTIONAL_H_
+diff --git a/migration_note.md b/migration_note.md
+index d0cf1e1d10..4ea0691f13 100644
+--- a/migration_note.md
++++ b/migration_note.md
+@@ -6,7 +6,9 @@ Preparation of building library:
+ export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
+ export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
+ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean # prepare
+-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
++MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
++MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
++MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=OFF USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py develop
+ ```
+ 
+ ## 1, Missing ATen cuda
+@@ -104,3 +106,58 @@ Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.1
+ ```cmake
+  list(APPEND Caffe2_GPU_INCLUDE ${ATen_CUDA_INCLUDE} /usr/local/cuda/include ${PROJECT_SOURCE_DIR}/third_party/cutlass/include)
+ ```
++
++## 4. Runtime issue
++
++torch 2.2.0
++
++```bash
++(base) Orlando:gpu-magma2.6.1-distributed-all-2.2.0-py3.10 llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
++/Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib:
++	@rpath/libtorch_python.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libshm.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libtorch.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libtorch_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libnvToolsExt.1.dylib (compatibility version 0.0.0, current version 1.0.0)
++	@rpath/libtorch_cpu.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_intel_lp64.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_intel_thread.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_core.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libomp.dylib (compatibility version 5.0.0, current version 5.0.0)
++	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)
++	@rpath/libc10_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libc10.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libcudart.10.2.dylib (compatibility version 0.0.0, current version 10.2.89)
++	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
++	/usr/local/opt/open-mpi/lib/libmpi.40.dylib (compatibility version 71.0.0, current version 71.1.0)
++	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
++```
++
++torch 2.0.0
++
++```bash
++(base) Orlando:lib llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
++/Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib:
++	@rpath/libtorch_python.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libshm.dylib (compatibility version 0.0.0, current version 0.0.0)
++	/usr/local/opt/open-mpi/lib/libmpi.40.dylib (compatibility version 71.0.0, current version 71.1.0)
++	@rpath/libtorch.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libtorch_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libnvrtc.10.1.dylib (compatibility version 0.0.0, current version 10.1.243)
++	@rpath/libnvToolsExt.1.dylib (compatibility version 0.0.0, current version 1.0.0)
++	@rpath/libtorch_cpu.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_intel_lp64.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_intel_thread.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libmkl_core.2.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libomp.dylib (compatibility version 5.0.0, current version 5.0.0)
++	/usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)
++	@rpath/libc10_cuda.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libc10.dylib (compatibility version 0.0.0, current version 0.0.0)
++	@rpath/libcudart.10.1.dylib (compatibility version 0.0.0, current version 10.1.243)
++	@rpath/libcufft.10.dylib (compatibility version 0.0.0, current version 10.1.1)
++	@rpath/libcurand.10.dylib (compatibility version 0.0.0, current version 10.1.1)
++	@rpath/libcublas.10.dylib (compatibility version 0.0.0, current version 10.2.1)
++	@rpath/libcublasLt.10.dylib (compatibility version 0.0.0, current version 10.2.1)
++	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
++	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
++```
+diff --git a/third_party/cutlass b/third_party/cutlass
+index 63fc6f05ff..b72cbf957d 160000
+--- a/third_party/cutlass
++++ b/third_party/cutlass
+@@ -1 +1 @@
+-Subproject commit 63fc6f05ffbfa66ca9e5548a041517bb6100e52c
++Subproject commit b72cbf957df8cf84a6d0ff91c190ad51a9c1d24a
+diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
+index 3296bd3754..0206be063d 100644
+--- a/torch/csrc/distributed/c10d/init.cpp
++++ b/torch/csrc/distributed/c10d/init.cpp
+@@ -1726,8 +1726,8 @@ Arguments:
+               },
+               py::arg("device"),
+               py::arg("backend_type"),
+-              py::arg("backend") =
+-                  c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
++            //   py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
++              py::arg("backend"),
+               py::call_guard<py::gil_scoped_release>())
+           .def(
+               "_get_backend",
+@@ -2589,7 +2589,8 @@ Example::
+       py::arg("bucket_size"),
+       py::arg("expect_sparse_gradient") = std::vector<bool>(),
+       py::arg("tensor_indices") = std::vector<int64_t>(),
+-      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++      py::arg("logger"),
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+@@ -2607,7 +2608,8 @@ Example::
+       },
+       py::arg("process_group"),
+       py::arg("params"),
+-      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++      py::arg("logger"),
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
+index 7b8a2d1f18..69ac2a13ce 100644
+--- a/torch/csrc/distributed/rpc/init.cpp
++++ b/torch/csrc/distributed/rpc/init.cpp
+@@ -544,8 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
+               std::unordered_map<std::string, DeviceMap>,
+               std::vector<c10::Device>>(),
+           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
+-          py::arg("_transports") = optional<std::vector<std::string>>(),
+-          py::arg("_channels") = optional<std::vector<std::string>>(),
++        //   py::arg("_transports") = optional<std::vector<std::string>>(),
++          py::arg("_transports"),
++        //   py::arg("_channels") = optional<std::vector<std::string>>(),
++          py::arg("_channels"),
+           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
+           py::arg("init_method") = kDefaultInitMethod,
+           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 46b15b281dabf8ea5974ceb12670d113bdc94cf5 Mon Sep 17 00:00:00 2001
+From: orlando <xiandao.airs@gmail.com>
+Date: Sun, 18 Feb 2024 21:07:47 -0800
+Subject: [PATCH 4/8] Update intrusive_ptr.h
+
+updates of headers
+---
+ c10/util/intrusive_ptr.h | 3 +++
+ 1 file changed, 3 insertions(+)
+
+diff --git a/c10/util/intrusive_ptr.h b/c10/util/intrusive_ptr.h
+index 8e43dbd876..704cc486bb 100644
+--- a/c10/util/intrusive_ptr.h
++++ b/c10/util/intrusive_ptr.h
+@@ -1,10 +1,13 @@
+ #pragma once
+ 
++#include <c10/util/C++17.h>
+ #include <c10/util/Exception.h>
++#include <c10/util/ExclusivelyOwned.h>
+ #include <c10/util/MaybeOwned.h>
+ #include <atomic>
+ #include <climits>
+ #include <memory>
++#include <stdexcept>
+ 
+ namespace pybind11 {
+ template <typename, typename...>
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 9c9075760717f51df205bc16623abee398131651 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Thu, 22 Feb 2024 14:20:26 -0800
+Subject: [PATCH 5/8] orlando - for fixing the issue of pocketfft invalid url
+
+---
+ migration_note.md                    |  4 ++--
+ third_party/pocketfft                |  2 +-
+ torch/csrc/distributed/c10d/init.cpp | 12 ++++++------
+ torch/csrc/distributed/rpc/init.cpp  |  8 ++++----
+ 4 files changed, 13 insertions(+), 13 deletions(-)
+
+diff --git a/migration_note.md b/migration_note.md
+index 4ea0691f13..6907bf5c79 100644
+--- a/migration_note.md
++++ b/migration_note.md
+@@ -5,9 +5,9 @@ Preparation of building library:
+ ```bash
+ export CXXFLAGS=-D_LIBCPP_DISABLE_AVAILABILITY
+ export CMAKE_PREFIX_PATH=${CONDA_PREFIX:-"$(dirname $(which conda))/../"}
+-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean # prepare
++MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py clean
+ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
+-MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel
++MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ CMAKE_BUILD_TYPE=1 DEBUG=1 USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=ON USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py bdist_wheel # current running
+ MAGMA_HOME="/usr/local/lib/magma2.6.1-cu101" MACOSX_DEPLOYMENT_TARGET=10.9 CC=clang CXX=clang++ USE_LIBUV=1 USE_CUSPARSELT=1 USE_DISTRIBUTED=ON USE_MPI=OFF USE_TENSORPIPE=ON USE_GLOO=ON USE_CUDA_MPI=ON python setup.py develop
+ ```
+ 
+diff --git a/third_party/pocketfft b/third_party/pocketfft
+index ad1eec0fb2..81d171a6d5 160000
+--- a/third_party/pocketfft
++++ b/third_party/pocketfft
+@@ -1 +1 @@
+-Subproject commit ad1eec0fb2f8bfb28e287c559a29bc16d059abf0
++Subproject commit 81d171a6d5562e3aaa2c73489b70f564c633ff81
+diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
+index 0206be063d..a9662a975d 100644
+--- a/torch/csrc/distributed/c10d/init.cpp
++++ b/torch/csrc/distributed/c10d/init.cpp
+@@ -1726,8 +1726,8 @@ Arguments:
+               },
+               py::arg("device"),
+               py::arg("backend_type"),
+-            //   py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+-              py::arg("backend"),
++              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
++            //   py::arg("backend"),
+               py::call_guard<py::gil_scoped_release>())
+           .def(
+               "_get_backend",
+@@ -2589,8 +2589,8 @@ Example::
+       py::arg("bucket_size"),
+       py::arg("expect_sparse_gradient") = std::vector<bool>(),
+       py::arg("tensor_indices") = std::vector<int64_t>(),
+-    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+-      py::arg("logger"),
++      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++    //   py::arg("logger"), 
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+@@ -2608,8 +2608,8 @@ Example::
+       },
+       py::arg("process_group"),
+       py::arg("params"),
+-    //   py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+-      py::arg("logger"),
++      py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
++    //   py::arg("logger"),
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
+index 69ac2a13ce..aa8f0d7a87 100644
+--- a/torch/csrc/distributed/rpc/init.cpp
++++ b/torch/csrc/distributed/rpc/init.cpp
+@@ -544,10 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
+               std::unordered_map<std::string, DeviceMap>,
+               std::vector<c10::Device>>(),
+           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
+-        //   py::arg("_transports") = optional<std::vector<std::string>>(),
+-          py::arg("_transports"),
+-        //   py::arg("_channels") = optional<std::vector<std::string>>(),
+-          py::arg("_channels"),
++          py::arg("_transports") = optional<std::vector<std::string>>(),
++        //   py::arg("_transports"),
++          py::arg("_channels") = optional<std::vector<std::string>>(),
++        //   py::arg("_channels"),
+           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
+           py::arg("init_method") = kDefaultInitMethod,
+           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 43ad1043be66454df9c5fc9eb3ce7679a2ee8baa Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Sat, 24 Feb 2024 22:58:08 -0800
+Subject: [PATCH 6/8] orlando - for fixing issues of init.cpp and avoid issue
+
+---
+ c10/util/Optional.h                       |  7 +++----
+ caffe2/serialize/inline_container.cc      |  4 +++-
+ caffe2/serialize/inline_container.h       |  4 ++--
+ caffe2/serialize/inline_container_test.cc |  4 ++--
+ torch/csrc/distributed/c10d/init.cpp      |  5 ++++-
+ torch/csrc/distributed/rpc/init.cpp       | 10 +++++-----
+ 6 files changed, 19 insertions(+), 15 deletions(-)
+
+diff --git a/c10/util/Optional.h b/c10/util/Optional.h
+index 23eac9e0ec..e2ae1f81e5 100644
+--- a/c10/util/Optional.h
++++ b/c10/util/Optional.h
+@@ -1,7 +1,7 @@
+ #ifndef C10_UTIL_OPTIONAL_H_
+ #define C10_UTIL_OPTIONAL_H_
+ 
+-// #if defined(__APPLE__) && defined(__MACH__)
++#if defined(__APPLE__) && defined(__MACH__)
+ 
+ #include <c10/macros/Macros.h>
+ #include <c10/util/ArrayRef.h>
+@@ -1235,7 +1235,7 @@ struct hash<c10::optional<T&>> {
+ 
+ C10_CLANG_DIAGNOSTIC_POP()
+ 
+-#if !defined(__APPLE__) && !defined(__MACH__)
++#else // !defined(__APPLE__) && !defined(__MACH__)
+ 
+ #include <optional>
+ #include <type_traits>
+@@ -1250,7 +1250,6 @@ namespace c10 {
+ using std::bad_optional_access;
+ using std::in_place;
+ using std::in_place_t;
+-using std::make_optional;
+ using std::nullopt;
+ using std::nullopt_t;
+ using std::optional;
+@@ -1281,6 +1280,6 @@ constexpr T value_or_else(optional<T>&& v, F&& func) {
+ }
+ } // namespace c10
+ 
+-#endif // !defined(__APPLE__) && !defined(__MACH__)
++#endif // defined(__APPLE__) && defined(__MACH__)
+ 
+ #endif // C10_UTIL_OPTIONAL_H_
+diff --git a/caffe2/serialize/inline_container.cc b/caffe2/serialize/inline_container.cc
+index 533fd42a04..20ea4e6923 100644
+--- a/caffe2/serialize/inline_container.cc
++++ b/caffe2/serialize/inline_container.cc
+@@ -34,12 +34,14 @@ constexpr c10::string_view kDebugPklSuffix(".debug_pkl");
+ struct MzZipReaderIterWrapper {
+   MzZipReaderIterWrapper(mz_zip_reader_extract_iter_state* iter) : impl(iter) {}
+   mz_zip_reader_extract_iter_state* impl;
++  // Disable the move constructor
++  MzZipReaderIterWrapper(MzZipReaderIterWrapper&& other) = delete;
+ };
+ 
+ ChunkRecordIterator::ChunkRecordIterator(
+     size_t recordSize,
+     size_t chunkSize,
+-    std::unique_ptr<MzZipReaderIterWrapper> iter)
++    std::shared_ptr<MzZipReaderIterWrapper> iter)
+     : recordSize_(recordSize),
+       chunkSize_(chunkSize),
+       offset_(0),
+diff --git a/caffe2/serialize/inline_container.h b/caffe2/serialize/inline_container.h
+index aa0cb8e043..d4b98b41a6 100644
+--- a/caffe2/serialize/inline_container.h
++++ b/caffe2/serialize/inline_container.h
+@@ -109,12 +109,12 @@ class TORCH_API ChunkRecordIterator {
+  ChunkRecordIterator(
+       size_t recordSize,
+       size_t chunkSize,
+-      std::unique_ptr<MzZipReaderIterWrapper> iter);
++      std::shared_ptr<MzZipReaderIterWrapper> iter);
+ 
+   const size_t recordSize_;
+   const size_t chunkSize_;
+   size_t offset_;
+-  std::unique_ptr<MzZipReaderIterWrapper> iter_;
++  std::shared_ptr<MzZipReaderIterWrapper> iter_;
+ 
+   friend class PyTorchStreamReader;
+ };
+diff --git a/caffe2/serialize/inline_container_test.cc b/caffe2/serialize/inline_container_test.cc
+index 4fe2c236e0..2e597a01fc 100644
+--- a/caffe2/serialize/inline_container_test.cc
++++ b/caffe2/serialize/inline_container_test.cc
+@@ -464,7 +464,7 @@ TEST_P(ChunkRecordIteratorTest, ChunkRead) {
+   LOG(INFO) << "Testing chunk size " << chunkSize;
+   PyTorchStreamReader reader(fileName);
+   ASSERT_TRUE(reader.hasRecord(recordName));
+-  #if !defined(__APPLE__) && !defined(__MACH__)
++  // #if !defined(__APPLE__) && !defined(__MACH__)
+   //see: to avoid "error: call to implicitly-deleted copy constructor of 'caffe2::serialize::ChunkRecordIterator'"
+   caffe2::serialize::ChunkRecordIterator chunkIterator = reader.createChunkReaderIter(
+       recordName, tensorDataSizeInBytes, chunkSize);
+@@ -476,7 +476,7 @@ TEST_P(ChunkRecordIteratorTest, ChunkRead) {
+     totalReadSize += readSize;
+   }
+   ASSERT_EQ(totalReadSize, tensorDataSizeInBytes);
+-  #endif
++  // #endif
+   // clean up
+   remove(fileName);
+ }
+diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
+index a9662a975d..d81f7c2087 100644
+--- a/torch/csrc/distributed/c10d/init.cpp
++++ b/torch/csrc/distributed/c10d/init.cpp
+@@ -107,6 +107,9 @@ namespace c10d {
+ 
+ namespace {
+ 
++using ::c10::in_place;
++using ::c10::in_place_t;
++
+ template <typename T>
+ using shared_ptr_class_ = py::class_<T, std::shared_ptr<T>>;
+ 
+@@ -1726,8 +1729,8 @@ Arguments:
+               },
+               py::arg("device"),
+               py::arg("backend_type"),
+-              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+             //   py::arg("backend"),
++              py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+               py::call_guard<py::gil_scoped_release>())
+           .def(
+               "_get_backend",
+diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
+index aa8f0d7a87..b90fe6c387 100644
+--- a/torch/csrc/distributed/rpc/init.cpp
++++ b/torch/csrc/distributed/rpc/init.cpp
+@@ -537,16 +537,16 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
+       .def(
+           py::init<
+               int,
+-              optional<std::vector<std::string>>,
+-              optional<std::vector<std::string>>,
++              c10::optional<std::vector<std::string>>,
++              c10::optional<std::vector<std::string>>,
+               float,
+               std::string,
+               std::unordered_map<std::string, DeviceMap>,
+               std::vector<c10::Device>>(),
+           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
+-          py::arg("_transports") = optional<std::vector<std::string>>(),
++          py::arg("_transports") = c10::optional<std::vector<std::string>>(),
+         //   py::arg("_transports"),
+-          py::arg("_channels") = optional<std::vector<std::string>>(),
++          py::arg("_channels") = c10::optional<std::vector<std::string>>(),
+         //   py::arg("_channels"),
+           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
+           py::arg("init_method") = kDefaultInitMethod,
+@@ -579,7 +579,7 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
+               [](const c10::intrusive_ptr<::c10d::Store>& store,
+                  std::string selfName,
+                  worker_id_t selfId,
+-                 optional<int> worldSize,
++                 c10::optional<int> worldSize,
+                  TensorPipeRpcBackendOptions opts,
+                  std::unordered_map<std::string, DeviceMap> reverseDeviceMaps,
+                  std::vector<c10::Device> devices) {
+-- 
+2.17.2 (Apple Git-113)
+
+
+From 3322cd3fa1d8189275f6e4b96fdee2526f9358d5 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Sun, 25 Feb 2024 22:24:58 -0800
+Subject: [PATCH 7/8] orlando - for updates of torch init.cpp and library.h
+
+---
+ aten/src/ATen/functorch/Interpreter.h         |  2 +-
+ aten/src/ATen/native/LinearAlgebra.cpp        |  1 +
+ c10/util/Exception.h                          |  4 ---
+ migration_note.md                             | 10 ++++++-
+ .../include/torch/nn/functional/upsampling.h  |  1 -
+ torch/csrc/api/include/torch/nn/init.h        | 17 ------------
+ .../csrc/api/include/torch/nn/modules/conv.h  |  1 -
+ .../torch/nn/options/transformerlayer.h       |  8 +-----
+ .../api/include/torch/nn/options/upsampling.h | 26 +++----------------
+ torch/csrc/api/src/nn/modules/conv.cpp        |  1 -
+ torch/csrc/autograd/profiler_kineto.cpp       |  1 -
+ torch/csrc/distributed/c10d/init.cpp          |  6 ++---
+ torch/csrc/distributed/rpc/init.cpp           |  8 +++---
+ torch/csrc/profiler/python/init.cpp           |  4 ---
+ torch/csrc/profiler/util.h                    |  2 --
+ torch/csrc/utils/pybind.h                     | 14 ++++++++++
+ torch/library.h                               |  1 +
+ 17 files changed, 38 insertions(+), 69 deletions(-)
+
+diff --git a/aten/src/ATen/functorch/Interpreter.h b/aten/src/ATen/functorch/Interpreter.h
+index 11cb41ee79..c4ccbee17c 100644
+--- a/aten/src/ATen/functorch/Interpreter.h
++++ b/aten/src/ATen/functorch/Interpreter.h
+@@ -9,8 +9,8 @@
+ #include <c10/util/variant.h>
+ namespace std {
+   using ::c10::variant;
+-  using ::c10::get;
+   using ::c10::holds_alternative;
++  using ::c10::get;
+ } // namespace std
+ #else
+ #include <variant>
+diff --git a/aten/src/ATen/native/LinearAlgebra.cpp b/aten/src/ATen/native/LinearAlgebra.cpp
+index 530f2ed3ca..c1ebcb2fd1 100644
+--- a/aten/src/ATen/native/LinearAlgebra.cpp
++++ b/aten/src/ATen/native/LinearAlgebra.cpp
+@@ -26,6 +26,7 @@ namespace std {
+   // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+   using ::c10::variant;
+   using ::c10::get_if;
++  using ::c10::get;
+ }// namespace std
+ #else
+ #include <variant>
+diff --git a/c10/util/Exception.h b/c10/util/Exception.h
+index fa5e67ddda..9f003c7730 100644
+--- a/c10/util/Exception.h
++++ b/c10/util/Exception.h
+@@ -122,11 +122,7 @@ class C10_API Warning {
+   class C10_API UserWarning {};
+   class C10_API DeprecationWarning {};
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
+-  using warning_variant_t = c10::variant<UserWarning, DeprecationWarning>;
+-#else
+   using warning_variant_t = std::variant<UserWarning, DeprecationWarning>;
+-#endif
+ 
+   Warning(
+       warning_variant_t type,
+diff --git a/migration_note.md b/migration_note.md
+index 6907bf5c79..d26c6c2100 100644
+--- a/migration_note.md
++++ b/migration_note.md
+@@ -109,7 +109,13 @@ Solution: correct the caffe2/CMakeLists.txt in Line 96 and switch cutlass to 2.1
+ 
+ ## 4. Runtime issue
+ 
+-torch 2.2.0
++torch 2.2.0's bash script result:
++
++```bash
++In [1]: import torch
++libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: arg(): could not convert default argument 'backend: c10::optional<c10::intrusive_ptr<c10d::Backend, c10::detail::intrusive_target_default_null_type<c10d::Backend> > >' in method '<class 'torch._C._distributed_c10d.ProcessGroup'>._register_backend' into a Python object (type not registered yet?)
++Abort trap: 6
++```
+ 
+ ```bash
+ (base) Orlando:gpu-magma2.6.1-distributed-all-2.2.0-py3.10 llv23$ otool -L /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/lib/libtorch_python.dylib
+@@ -161,3 +167,5 @@ torch 2.0.0
+ 	@rpath/libcudnn.7.dylib (compatibility version 0.0.0, current version 7.6.5)
+ 	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
+ ```
++
++change torch/csrc/utils/pybind.h with 
+\ No newline at end of file
+diff --git a/torch/csrc/api/include/torch/nn/functional/upsampling.h b/torch/csrc/api/include/torch/nn/functional/upsampling.h
+index fb8a343f44..a8ad434cbb 100644
+--- a/torch/csrc/api/include/torch/nn/functional/upsampling.h
++++ b/torch/csrc/api/include/torch/nn/functional/upsampling.h
+@@ -10,7 +10,6 @@
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ namespace std {
+-  using ::c10::variant;
+   using ::c10::holds_alternative;
+   using ::c10::get_if;
+ }// namespace std
+diff --git a/torch/csrc/api/include/torch/nn/init.h b/torch/csrc/api/include/torch/nn/init.h
+index 7f36db896d..2ff0a51146 100644
+--- a/torch/csrc/api/include/torch/nn/init.h
++++ b/torch/csrc/api/include/torch/nn/init.h
+@@ -20,22 +20,6 @@ namespace nn {
+ namespace init {
+ 
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
+-using NonlinearityType = c10::variant<
+-    enumtype::kLinear,
+-    enumtype::kConv1D,
+-    enumtype::kConv2D,
+-    enumtype::kConv3D,
+-    enumtype::kConvTranspose1D,
+-    enumtype::kConvTranspose2D,
+-    enumtype::kConvTranspose3D,
+-    enumtype::kSigmoid,
+-    enumtype::kTanh,
+-    enumtype::kReLU,
+-    enumtype::kLeakyReLU>;
+-
+-using FanModeType = c10::variant<enumtype::kFanIn, enumtype::kFanOut>;
+-#else
+ using NonlinearityType = std::variant<
+     enumtype::kLinear,
+     enumtype::kConv1D,
+@@ -50,7 +34,6 @@ using NonlinearityType = std::variant<
+     enumtype::kLeakyReLU>;
+ 
+ using FanModeType = std::variant<enumtype::kFanIn, enumtype::kFanOut>;
+-#endif
+ 
+ } // namespace init
+ } // namespace nn
+diff --git a/torch/csrc/api/include/torch/nn/modules/conv.h b/torch/csrc/api/include/torch/nn/modules/conv.h
+index f61a9fab2d..2b7809d18e 100644
+--- a/torch/csrc/api/include/torch/nn/modules/conv.h
++++ b/torch/csrc/api/include/torch/nn/modules/conv.h
+@@ -20,7 +20,6 @@
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ namespace std {
+-  using ::c10::variant;
+   using ::c10::holds_alternative;
+   using ::c10::get_if;
+ }// namespace std
+diff --git a/torch/csrc/api/include/torch/nn/options/transformerlayer.h b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
+index 84e6221588..ded2018806 100644
+--- a/torch/csrc/api/include/torch/nn/options/transformerlayer.h
++++ b/torch/csrc/api/include/torch/nn/options/transformerlayer.h
+@@ -17,17 +17,11 @@ namespace std {
+ namespace torch {
+ namespace nn {
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
+-using activation_t = c10::variant<
+-    enumtype::kReLU,
+-    enumtype::kGELU,
+-    std::function<Tensor(const Tensor&)>>;
+-#else
++
+ using activation_t = std::variant<
+     enumtype::kReLU,
+     enumtype::kGELU,
+     std::function<Tensor(const Tensor&)>>;
+-#endif
+ 
+ /// Options for the `TransformerEncoderLayer`
+ ///
+diff --git a/torch/csrc/api/include/torch/nn/options/upsampling.h b/torch/csrc/api/include/torch/nn/options/upsampling.h
+index 122df40912..898280ae85 100644
+--- a/torch/csrc/api/include/torch/nn/options/upsampling.h
++++ b/torch/csrc/api/include/torch/nn/options/upsampling.h
+@@ -10,6 +10,9 @@
+ 
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
++namespace std {
++  using ::c10::variant;
++}// namespace std
+ #else
+ #include <variant>
+ #endif
+@@ -33,15 +36,6 @@ struct TORCH_API UpsampleOptions {
+ 
+   /// the upsampling algorithm: one of "nearest", "linear", "bilinear",
+   /// "bicubic" and "trilinear". Default: "nearest"
+-#if defined(__APPLE__) && defined(__MACH__)
+-  typedef c10::variant<
+-      enumtype::kNearest,
+-      enumtype::kLinear,
+-      enumtype::kBilinear,
+-      enumtype::kBicubic,
+-      enumtype::kTrilinear>
+-      mode_t;
+-#else
+   typedef std::variant<
+       enumtype::kNearest,
+       enumtype::kLinear,
+@@ -49,7 +43,7 @@ struct TORCH_API UpsampleOptions {
+       enumtype::kBicubic,
+       enumtype::kTrilinear>
+       mode_t;
+-#endif
++  
+   TORCH_ARG(mode_t, mode) = torch::kNearest;
+ 
+   /// if "True", the corner pixels of the input and output tensors are
+@@ -70,17 +64,6 @@ namespace functional {
+ /// F::InterpolateFuncOptions().size(std::vector<int64_t>({4})).mode(torch::kNearest));
+ /// ```
+ struct TORCH_API InterpolateFuncOptions {
+-#if defined(__APPLE__) && defined(__MACH__)
+-  typedef c10::variant<
+-      enumtype::kNearest,
+-      enumtype::kLinear,
+-      enumtype::kBilinear,
+-      enumtype::kBicubic,
+-      enumtype::kTrilinear,
+-      enumtype::kArea,
+-      enumtype::kNearestExact>
+-      mode_t;
+-#else
+   typedef std::variant<
+       enumtype::kNearest,
+       enumtype::kLinear,
+@@ -90,7 +73,6 @@ struct TORCH_API InterpolateFuncOptions {
+       enumtype::kArea,
+       enumtype::kNearestExact>
+       mode_t;
+-#endif
+ 
+   /// output spatial sizes.
+   TORCH_ARG(c10::optional<std::vector<int64_t>>, size) = c10::nullopt;
+diff --git a/torch/csrc/api/src/nn/modules/conv.cpp b/torch/csrc/api/src/nn/modules/conv.cpp
+index b1a9ddb116..4cb106546f 100644
+--- a/torch/csrc/api/src/nn/modules/conv.cpp
++++ b/torch/csrc/api/src/nn/modules/conv.cpp
+@@ -18,7 +18,6 @@
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ namespace std {
+-  using ::c10::variant;
+   using ::c10::holds_alternative;
+   using ::c10::get_if;
+ }// namespace std
+diff --git a/torch/csrc/autograd/profiler_kineto.cpp b/torch/csrc/autograd/profiler_kineto.cpp
+index 3bb25ecc0e..02670dad96 100644
+--- a/torch/csrc/autograd/profiler_kineto.cpp
++++ b/torch/csrc/autograd/profiler_kineto.cpp
+@@ -31,7 +31,6 @@
+ #if defined(__APPLE__) && defined(__MACH__)
+ #include <c10/util/variant.h>
+ namespace std {
+-  using ::c10::variant;
+   using ::c10::holds_alternative;
+   using ::c10::get;
+   using ::c10::get_if;
+diff --git a/torch/csrc/distributed/c10d/init.cpp b/torch/csrc/distributed/c10d/init.cpp
+index d81f7c2087..4a8edf3356 100644
+--- a/torch/csrc/distributed/c10d/init.cpp
++++ b/torch/csrc/distributed/c10d/init.cpp
+@@ -1729,7 +1729,7 @@ Arguments:
+               },
+               py::arg("device"),
+               py::arg("backend_type"),
+-            //   py::arg("backend"),
++              //see: pybind11 backend with optional
+               py::arg("backend") = c10::optional<c10::intrusive_ptr<::c10d::Backend>>(),
+               py::call_guard<py::gil_scoped_release>())
+           .def(
+@@ -2592,8 +2592,8 @@ Example::
+       py::arg("bucket_size"),
+       py::arg("expect_sparse_gradient") = std::vector<bool>(),
+       py::arg("tensor_indices") = std::vector<int64_t>(),
++      //see: pybind11 Logger
+       py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+-    //   py::arg("logger"), 
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+@@ -2611,8 +2611,8 @@ Example::
+       },
+       py::arg("process_group"),
+       py::arg("params"),
++      //see: pybind11 Logger
+       py::arg("logger") = c10::optional<std::shared_ptr<::c10d::Logger>>{},
+-    //   py::arg("logger"),
+       py::call_guard<py::gil_scoped_release>());
+ 
+   module.def(
+diff --git a/torch/csrc/distributed/rpc/init.cpp b/torch/csrc/distributed/rpc/init.cpp
+index b90fe6c387..e7529bb53c 100644
+--- a/torch/csrc/distributed/rpc/init.cpp
++++ b/torch/csrc/distributed/rpc/init.cpp
+@@ -544,10 +544,10 @@ PyObject* rpc_init(PyObject* _unused, PyObject* noargs) {
+               std::unordered_map<std::string, DeviceMap>,
+               std::vector<c10::Device>>(),
+           py::arg("num_worker_threads") = kDefaultNumWorkerThreads,
+-          py::arg("_transports") = c10::optional<std::vector<std::string>>(),
+-        //   py::arg("_transports"),
+-          py::arg("_channels") = c10::optional<std::vector<std::string>>(),
+-        //   py::arg("_channels"),
++        //  see: pybind11 py::arg("_transports"),
++          py::arg("_transports") = optional<std::vector<std::string>>(),
++        //  see: pybind11 py::arg("_channels"),
++          py::arg("_channels") = optional<std::vector<std::string>>(),
+           py::arg("rpc_timeout") = kDefaultRpcTimeoutSeconds,
+           py::arg("init_method") = kDefaultInitMethod,
+           py::arg("device_maps") = std::unordered_map<std::string, DeviceMap>(),
+diff --git a/torch/csrc/profiler/python/init.cpp b/torch/csrc/profiler/python/init.cpp
+index 2c5635c720..5bc1354eeb 100644
+--- a/torch/csrc/profiler/python/init.cpp
++++ b/torch/csrc/profiler/python/init.cpp
+@@ -10,10 +10,6 @@
+ #include <torch/csrc/profiler/standalone/execution_trace_observer.h>
+ #include <torch/csrc/utils/pybind.h>
+ 
+-#if defined(__APPLE__) && defined(__MACH__)
+-#include <c10/util/variant.h>
+-#endif
+-
+ struct THPCapturedTraceback {
+   PyObject_HEAD std::shared_ptr<torch::CapturedTraceback> data;
+ };
+diff --git a/torch/csrc/profiler/util.h b/torch/csrc/profiler/util.h
+index c35da5a16d..161b912d32 100644
+--- a/torch/csrc/profiler/util.h
++++ b/torch/csrc/profiler/util.h
+@@ -18,8 +18,6 @@
+ #include <c10/util/variant.h>
+ namespace std {
+   using ::c10::variant;
+-  using ::c10::holds_alternative;
+-  using ::c10::get;
+ }// namespace std
+ #else
+ #include <variant>
+diff --git a/torch/csrc/utils/pybind.h b/torch/csrc/utils/pybind.h
+index 4f3871d3ea..9dc45109d3 100644
+--- a/torch/csrc/utils/pybind.h
++++ b/torch/csrc/utils/pybind.h
+@@ -5,6 +5,9 @@
+ #include <ATen/core/Tensor.h>
+ #include <ATen/core/jit_type_base.h>
+ #include <c10/util/irange.h>
++#if defined(__APPLE__) && defined(__MACH__)
++#include <c10/util/variant.h>
++#endif
+ #include <pybind11/pybind11.h>
+ #include <pybind11/stl.h>
+ 
+@@ -324,6 +327,17 @@ struct type_caster<c10::complex<T>> {
+   }
+ };
+ 
++#if defined(__APPLE__) && defined(__MACH__)
++// Pybind11 bindings for our optional and variant types.
++// http://pybind11.readthedocs.io/en/stable/advanced/cast/stl.html#c-17-library-containers
++template <typename T>
++struct type_caster<c10::optional<T>> : optional_caster<c10::optional<T>> {};
++
++template <typename... Ts>
++struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
++    : variant_caster<c10::variant<Ts...>> {};
++#endif
++
+ } // namespace detail
+ } // namespace pybind11
+ 
+diff --git a/torch/library.h b/torch/library.h
+index e74b409bcc..8e584e6222 100644
+--- a/torch/library.h
++++ b/torch/library.h
+@@ -73,6 +73,7 @@
+ namespace std {
+   // Define is_nothrow_move_assignable_v for C++ versions before C++17 where it might not be available.
+   using ::c10::holds_alternative;
++  using ::c10::get;
+ }
+ #endif
+ 
+-- 
+2.17.2 (Apple Git-113)
+
+
+From c3959b7600acba1f44dac58c81691131877bc836 Mon Sep 17 00:00:00 2001
+From: Orlando Ding <xiandao.airs@gmail.com>
+Date: Mon, 26 Feb 2024 18:02:36 -0800
+Subject: [PATCH 8/8] orlando - for updates of support 2.2.0
+
+---
+ migration_note.md            | 17 ++++++++++++++++-
+ torch/csrc/utils/pybind.h    |  9 +++++----
+ torch/utils/cpp_extension.py |  2 +-
+ 3 files changed, 22 insertions(+), 6 deletions(-)
+
+diff --git a/migration_note.md b/migration_note.md
+index d26c6c2100..e847b0be6b 100644
+--- a/migration_note.md
++++ b/migration_note.md
+@@ -168,4 +168,19 @@ torch 2.0.0
+ 	/usr/lib/libc++.1.dylib (compatibility version 1.0.0, current version 400.9.4)
+ ```
+ 
+-change torch/csrc/utils/pybind.h with 
+\ No newline at end of file
++change torch/csrc/utils/pybind.h with cast_type.
++
++## 5. Building pytorch.vision 0.17.1
++
++Issue: not found  /usr/local/cuda/lib/libcudnn.a
++
++Try with the following solution:
++
++```bash
++sudo ln -s  /usr/local/torch/lib/libdnnl.a /usr/local/lib/libdnnl.a
++sudo ln -s  /usr/local/torch/lib/libc10_cuda.dylib /usr/local/lib/libc10_cuda.dylib
++sudo ln -s  /usr/local/torch/lib/libc10.dylib /usr/local/lib/libc10.dylib
++sudo ln -s  /usr/local/torch/lib/libtorch_cpu.dylib /usr/local/lib/libtorch_cpu.dylib
++sudo ln -s  /usr/local/torch/lib/libtorch_cuda.dylib  /usr/local/lib/libtorch_cuda.dylib
++sudo ln -s  /usr/local/torch/lib/libtorch.dylib  /usr/local/lib/libtorch.dylib
++```
+diff --git a/torch/csrc/utils/pybind.h b/torch/csrc/utils/pybind.h
+index 9dc45109d3..da7175bd4f 100644
+--- a/torch/csrc/utils/pybind.h
++++ b/torch/csrc/utils/pybind.h
+@@ -333,10 +333,11 @@ struct type_caster<c10::complex<T>> {
+ template <typename T>
+ struct type_caster<c10::optional<T>> : optional_caster<c10::optional<T>> {};
+ 
+-template <typename... Ts>
+-struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
+-    : variant_caster<c10::variant<Ts...>> {};
+-#endif
++//see: redefinition /Users/llv23/opt/miniconda3/lib/python3.10/site-packages/torch/include/pybind11/stl.h:441:8: note: previous definition is here
++// template <typename... Ts>
++// struct C10_MPARK_VISIBILITY_HIDDEN type_caster<c10::variant<Ts...>>
++//     : variant_caster<c10::variant<Ts...>> {};
++// #endif
+ 
+ } // namespace detail
+ } // namespace pybind11
+diff --git a/torch/utils/cpp_extension.py b/torch/utils/cpp_extension.py
+index b490d262a4..7feb1774aa 100644
+--- a/torch/utils/cpp_extension.py
++++ b/torch/utils/cpp_extension.py
+@@ -2312,7 +2312,7 @@ def _write_ninja_file(path,
+         
+     def replace_std17_with_std14(options):
+             options = [c for c in options if c != "-std=c++17"]
+-            if options.find("-std=c++14") == -1:
++            if "-std=c++14" not in options:
+                 options.append("-std=c++14")
+             return options
+ 
+-- 
+2.17.2 (Apple Git-113)
+
-- 
2.17.2 (Apple Git-113)


From 4916fabed96c4c2a75b11388ca1b2ca2f90575e9 Mon Sep 17 00:00:00 2001
From: Orlando Ding <xiandao.airs@gmail.com>
Date: Tue, 27 Feb 2024 21:29:33 -0800
Subject: [PATCH 14/14] orlando - for updates to v2.2.1

---
 CMakeLists.txt                                |  13 ++
 README.md                                     |  58 +++----
 cmake/Modules/FindMKLDNN.cmake                |   5 +-
 docs/source/community/contribution_guide.rst  |   2 +-
 docs/source/nn.rst                            |   3 +
 migration_note.md                             |  37 +++++
 .../_tensor/test_dtensor_compile.py           |  38 +++--
 test/distributed/_tensor/test_tensor_ops.py   |  36 +++-
 .../distributed/checkpoint/test_state_dict.py |  23 ++-
 .../fsdp/test_fsdp_freezing_weights.py        | 124 +++++++++++---
 .../fsdp/test_fsdp_hybrid_shard.py            |  57 ++-----
 .../fsdp/test_fsdp_tp_integration.py          | 156 +++++++++++++++++-
 .../fsdp/test_hsdp_dtensor_state_dict.py      |  22 +--
 test/distributed/test_dynamo_distributed.py   |  23 ++-
 test/lazy/test_meta_kernel.py                 |   4 +
 torch/__init__.py                             |   8 +-
 torch/_dynamo/trace_rules.py                  |   2 +-
 torch/_inductor/codecache.py                  |  15 ++
 torch/_inductor/kernel/mm.py                  |  12 +-
 .../csrc/distributed/c10d/TCPStoreBackend.cpp |   1 +
 torch/csrc/lazy/core/shape_inference.cpp      |   2 +-
 .../_shard/sharded_tensor/__init__.py         |  12 +-
 .../distributed/_shard/sharded_tensor/api.py  |   2 +-
 torch/distributed/_tensor/__init__.py         |  12 +-
 torch/distributed/_tensor/ops/tensor_ops.py   |  38 +++--
 .../checkpoint/_state_dict_utils.py           |  16 +-
 torch/distributed/checkpoint/state_dict.py    |  38 +++--
 torch/distributed/fsdp/_flat_param.py         |   7 +
 torch/distributed/fsdp/_init_utils.py         |  31 +++-
 torch/distributed/fsdp/_runtime_utils.py      |  39 +----
 .../fsdp/fully_sharded_data_parallel.py       |   2 +-
 .../tensor/parallel/_data_parallel_utils.py   |  35 +++-
 torch/distributed/tensor/parallel/fsdp.py     |  40 ++++-
 torch/distributed/tensor/parallel/style.py    |   2 +-
 torch/fx/passes/split_module.py               |  20 ++-
 .../_internal/common_dist_composable.py       |   3 +
 36 files changed, 685 insertions(+), 253 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index f6eed33502..ca3fe69f40 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -354,6 +354,9 @@ cmake_dependent_option(
     "NOT INTERN_BUILD_MOBILE" OFF)
 cmake_dependent_option(
     BUILD_FUNCTORCH "Build Functorch" ON "BUILD_PYTHON" OFF)
+# see: orlando upgrade to 2.2.1
+cmake_dependent_option(
+    BUILD_BUNDLE_PTXAS "Bundle PTX into torch/bin fodler" OFF "USE_CUDA" OFF)
 
 option(USE_MIMALLOC "Use mimalloc" OFF)
 # Enable third party mimalloc library to improve memory allocation performance on Windows.
@@ -1235,3 +1238,13 @@ if(DEFINED USE_CUSTOM_DEBINFO)
     set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -g")
     set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -g")
 endif()
+
+# see: orlando upgrade to 2.2.1
+# Bundle PTXAS if needed
+if(BUILD_BUNDLE_PTXAS AND USE_CUDA)
+   if(NOT EXISTS "${PROJECT_SOURCE_DIR}/build/bin/ptxas")
+     message(STATUS "Copying PTXAS into the bin folder")
+     file(COPY "${CUDAToolkit_BIN_DIR}/ptxas" DESTINATION "${PROJECT_BINARY_DIR}")
+   endif()
+   install(PROGRAMS "${PROJECT_BINARY_DIR}/ptxas" DESTINATION "${CMAKE_INSTALL_BINDIR}")
+endif()
\ No newline at end of file
diff --git a/README.md b/README.md
index 276d02ef5d..caed66655f 100644
--- a/README.md
+++ b/README.md
@@ -1,7 +1,8 @@
 <!-- markdownlint-disable MD033 -->
 <!-- markdownlint-disable MD004 -->
 <!-- markdownlint-disable MD029 -->
-# Pytorch 2.2.0 with Nvidia GPU on macOS
+# Pytorch 2.2.1 with Nvidia GPU on macOS
+
 --------------------------------------------------------------------------------
 [Features of pytorch 2.0](https://pytorch.org/blog/Accelerating-Hugging-Face-and-TIMM-models/) requires trions of [openAI triton](https://github.com/openai/triton), which needs NVIDIA GPUs (Compute Capability 7.0+, refer to https://developer.nvidia.com/cuda-gpus). In order to support the compilation via cuda, the hardware of eGPU needs to upgrade to 2080i +, like sales in [gaming box of 2080i](https://www.amazon.com/Embedded-Thunderbolt-Waterforce-Controller-Gv-N208TIXEB-11GC/dp/B07ZS9GZRY/ref=sr_1_5?crid=38RK3T5BAKIGN&keywords=gigabyte+gaming+box&qid=1679248280&s=pc&sprefix=gigabyte+gaming+box%2Ccomputers%2C147&sr=1-5). 
 
@@ -46,33 +47,34 @@ Our trunk health (Continuous Integration signals) can be found at [hud.pytorch.o
 
 <!-- toc -->
 
-- [More About PyTorch](#more-about-pytorch)
-  - [A GPU-Ready Tensor Library](#a-gpu-ready-tensor-library)
-  - [Dynamic Neural Networks: Tape-Based Autograd](#dynamic-neural-networks-tape-based-autograd)
-  - [Python First](#python-first)
-  - [Imperative Experiences](#imperative-experiences)
-  - [Fast and Lean](#fast-and-lean)
-  - [Extensions Without Pain](#extensions-without-pain)
-- [Installation](#installation)
-  - [Binaries](#binaries)
-    - [NVIDIA Jetson Platforms](#nvidia-jetson-platforms)
-  - [From Source](#from-source)
-    - [Prerequisites](#prerequisites)
-    - [Install Dependencies](#install-dependencies)
-    - [Get the PyTorch Source](#get-the-pytorch-source)
-    - [Install PyTorch](#install-pytorch)
-      - [Adjust Build Options (Optional)](#adjust-build-options-optional)
-  - [Docker Image](#docker-image)
-    - [Using pre-built images](#using-pre-built-images)
-    - [Building the image yourself](#building-the-image-yourself)
-  - [Building the Documentation](#building-the-documentation)
-  - [Previous Versions](#previous-versions)
-- [Getting Started](#getting-started)
-- [Resources](#resources)
-- [Communication](#communication)
-- [Releases and Contributing](#releases-and-contributing)
-- [The Team](#the-team)
-- [License](#license)
+- [Pytorch 2.2.1 with Nvidia GPU on macOS](#pytorch-221-with-nvidia-gpu-on-macos)
+  - [More About PyTorch](#more-about-pytorch)
+    - [A GPU-Ready Tensor Library](#a-gpu-ready-tensor-library)
+    - [Dynamic Neural Networks: Tape-Based Autograd](#dynamic-neural-networks-tape-based-autograd)
+    - [Python First](#python-first)
+    - [Imperative Experiences](#imperative-experiences)
+    - [Fast and Lean](#fast-and-lean)
+    - [Extensions Without Pain](#extensions-without-pain)
+  - [Installation](#installation)
+    - [Binaries](#binaries)
+      - [NVIDIA Jetson Platforms](#nvidia-jetson-platforms)
+    - [From Source](#from-source)
+      - [Prerequisites](#prerequisites)
+      - [Install Dependencies](#install-dependencies)
+      - [Get the PyTorch Source](#get-the-pytorch-source)
+      - [Install PyTorch](#install-pytorch)
+        - [Adjust Build Options (Optional)](#adjust-build-options-optional)
+    - [Docker Image](#docker-image)
+      - [Using pre-built images](#using-pre-built-images)
+      - [Building the image yourself](#building-the-image-yourself)
+    - [Building the Documentation](#building-the-documentation)
+    - [Previous Versions](#previous-versions)
+  - [Getting Started](#getting-started)
+  - [Resources](#resources)
+  - [Communication](#communication)
+  - [Releases and Contributing](#releases-and-contributing)
+  - [The Team](#the-team)
+  - [License](#license)
 
 <!-- tocstop -->
 
diff --git a/cmake/Modules/FindMKLDNN.cmake b/cmake/Modules/FindMKLDNN.cmake
index e62d86897f..da49ed58fe 100644
--- a/cmake/Modules/FindMKLDNN.cmake
+++ b/cmake/Modules/FindMKLDNN.cmake
@@ -88,7 +88,10 @@ IF(NOT MKLDNN_FOUND)
   ELSE()
     IF(CMAKE_CXX_COMPILER_ID STREQUAL "GNU" OR CMAKE_CXX_COMPILER_ID STREQUAL "Clang")
       IF(CPU_INTEL)
-        SET(DNNL_ARCH_OPT_FLAGS "-msse4" CACHE STRING "" FORCE)
+      # see: orlando upgrade to 2.2.1
+        # SET(DNNL_ARCH_OPT_FLAGS "-msse4" CACHE STRING "" FORCE)
+        # Do not specify arch in oneDNN build option, for the portability in older systems
+        SET(DNNL_ARCH_OPT_FLAGS "" CACHE STRING "" FORCE)
       ELSEIF(CPU_AARCH64)
         SET(DNNL_ARCH_OPT_FLAGS "-mcpu=generic" CACHE STRING "" FORCE)
       ENDIF()
diff --git a/docs/source/community/contribution_guide.rst b/docs/source/community/contribution_guide.rst
index c6ec6d75e4..ab6fb13da7 100644
--- a/docs/source/community/contribution_guide.rst
+++ b/docs/source/community/contribution_guide.rst
@@ -303,7 +303,7 @@ Frequently Asked Questions
    tasks or pull requests with your environment details is helpful and
    appreciated.
 -  **CI tests failed, what does it mean?** Maybe your PR is based
-   off a broken main bracnh? You can try to rebase your change on top
+   off a broken main branch? You can try to rebase your change on top
    of the latest main branch. You can also see the current status of
    main branch's CI at https://hud.pytorch.org/.
 -  **What are the most high risk changes?** Anything that touches build
diff --git a/docs/source/nn.rst b/docs/source/nn.rst
index 3978cb287f..7c921b3dff 100644
--- a/docs/source/nn.rst
+++ b/docs/source/nn.rst
@@ -130,6 +130,9 @@ Padding Layers
     nn.ConstantPad1d
     nn.ConstantPad2d
     nn.ConstantPad3d
+    nn.CircularPad1d
+    nn.CircularPad2d
+    nn.CircularPad3d
 
 Non-linear Activations (weighted sum, nonlinearity)
 ---------------------------------------------------
diff --git a/migration_note.md b/migration_note.md
index e847b0be6b..03658583ab 100644
--- a/migration_note.md
+++ b/migration_note.md
@@ -184,3 +184,40 @@ sudo ln -s  /usr/local/torch/lib/libtorch_cpu.dylib /usr/local/lib/libtorch_cpu.
 sudo ln -s  /usr/local/torch/lib/libtorch_cuda.dylib  /usr/local/lib/libtorch_cuda.dylib
 sudo ln -s  /usr/local/torch/lib/libtorch.dylib  /usr/local/lib/libtorch.dylib
 ```
+
+## 6, Upgrade from v2.2.0 to v2.2.1
+
+1. CMakeLists.txt
+2. cmake/Modules/FindMKLDNN.cmake
+3. torch/__init__.py
+4. torch/_dynamo/trace_rules.py
+5. torch/_inductor/codecache.py
+6. torch/_inductor/kernel/mm.py
+7. torch/csrc/distributed/c10d/TCPStoreBackend.cpp
+8. torch/csrc/lazy/core/shape_inference.cpp
+9. torch/distributed/_shard/sharded_tensor/__init__.py
+10. torch/distributed/_shard/sharded_tensor/api.py
+11. torch/distributed/_tensor/__init__.py
+12. torch/distributed/_tensor/ops/tensor_ops.py
+13. torch/distributed/checkpoint/_state_dict_utils.py
+14. torch/distributed/checkpoint/state_dict.py
+15. torch/distributed/fsdp/_flat_param.py
+16. torch/distributed/fsdp/_init_utils.py
+17. torch/distributed/fsdp/_runtime_utils.py
+18. torch/distributed/fsdp/fully_sharded_data_parallel.py
+19. torch/distributed/tensor/parallel/_data_parallel_utils.py
+20. torch/distributed/tensor/parallel/fsdp.py
+21. torch/distributed/tensor/parallel/style.py
+22. torch/fx/passes/split_module.py
+23. torch/testing/_internal/common_dist_composable.py
+24. docs/source/community/contribution_guide.rst
+25. docs/source/nn.rst
+26. test/distributed/_tensor/test_dtensor_compile.py
+27. test/distributed/_tensor/test_tensor_ops.py
+28. test/distributed/checkpoint/test_state_dict.py
+29. test/distributed/fsdp/test_fsdp_freezing_weights.py
+30. test/distributed/fsdp/test_fsdp_hybrid_shard.py
+31. test/distributed/fsdp/test_fsdp_tp_integration.py
+32. test/distributed/fsdp/test_hsdp_dtensor_state_dict.py
+33. test/distributed/test_dynamo_distributed.py
+34. test/lazy/test_meta_kernel.py
\ No newline at end of file
diff --git a/test/distributed/_tensor/test_dtensor_compile.py b/test/distributed/_tensor/test_dtensor_compile.py
index dc85c30498..7f622aa8e0 100644
--- a/test/distributed/_tensor/test_dtensor_compile.py
+++ b/test/distributed/_tensor/test_dtensor_compile.py
@@ -8,6 +8,7 @@ from unittest.mock import patch
 
 import torch
 import torch._dynamo
+import torch._dynamo.testing
 import torch.distributed as dist
 import torch.nn as nn
 from torch._C import FileCheck
@@ -145,11 +146,16 @@ class TestDTensorCompile(torch._dynamo.test_case.TestCase):
         # _dt_lib_impl = torch.library.Library("dtensor", "IMPL")
         # _dt_lib_impl.impl("from_local", from_local_tensor, "Autograd")
 
-        x = torch.ones(1)
+        x = torch.ones(1, requires_grad=True)
         ref = fn(x)
-        opt_fn = torch.compile(fn, backend="aot_eager", fullgraph=True, dynamic=False)
+        cnt = torch._dynamo.testing.CompileCounterWithBackend("aot_eager")
+        opt_fn = torch.compile(fn, backend=cnt, fullgraph=True)
         res = opt_fn(x)
+        # backward should work as well
+        res.sum().backward()
+
         self.assertEqual(res, ref)
+        self.assertEqual(cnt.frame_count, 1)
 
         # test if user calls from_local with mesh/placements as kwargs and that should still work
         def from_local_kwargs_fn(x):
@@ -159,11 +165,10 @@ class TestDTensorCompile(torch._dynamo.test_case.TestCase):
             return dt.to_local() + 2
 
         ref = from_local_kwargs_fn(x)
-        opt_kwargs_fn = torch.compile(
-            from_local_kwargs_fn, backend="aot_eager", fullgraph=True, dynamic=False
-        )
+        opt_kwargs_fn = torch.compile(from_local_kwargs_fn, backend=cnt, fullgraph=True)
         res = opt_kwargs_fn(x)
         self.assertEqual(res, ref)
+        self.assertEqual(cnt.frame_count, 2)
 
     def test_dynamo_dtensor_from_local_redistribute(self):
         mesh = DeviceMesh(self.device_type, torch.arange(self.world_size))
@@ -176,7 +181,8 @@ class TestDTensorCompile(torch._dynamo.test_case.TestCase):
 
         x = torch.ones(1)
         ref = fn(x)
-        opt_fn = torch.compile(fn, backend="aot_eager", fullgraph=True, dynamic=False)
+        cnt = torch._dynamo.testing.CompileCounterWithBackend("aot_eager")
+        opt_fn = torch.compile(fn, backend=cnt, fullgraph=True)
         res = opt_fn(x)
         self.assertEqual(res, ref)
 
@@ -190,7 +196,7 @@ class TestDTensorCompile(torch._dynamo.test_case.TestCase):
         x = torch.ones(1)
         ref = redistribute_kwargs_fn(x)
         opt_kwargs_fn = torch.compile(
-            redistribute_kwargs_fn, backend="aot_eager", fullgraph=True, dynamic=False
+            redistribute_kwargs_fn, backend=cnt, fullgraph=True
         )
         res = opt_kwargs_fn(x)
         self.assertEqual(res, ref)
@@ -254,9 +260,12 @@ class TestDTensorCompile(torch._dynamo.test_case.TestCase):
             parallelize_plan=parallel_plan,
         )
 
-        compiled_model = torch.compile(model)
+        cnt = torch._dynamo.testing.CompileCounterWithBackend("inductor")
+        compiled_model = torch.compile(model, backend=cnt, fullgraph=True)
         inp = torch.rand(20, 16).to(self.device_type)
         out = compiled_model(inp)
+        out.sum().backward()
+        self.assertEqual(cnt.frame_count, 1)
 
         code = run_and_get_triton_code(compiled_model, inp)
         # Check that `buf2` is correctly waited on before first use.
@@ -327,11 +336,12 @@ class TestDTensorCompileE2E(DTensorTestBase):
         torch.manual_seed(rng_seed)
         inp = torch.rand(20, 10, device=self.device_type)
         out = model(inp)
-        compiled_mod = torch.compile(
-            model, backend="aot_eager", fullgraph=True, dynamic=False
-        )
+        cnt = torch._dynamo.testing.CompileCounterWithBackend("aot_eager")
+        compiled_mod = torch.compile(model, backend=cnt, fullgraph=True)
         compiled_out = compiled_mod(inp)
+        compiled_out.sum().backward()
         self.assertEqual(compiled_out, out)
+        self.assertEqual(cnt.frame_count, 1)
 
     @with_comms
     @skip_if_lt_x_gpu(4)
@@ -377,10 +387,12 @@ class TestDTensorCompileE2E(DTensorTestBase):
         )
 
         # TODO: once aot autograd support is ready we can just use default backend
-        compiled_2d = torch.compile(fsdp_2d, backend="aot_eager", dynamic=False)
+        cnt = torch._dynamo.testing.CompileCounterWithBackend("aot_eager")
+        compiled_2d = torch.compile(fsdp_2d, backend=cnt)
         compiled_output = compiled_2d(inp)
 
         self.assertEqual(out, compiled_output)
+        self.assertEqual(cnt.frame_count, 1)
 
     @with_comms
     @skip_if_lt_x_gpu(4)
@@ -470,4 +482,4 @@ class TestDTensorCompileE2E(DTensorTestBase):
 instantiate_parametrized_tests(TestDTensorCompileE2E)
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/_tensor/test_tensor_ops.py b/test/distributed/_tensor/test_tensor_ops.py
index f745dbd555..f26e65226a 100644
--- a/test/distributed/_tensor/test_tensor_ops.py
+++ b/test/distributed/_tensor/test_tensor_ops.py
@@ -399,6 +399,40 @@ class DistTensorOpsTest(DTensorTestBase):
             ref = torch.where(global_tensor > 0, 1, 0)
             self.assertEqual(res.full_tensor(), ref)
 
+    @with_comms
+    def test_dtensor_dtype_conversion(self):
+        device_mesh = DeviceMesh(self.device_type, list(range(self.world_size)))
+        shard_spec = [Shard(0)]
+        # by default we start from bf16 dtype
+        local_tenor = torch.randn(2, 8, dtype=torch.bfloat16)
+        bf16_sharded_dtensor = DTensor.from_local(local_tenor, device_mesh, shard_spec)
+        self.assertEqual(bf16_sharded_dtensor.dtype, torch.bfloat16)
+        self.assertEqual(bf16_sharded_dtensor.to_local().dtype, torch.bfloat16)
+
+        # convert to float dtype
+        fp32_sharded_dtensor = bf16_sharded_dtensor.float()
+        self.assertEqual(fp32_sharded_dtensor.dtype, torch.float32)
+        self.assertEqual(fp32_sharded_dtensor.to_local().dtype, torch.float32)
+
+        # convert back to bf16 dtype
+        bf16_sharded_dtensor1 = fp32_sharded_dtensor.type_as(bf16_sharded_dtensor)
+        self.assertEqual(bf16_sharded_dtensor1.dtype, torch.bfloat16)
+        self.assertEqual(bf16_sharded_dtensor1.to_local().dtype, torch.bfloat16)
+
+        from torch.distributed._tensor.debug import get_sharding_prop_cache_info
+
+        # by this point we only have cache misses
+        hits, misses, _, _ = get_sharding_prop_cache_info()
+        self.assertEqual(hits, 0)
+        self.assertEqual(misses, 2)
+
+        # convert to fp32 again and see if there's cache hit
+        fp32_sharded_dtensor1 = bf16_sharded_dtensor1.float()
+        hits, misses, _, _ = get_sharding_prop_cache_info()
+        # by now we should have cache hit
+        self.assertEqual(hits, 1)
+        self.assertEqual(misses, 2)
+
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/checkpoint/test_state_dict.py b/test/distributed/checkpoint/test_state_dict.py
index b2dca7777e..bff883b981 100644
--- a/test/distributed/checkpoint/test_state_dict.py
+++ b/test/distributed/checkpoint/test_state_dict.py
@@ -3,10 +3,11 @@
 import copy
 import sys
 from itertools import chain
-from typing import Callable
+from typing import Callable, Tuple
 
 import torch
 import torch.distributed as dist
+import torch.nn as nn
 from torch.distributed._composable import fully_shard, replicate
 from torch.distributed._shard.sharded_tensor import ShardedTensor
 from torch.distributed._tensor import DTensor, init_device_mesh
@@ -133,7 +134,12 @@ class TestStateDict(DTensorTestBase, VerifyStateDictMixin):
         self._verify_osd(model, optim, osd, dist_osd)
 
     def _test_fsdp(
-        self, use_orig_params: bool, use_composable: bool, use_dtensor: bool
+        self,
+        *,
+        use_orig_params: bool,
+        use_composable: bool,
+        use_dtensor: bool,
+        wrapping: Tuple[nn.Module] = (),
     ) -> None:
         if not use_orig_params and use_composable:
             return
@@ -149,23 +155,27 @@ class TestStateDict(DTensorTestBase, VerifyStateDictMixin):
             orig_model = CompositeParamModel(device=torch.device("cuda"))
             orig_optim = torch.optim.Adam(orig_model.parameters(), lr=1e-3)
             copy_optim = torch.optim.Adam(orig_model.parameters(), lr=1e-3)
+            if wrapping:
+                strategy = set(wrapping)
+            else:
+                strategy = {UnitModule}
             if use_composable:
                 dist_model = fully_shard(
-                    copy.deepcopy(orig_model), policy=ModuleWrapPolicy({UnitModule})
+                    copy.deepcopy(orig_model), policy=ModuleWrapPolicy(strategy)
                 )
             else:
                 if use_dtensor:
                     device_mesh = init_device_mesh("cuda", (self.world_size,))
                     dist_model = FSDP(
                         copy.deepcopy(orig_model),
-                        auto_wrap_policy=ModuleWrapPolicy({UnitModule}),
+                        auto_wrap_policy=ModuleWrapPolicy(strategy),
                         use_orig_params=use_orig_params,
                         device_mesh=device_mesh,
                     )
                 else:
                     dist_model = FSDP(
                         copy.deepcopy(orig_model),
-                        auto_wrap_policy=ModuleWrapPolicy({UnitModule}),
+                        auto_wrap_policy=ModuleWrapPolicy(strategy),
                         use_orig_params=use_orig_params,
                     )
 
@@ -182,6 +192,7 @@ class TestStateDict(DTensorTestBase, VerifyStateDictMixin):
                 "use_orig_params": [True, False],
                 "use_composable": [True, False],
                 "use_dtensor": [True, False],
+                "wrapping": [tuple(), (nn.Linear, UnitModule)],
             },
             self._test_fsdp,
         )
@@ -434,4 +445,4 @@ class TestStateDict(DTensorTestBase, VerifyStateDictMixin):
 
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/fsdp/test_fsdp_freezing_weights.py b/test/distributed/fsdp/test_fsdp_freezing_weights.py
index 90c96135e8..2d081195c4 100644
--- a/test/distributed/fsdp/test_fsdp_freezing_weights.py
+++ b/test/distributed/fsdp/test_fsdp_freezing_weights.py
@@ -1,5 +1,6 @@
 # Owner(s): ["oncall: distributed"]
 
+import contextlib
 import sys
 from enum import Enum
 
@@ -31,7 +32,13 @@ if TEST_WITH_DEV_DBG_ASAN:
 
 
 class Model(nn.Module):
-    def __init__(self, with_fsdp, freeze_after_wrap_fsdp):
+    def __init__(
+        self,
+        with_fsdp,
+        freeze_after_wrap_fsdp,
+        disable_autograd,
+        fsdp_kwargs,
+    ):
         super().__init__()
         self.trunk = nn.Sequential(
             nn.Conv2d(3, 64, kernel_size=3),
@@ -39,20 +46,32 @@ class Model(nn.Module):
             nn.AdaptiveAvgPool2d(output_size=(1, 1)),
             nn.Flatten(),
         )
+        self.device = torch.cuda.current_device()
         self.head = nn.Linear(64, 10)
         if with_fsdp and freeze_after_wrap_fsdp:
-            self.fsdp_wrap()
+            self.fsdp_wrap(fsdp_kwargs)
+        self.autograd_ctx = (
+            torch.no_grad if disable_autograd else contextlib.nullcontext
+        )
 
-    def fsdp_wrap(self):
-        self.trunk = FSDP(self.trunk)
-        self.head = FSDP(self.head)
+    def fsdp_wrap(self, fsdp_kwargs):
+        self.trunk = FSDP(self.trunk, **fsdp_kwargs)
+        self.head = FSDP(self.head, **fsdp_kwargs)
 
     def forward(self, x):
-        return self.head(self.trunk(x))
+        with self.autograd_ctx():
+            x = self.trunk(x)
+        return self.head(x)
 
 
 class NestedTrunkModel(nn.Module):
-    def __init__(self, with_fsdp, freeze_after_wrap_fsdp):
+    def __init__(
+        self,
+        with_fsdp,
+        freeze_after_wrap_fsdp,
+        disable_autograd,
+        fsdp_kwargs,
+    ):
         super().__init__()
         self.trunk = nn.Sequential(
             self._create_block(3, 64, with_fsdp, freeze_after_wrap_fsdp),
@@ -64,17 +83,22 @@ class NestedTrunkModel(nn.Module):
             nn.Linear(64, 10),
         )
         if with_fsdp and freeze_after_wrap_fsdp:
-            self.fsdp_wrap()
+            self.fsdp_wrap(fsdp_kwargs)
+        self.autograd_ctx = (
+            torch.no_grad if disable_autograd else contextlib.nullcontext
+        )
 
-    def fsdp_wrap(self):
+    def fsdp_wrap(self, fsdp_kwargs):
         for name, child in self.trunk.named_children():
-            wrapped_child = FSDP(child)
+            wrapped_child = FSDP(child, **fsdp_kwargs)
             setattr(self.trunk, name, wrapped_child)
-        self.trunk = FSDP(self.trunk)
-        self.head = FSDP(self.head)
+        self.trunk = FSDP(self.trunk, **fsdp_kwargs)
+        self.head = FSDP(self.head, **fsdp_kwargs)
 
     def forward(self, x):
-        return self.head(self.trunk(x))
+        with self.autograd_ctx():
+            x = self.trunk(x)
+        return self.head(x)
 
     def _create_block(
         self, in_channels, out_channels, with_fsdp, freeze_after_wrap_fsdp
@@ -92,20 +116,53 @@ class FreezingMethod(str, Enum):
 
 
 class TestFreezingWeights(FSDPTest):
-    def _create_model(self, with_fsdp, with_nested_trunk, freeze_after_wrap_fsdp):
+    def _create_model(
+        self,
+        with_fsdp,
+        with_nested_trunk,
+        freeze_after_wrap_fsdp,
+        disable_autograd,
+        fsdp_kwargs,
+    ):
         if with_nested_trunk:
-            model = NestedTrunkModel(with_fsdp, freeze_after_wrap_fsdp)
+            model = NestedTrunkModel(
+                with_fsdp, freeze_after_wrap_fsdp, disable_autograd, fsdp_kwargs
+            )
         else:
-            model = Model(with_fsdp, freeze_after_wrap_fsdp)
+            model = Model(
+                with_fsdp, freeze_after_wrap_fsdp, disable_autograd, fsdp_kwargs
+            )
         return model
 
     def _dist_train(
-        self, with_nested_trunk, freezing_method, freeze_after_wrap_fsdp, with_fsdp
+        self,
+        with_nested_trunk,
+        freezing_method,
+        freeze_after_wrap_fsdp,
+        with_fsdp,
+        disable_autograd,
+        forward_prefetch,
     ):
         torch.manual_seed(0)
         batch = torch.randn(size=(2, 3, 224, 224)).cuda()
 
-        model = self._create_model(with_fsdp, with_nested_trunk, freeze_after_wrap_fsdp)
+        fsdp_kwargs = {
+            "device_id": self.rank,
+            "forward_prefetch": forward_prefetch,
+        }
+
+        ddp_kwargs = {
+            "device_ids": [self.rank],
+            "find_unused_parameters": True if disable_autograd else False,
+        }
+
+        model = self._create_model(
+            with_fsdp,
+            with_nested_trunk,
+            freeze_after_wrap_fsdp,
+            disable_autograd,
+            fsdp_kwargs,
+        )
         model = model.cuda()
 
         # freezing the trunk using requires_grad.
@@ -115,10 +172,10 @@ class TestFreezingWeights(FSDPTest):
 
         if with_fsdp:
             if not freeze_after_wrap_fsdp:
-                model.fsdp_wrap()
-            model = FSDP(model)
+                model.fsdp_wrap(fsdp_kwargs)
+            model = FSDP(model, **fsdp_kwargs)
         else:
-            model = DistributedDataParallel(model, device_ids=[self.rank])
+            model = DistributedDataParallel(model, **ddp_kwargs)
 
         target = torch.tensor([0, 1], dtype=torch.long).cuda()
         criterion = nn.CrossEntropyLoss()
@@ -145,17 +202,34 @@ class TestFreezingWeights(FSDPTest):
         "freezing_method", [FreezingMethod.RequiresGrad, FreezingMethod.GradToNone]
     )
     @parametrize("freeze_after_wrap_fsdp", [True, False])
+    @parametrize("disable_autograd", [True, False])
+    @parametrize("forward_prefetch", [True, False])
     def test_freezing_weights(
-        self, with_nested_trunk, freezing_method, freeze_after_wrap_fsdp
+        self,
+        with_nested_trunk,
+        freezing_method,
+        freeze_after_wrap_fsdp,
+        disable_autograd,
+        forward_prefetch,
     ):
         # DDP
         ddp_state = self._dist_train(
-            with_nested_trunk, freezing_method, freeze_after_wrap_fsdp, with_fsdp=False
+            with_nested_trunk,
+            freezing_method,
+            freeze_after_wrap_fsdp,
+            with_fsdp=False,
+            disable_autograd=disable_autograd,
+            forward_prefetch=False,  # does not apply to DDP
         )
 
         # FSDP
         fsdp_state = self._dist_train(
-            with_nested_trunk, freezing_method, freeze_after_wrap_fsdp, with_fsdp=True
+            with_nested_trunk,
+            freezing_method,
+            freeze_after_wrap_fsdp,
+            with_fsdp=True,
+            disable_autograd=disable_autograd,
+            forward_prefetch=forward_prefetch,
         )
 
         self.assertEqual(
@@ -173,4 +247,4 @@ class TestFreezingWeights(FSDPTest):
 instantiate_parametrized_tests(TestFreezingWeights)
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/fsdp/test_fsdp_hybrid_shard.py b/test/distributed/fsdp/test_fsdp_hybrid_shard.py
index f0bb99b5a4..cf0efa71a2 100644
--- a/test/distributed/fsdp/test_fsdp_hybrid_shard.py
+++ b/test/distributed/fsdp/test_fsdp_hybrid_shard.py
@@ -11,6 +11,7 @@ import torch
 import torch.distributed as dist
 import torch.distributed.fsdp._traversal_utils as traversal_utils
 import torch.nn as nn
+from torch.distributed.device_mesh import init_device_mesh
 from torch.distributed.distributed_c10d import _rank_not_in_group
 from torch.distributed.fsdp import (
     FullyShardedDataParallel as FSDP,
@@ -116,46 +117,6 @@ class TestFSDPHybridShard(FSDPTest):
         with err_ctx:
             model = FSDP(model, sharding_strategy=ShardingStrategy._HYBRID_SHARD_ZERO2)
 
-    @skip_if_lt_x_gpu(2)
-    def test_hybrid_shard_pg_mismatch_raises(self):
-        model = MyModel().cuda()
-        intra_pg = self.process_group
-        inter_pg = dist.new_group(ranks=[self.rank])
-        # Mismatched process groups for intra-node
-        model.lin1 = FSDP(
-            model.lin1,
-            process_group=(intra_pg, inter_pg),
-            sharding_strategy=ShardingStrategy.HYBRID_SHARD,
-        )
-        model = FSDP(
-            model,
-            process_group=(dist.new_group(), dist.new_group()),
-            sharding_strategy=ShardingStrategy.HYBRID_SHARD,
-        )
-        # Errors during _lazy_init
-        inp = torch.randn(4, 10)
-        with self.assertRaisesRegex(
-            ValueError, "intra-node process groups do not match"
-        ):
-            model(inp)
-
-        # Mismatched process groups for inter-node
-        model = MyModel().cuda()
-        model.lin1 = FSDP(
-            model.lin1,
-            process_group=(intra_pg, inter_pg),
-            sharding_strategy=ShardingStrategy.HYBRID_SHARD,
-        )
-        model = FSDP(
-            model,
-            process_group=(intra_pg, dist.new_group()),
-            sharding_strategy=ShardingStrategy.HYBRID_SHARD,
-        )
-        with self.assertRaisesRegex(
-            ValueError, "inter-node process groups do not match"
-        ):
-            model(inp)
-
     @skip_if_lt_x_gpu(4)
     def test_hsdp_save_load_state_dict(self):
         model = MyModel().cuda()
@@ -284,6 +245,7 @@ class TestFSDPHybridShard(FSDPTest):
                     ShardingStrategyMode.MIXED_HYBRID_FULL_SHARD,
                 ],
                 "use_orig_params": [False, True],
+                "use_device_mesh": [False, True],
             },
             self._test_fsdp_hybrid_shard_basic_setup,
         )
@@ -293,9 +255,17 @@ class TestFSDPHybridShard(FSDPTest):
         hsdp_sharding_strategy: ShardingStrategy,
         sharding_strategy_mode: ShardingStrategyMode,
         use_orig_params: bool,
+        use_device_mesh: bool,
     ):
+        if use_device_mesh:
+            device_mesh = init_device_mesh("cuda", (1, self.world_size))
+        else:
+            device_mesh = None
         hsdp_model = self._init_hsdp_model(
-            hsdp_sharding_strategy, sharding_strategy_mode, use_orig_params
+            hsdp_sharding_strategy,
+            sharding_strategy_mode,
+            use_orig_params,
+            hsdp_device_mesh=device_mesh,
         )
         # All FSDP modules should have state.process_group as the process group over which to
         # shard (default process group), and state._inter_node_pg (process group containing only
@@ -428,7 +398,9 @@ class TestFSDPHybridShard(FSDPTest):
         hsdp_process_groups: Optional[
             Tuple[dist.ProcessGroup, dist.ProcessGroup]
         ] = None,
+        hsdp_device_mesh: Optional = None,
     ):
+        assert hsdp_process_groups is None or hsdp_device_mesh is None
         auto_wrap_policy = ModuleWrapPolicy(
             {TransformerEncoderLayer, TransformerDecoderLayer},
         )
@@ -437,6 +409,7 @@ class TestFSDPHybridShard(FSDPTest):
             "auto_wrap_policy": auto_wrap_policy,
             "sharding_strategy": hsdp_sharding_strategy,
             "use_orig_params": use_orig_params,
+            "device_mesh": hsdp_device_mesh,
         }
         if sharding_strategy_mode == ShardingStrategyMode.ALL_HYBRID_SHARD:
             hsdp_model = TransformerWithSharedParams.init(
@@ -469,4 +442,4 @@ class TestFSDPHybridShard(FSDPTest):
 instantiate_parametrized_tests(TestFSDPHybridShard)
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/fsdp/test_fsdp_tp_integration.py b/test/distributed/fsdp/test_fsdp_tp_integration.py
index c14b4be2ac..b24c57b37e 100644
--- a/test/distributed/fsdp/test_fsdp_tp_integration.py
+++ b/test/distributed/fsdp/test_fsdp_tp_integration.py
@@ -8,7 +8,15 @@ import torch
 from torch import distributed as dist
 from torch.distributed._shard.sharded_tensor.api import ShardedTensor
 from torch.distributed._shard.sharding_spec import ChunkShardingSpec
-from torch.distributed._tensor import DeviceMesh, DTensor as DT, init_device_mesh, Shard
+from torch.distributed._tensor import (
+    DeviceMesh,
+    distribute_module,
+    DTensor,
+    init_device_mesh,
+    Replicate,
+    Shard,
+)
+from torch.distributed._tensor.debug import CommDebugMode
 from torch.distributed.fsdp.fully_sharded_data_parallel import (
     CPUOffload,
     FullyShardedDataParallel as FSDP,
@@ -26,6 +34,7 @@ from torch.testing._internal.common_utils import (
     run_tests,
     TEST_WITH_DEV_DBG_ASAN,
 )
+from torch.testing._internal.distributed._tensor.common_dtensor import MLPModule
 
 if not dist.is_available():
     print("Distributed not available, skipping tests", file=sys.stderr)
@@ -68,6 +77,34 @@ class SimpleModel(torch.nn.Module):
         return ["net3.weight", "net3.bias"]
 
 
+# simple RMSNorm layer for testing
+class RMSNormPython(torch.nn.Module):
+    def __init__(self, dim: int, eps: float = 1e-6):
+        super().__init__()
+        self.eps = eps
+        self.weight = torch.nn.Parameter(torch.ones(dim))
+
+    def _norm(self, x):
+        return x * torch.rsqrt(x.pow(2).mean(-1, keepdim=True) + self.eps)
+
+    def forward(self, x):
+        output = self._norm(x)
+        return output * self.weight
+
+
+def distribute_rmsnorm(module, device_mesh):
+    def prepare_input_fn(inputs, device_mesh):
+        shard_tensor = DTensor.from_local(inputs[0], device_mesh, [Shard(0)])
+        return shard_tensor
+
+    def prepare_output_fn(outputs, device_mesh):
+        return outputs.to_local()
+
+    return distribute_module(
+        module, device_mesh, input_fn=prepare_input_fn, output_fn=prepare_output_fn
+    )
+
+
 class TestTPFSDPIntegration(FSDPTest):
     def _get_params_and_sharding_info(
         self,
@@ -260,8 +297,8 @@ class TestTPFSDPIntegration(FSDPTest):
             sequence_parallelize_plan,
         )
         tp_pg = mesh_2d["tp"].get_group(mesh_dim=0)
-        assert isinstance(tp_fsdp_model.net1.weight, DT)
-        assert isinstance(tp_fsdp_model.net2.weight, DT)
+        assert isinstance(tp_fsdp_model.net1.weight, DTensor)
+        assert isinstance(tp_fsdp_model.net2.weight, DTensor)
         tp_fsdp_model = FSDP(
             tp_fsdp_model,
             cpu_offload=cpu_offload,
@@ -314,8 +351,119 @@ class TestTPFSDPIntegration(FSDPTest):
         tp_fsdp_out = tp_fsdp_model(inp)
         self.assertEqual(fsdp_out, tp_fsdp_out)
 
+    @skip_if_lt_x_gpu(4)
+    def test_fsdp_tp_extension_grad(self):
+        """
+        Tests TP + FSDP extension with correct gradient (i.e. no ACT)
+        """
+        mesh_2d = init_device_mesh(
+            "cuda", (self.world_size // 2, 2), mesh_dim_names=["dp", "tp"]
+        )
+
+        class TestModel(torch.nn.Module):
+            def __init__(self):
+                super().__init__()
+                self.mlp = MLPModule("cuda")
+                self.mlp_norm = RMSNormPython(10)
+
+            def forward(self, x):
+                return self.mlp(self.mlp_norm(x))
+
+        model = TestModel().cuda(self.rank)
+
+        # Shard with TP and test gradient
+        tp_mesh = mesh_2d["tp"]
+        tp_model = parallelize_module(
+            model,
+            tp_mesh,
+            {
+                "mlp.net1": ColwiseParallel(input_layouts=Shard(0)),
+                "mlp.net2": RowwiseParallel(output_layouts=Shard(0)),
+            },
+        )
+        distribute_rmsnorm(tp_model.mlp_norm, tp_mesh)
+
+        fsdp_2d_model = FSDP(tp_model, device_mesh=mesh_2d["dp"])
+        comm_mode = CommDebugMode()
+
+        with comm_mode:
+            fsdp_2d_model(torch.rand(2, 10).cuda(self.rank)).sum().backward()
+
+        funcol = torch.ops.c10d_functional
+        comm_counts = comm_mode.get_comm_counts()
+        self.assertEqual(comm_mode.get_total_counts(), 5)
+        self.assertEqual(comm_counts[funcol.reduce_scatter_tensor], 2)
+        self.assertEqual(comm_counts[funcol.all_gather_into_tensor], 2)
+        self.assertEqual(comm_counts[funcol.all_reduce], 1)
+
+        grads = [p.grad for p in fsdp_2d_model.parameters() if p.grad is not None]
+
+        for grad in grads:
+            self.assertFalse(grad.isnan().any().item())
+
+    @skip_if_lt_x_gpu(4)
+    def test_fsdp_tp_sync_module_state(self):
+        mesh_2d = init_device_mesh(
+            "cuda", (self.world_size // 2, 2), mesh_dim_names=["dp", "tp"]
+        )
+        tp_mesh = mesh_2d["tp"]
+        dp_mesh = mesh_2d["dp"]
+
+        # set random seed for each rank
+        torch.manual_seed(mesh_2d.get_rank())
+
+        class TestModel(torch.nn.Module):
+            def __init__(self):
+                super().__init__()
+                replicated_dt = DTensor.from_local(
+                    torch.randn(8, 8), tp_mesh, [Replicate()], run_check=False
+                )
+                replicated_buffer_dt = DTensor.from_local(
+                    torch.randn(8, 8), tp_mesh, [Replicate()], run_check=False
+                )
+                self.param = torch.nn.Parameter(replicated_dt)
+                self.register_buffer("buf", replicated_buffer_dt)
+
+            def forward(self, x):
+                return self.param + self.buffer + 1
+
+        model = TestModel()
+
+        def assert_local_shard_across_ranks(local_tensor, group, check_equal=True):
+            gathered_tensors = [
+                torch.empty_like(local_tensor) for _ in range(group.size())
+            ]
+            dist.all_gather(gathered_tensors, local_tensor, group=group)
+            # on dp mesh dim local tensor does not equal
+            tensor_to_compare = gathered_tensors[0]
+            for tensor in gathered_tensors[1:]:
+                if check_equal:
+                    self.assertTrue(torch.equal(tensor, tensor_to_compare))
+                else:
+                    self.assertFalse(torch.equal(tensor, tensor_to_compare))
+
+        dp_group = dp_mesh.get_group()
+
+        # check on dp mesh dim param local tensor does not equal
+        local_param = model.param.to_local()
+        assert_local_shard_across_ranks(local_param, dp_group, check_equal=False)
+        # check on dp mesh dim buffer local tensor does not equal
+        local_buf = model.buf.to_local()
+        assert_local_shard_across_ranks(local_buf, dp_group, check_equal=False)
+
+        # wrap with fsdp sync param should sync dp mesh dim
+        fsdp_mod = FSDP(model, device_mesh=dp_mesh, sync_module_states=True)
+        with fsdp_mod.summon_full_params(fsdp_mod):
+            # on dp mesh dim local param does equal after sync_module_states
+            local_param = fsdp_mod.param.to_local()
+            assert_local_shard_across_ranks(local_param, dp_group, check_equal=True)
+
+            # on dp mesh dim local buf does equal after sync_module_states
+            local_buf = fsdp_mod.buf.to_local()
+            assert_local_shard_across_ranks(local_buf, dp_group, check_equal=True)
+
 
 instantiate_parametrized_tests(TestTPFSDPIntegration)
 
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/fsdp/test_hsdp_dtensor_state_dict.py b/test/distributed/fsdp/test_hsdp_dtensor_state_dict.py
index 86dbda6c45..6685d31f5a 100644
--- a/test/distributed/fsdp/test_hsdp_dtensor_state_dict.py
+++ b/test/distributed/fsdp/test_hsdp_dtensor_state_dict.py
@@ -9,7 +9,7 @@ import torch.nn as nn
 from torch.distributed._shard.sharded_tensor import ShardedTensor
 
 from torch.distributed._tensor import DTensor, Replicate, Shard
-from torch.distributed.device_mesh import _mesh_resources, init_device_mesh
+from torch.distributed.device_mesh import init_device_mesh
 from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
 from torch.distributed.fsdp.api import (
     ShardedOptimStateDictConfig,
@@ -50,24 +50,6 @@ class DenseModel(torch.nn.Module):
 
 # TODO: Consolidate DeviceMesh based FSDP and HSDP test cases.
 class TestHSDPWithDeviceMeshAndDTensor(DTensorTestBase):
-    @with_comms
-    @skip_if_lt_x_gpu(4)
-    def test_raises_tp_hsdp_not_supported_error(self):
-        mesh_2d = init_device_mesh(self.device_type, (2, self.world_size // 2))
-        # manually set a fake parent mesh to mesh_2d
-        fake_parent_mesh = init_device_mesh(self.device_type, (self.world_size,))
-        _mesh_resources.child_to_parent_mapping[mesh_2d] = fake_parent_mesh
-
-        with self.assertRaisesRegex(
-            RuntimeError,
-            r"Hybrid sharding \+ TP is not supported yet.",
-        ):
-            model = FSDP(
-                DenseModel().cuda(),
-                device_mesh=mesh_2d,
-                sharding_strategy=ShardingStrategy.HYBRID_SHARD,
-            )
-
     def _create_model(self, device_mesh=None):
         if device_mesh:
             model = FSDP(
@@ -338,4 +320,4 @@ class TestHSDPWithDeviceMeshAndDTensor(DTensorTestBase):
 
 instantiate_parametrized_tests(TestHSDPWithDeviceMeshAndDTensor)
 if __name__ == "__main__":
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/distributed/test_dynamo_distributed.py b/test/distributed/test_dynamo_distributed.py
index 6a1f276897..47ea7e1e5a 100644
--- a/test/distributed/test_dynamo_distributed.py
+++ b/test/distributed/test_dynamo_distributed.py
@@ -269,6 +269,27 @@ class TestFakeDistributedSingleProc(torch._dynamo.test_case.TestCase):
         opt_model()
 
 
+    @patch.object(config, "optimize_ddp", True)
+    def test_symbol_splitting(self):
+        class Model(nn.Module):
+            def __init__(self):
+                super().__init__()
+                self.weight1 = nn.Parameter(torch.randn(512, 512))
+                self.weight2 = nn.Parameter(torch.randn(512, 512))
+
+            def forward(self, x):
+                x = torch.cat([x, x])
+                y = x @ self.weight1
+                z = x + y @ self.weight2
+                return z
+
+        model = Model()
+        model = FakeDDP(model)
+
+        opt_model = torch.compile(dynamic=True)(model)
+        opt_model(torch.randn(20, 512))
+
+
 # Are these tests failing?  Check and see if TestFakeDistributedSingleProc has a
 # single process version; if it's just a problem in the Dynamo distributed
 # optimizer, you should be able to repro it single process!
@@ -1053,4 +1074,4 @@ class TestSingleProc(DynamoDistributedSingleProcTestCase):
 
 if __name__ == "__main__":
     from torch._dynamo.test_case import run_tests
-    run_tests()
+    run_tests()
\ No newline at end of file
diff --git a/test/lazy/test_meta_kernel.py b/test/lazy/test_meta_kernel.py
index 06fd8b8ece..0fe3ab3b4f 100644
--- a/test/lazy/test_meta_kernel.py
+++ b/test/lazy/test_meta_kernel.py
@@ -32,3 +32,7 @@ class TestMetaKernel(TestCase):
         fc_bias = torch.nn.Linear(2, 2, bias=True, dtype=float16).to("lazy")
         out_bias = fc_bias(input)
         self.assertEqual(out_bias.dtype, torch.float16)
+
+    def test_add_invalid_device(self):
+        with self.assertRaisesRegex(RuntimeError, '.*not a lazy tensor.*'):
+            _ = torch.tensor([1], device="cpu") + torch.tensor([1], device="lazy")
\ No newline at end of file
diff --git a/torch/__init__.py b/torch/__init__.py
index 8693dd7c8a..f52060e971 100644
--- a/torch/__init__.py
+++ b/torch/__init__.py
@@ -666,7 +666,13 @@ def set_default_device(device):
 
 
 def set_default_tensor_type(t):
-    r"""Sets the default ``torch.Tensor`` type to floating point tensor type
+    r"""
+    .. warning::
+
+        This function is deprecated as of PyTorch 2.1, please use :func:`torch.set_default_dtype()` and
+        :func:`torch.set_default_device()` as alternatives.
+
+    Sets the default ``torch.Tensor`` type to floating point tensor type
     ``t``. This type will also be used as default floating point type for
     type inference in :func:`torch.tensor`.
 
diff --git a/torch/_dynamo/trace_rules.py b/torch/_dynamo/trace_rules.py
index e52c985d40..ee0c76b25a 100644
--- a/torch/_dynamo/trace_rules.py
+++ b/torch/_dynamo/trace_rules.py
@@ -59,7 +59,7 @@ manual_torch_name_rule_map = {
     "torch.distributed.is_initialized": TorchInGraphFunctionVariable,
     "torch.distributed.get_rank": TorchInGraphFunctionVariable,
     "torch.distributed.get_world_size": TorchInGraphFunctionVariable,
-    "torch.distributed._tensor.DTensor#from_local": TorchInGraphFunctionVariable,
+    "torch.distributed._tensor.api.DTensor#from_local": TorchInGraphFunctionVariable,
     "torch.distributed.distributed_c10d._get_group_tag": TorchInGraphFunctionVariable,
     "torch.distributed.distributed_c10d.get_process_group_ranks": TorchInGraphFunctionVariable,
     "torch._utils.is_compiling": TorchInGraphFunctionVariable,
diff --git a/torch/_inductor/codecache.py b/torch/_inductor/codecache.py
index f26b8fa499..4a41e8d5b8 100644
--- a/torch/_inductor/codecache.py
+++ b/torch/_inductor/codecache.py
@@ -2277,6 +2277,20 @@ def caching_device_properties():
             device_interface.Worker.get_device_properties()
 
 
+def _set_triton_ptxas_path() -> None:
+    if os.environ.get("TRITON_PTXAS_PATH") is not None:
+        return
+    ptxas_path = os.path.abspath(
+        os.path.join(os.path.dirname(__file__), "..", "bin", "ptxas")
+    )
+    if not os.path.exists(ptxas_path):
+        return
+    if os.path.isfile(ptxas_path) and os.access(ptxas_path, os.X_OK):
+        os.environ["TRITON_PTXAS_PATH"] = ptxas_path
+    else:
+        warnings.warn(f"{ptxas_path} exists but is not an executable")
+
+
 def _worker_compile(
     kernel_name: str, source_code: str, cc: int, device: torch.device
 ) -> None:
@@ -2287,6 +2301,7 @@ def _worker_compile(
 
 
 def _load_kernel(kernel_name: str, source_code: str) -> ModuleType:
+    _set_triton_ptxas_path()
     kernel = TritonCodeCache.load(kernel_name, source_code)
     kernel.precompile()
     return kernel
diff --git a/torch/_inductor/kernel/mm.py b/torch/_inductor/kernel/mm.py
index 6479c2d83c..4fbc4c6e63 100644
--- a/torch/_inductor/kernel/mm.py
+++ b/torch/_inductor/kernel/mm.py
@@ -1,5 +1,5 @@
 import logging
-from typing import Any, Dict, List
+from typing import Any, Dict, List, Optional
 
 import torch
 from torch._inductor.virtualized import V
@@ -259,10 +259,18 @@ def fallback_mixed_mm(mat1, mat2, *, out):
 aten_fallback_mixed_mm = ExternKernelChoice(fallback_mixed_mm, None)
 
 
+@functools.lru_cache(None)
+def _is_sm7x_or_older_gpu(index: Optional[int]) -> bool:
+    props = torch.cuda.get_device_properties(index or 0)
+    return props.major <= 7
+
+
 def tuned_mixed_mm(mat1, mat2, mat2_dtype):
     m, n, k, layout, mat1, mat2 = mm_args(mat1, mat2, layout=None)
     choices = [aten_fallback_mixed_mm.bind((mat1, mat2), layout)]
-    if mat1.layout.dtype != torch.float32 and not mat2.layout.is_contiguous():
+    if (
+        mat1.layout.dtype != torch.float32 and not mat2.layout.is_contiguous()
+    ) or _is_sm7x_or_older_gpu(layout.device.index):
         # can't use triton kernel unless one of these is true
         return autotune_select_algorithm("mixed_mm", choices, [mat1, mat2], layout)
     if inductor_config.force_mixed_mm:
diff --git a/torch/csrc/distributed/c10d/TCPStoreBackend.cpp b/torch/csrc/distributed/c10d/TCPStoreBackend.cpp
index 4c54932e34..6702595b29 100644
--- a/torch/csrc/distributed/c10d/TCPStoreBackend.cpp
+++ b/torch/csrc/distributed/c10d/TCPStoreBackend.cpp
@@ -539,6 +539,7 @@ void TCPStoreMasterDaemon::run() {
       int rawSocket = socket.handle();
       sockets_.emplace_back(std::move(socket));
       tcputil::addPollfd(fds, rawSocket, POLLIN);
+      addMiscellaneousSocket(rawSocket);
     }
     queryFds(fds);
   }
diff --git a/torch/csrc/lazy/core/shape_inference.cpp b/torch/csrc/lazy/core/shape_inference.cpp
index 39f26d8043..c1b3424c8d 100644
--- a/torch/csrc/lazy/core/shape_inference.cpp
+++ b/torch/csrc/lazy/core/shape_inference.cpp
@@ -159,7 +159,7 @@ TORCH_API std::vector<Shape> compute_shape_arange_out(
   // From torch.arange docs:
   // dtype (torch.dtype, optional)  the desired data type of returned tensor.
   // Default: if None, uses a global default (see
-  // torch.set_default_tensor_type()). If dtype is not given, infer the data
+  // torch.set_default_dtype()). If dtype is not given, infer the data
   // type from the other input arguments. If any of start, end, or stop are
   // floating-point, the dtype is inferred to be the default dtype, see
   // get_default_dtype(). Otherwise, the dtype is inferred to be torch.int64.
diff --git a/torch/distributed/_shard/sharded_tensor/__init__.py b/torch/distributed/_shard/sharded_tensor/__init__.py
index bb0271ca18..f2723dca4b 100644
--- a/torch/distributed/_shard/sharded_tensor/__init__.py
+++ b/torch/distributed/_shard/sharded_tensor/__init__.py
@@ -39,7 +39,7 @@ def empty(sharding_spec: shard_spec.ShardingSpec,
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -91,7 +91,7 @@ def ones(sharding_spec: shard_spec.ShardingSpec,
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -142,7 +142,7 @@ def zeros(sharding_spec: shard_spec.ShardingSpec,
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -195,7 +195,7 @@ def full(sharding_spec: shard_spec.ShardingSpec,
         fill_value (Scalar)  the value to fill the output tensor with.
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -247,7 +247,7 @@ def rand(sharding_spec: shard_spec.ShardingSpec,
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -301,7 +301,7 @@ def randn(sharding_spec: shard_spec.ShardingSpec,
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
diff --git a/torch/distributed/_shard/sharded_tensor/api.py b/torch/distributed/_shard/sharded_tensor/api.py
index 97a691746f..1fc3114ac7 100644
--- a/torch/distributed/_shard/sharded_tensor/api.py
+++ b/torch/distributed/_shard/sharded_tensor/api.py
@@ -210,7 +210,7 @@ class ShardedTensor(ShardedTensorBase):
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned tensor.
-                Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+                Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned Tensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
diff --git a/torch/distributed/_tensor/__init__.py b/torch/distributed/_tensor/__init__.py
index 98d12d3e31..b3755e7956 100644
--- a/torch/distributed/_tensor/__init__.py
+++ b/torch/distributed/_tensor/__init__.py
@@ -99,7 +99,7 @@ def ones(
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned DTensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -142,7 +142,7 @@ def empty(
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).\
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).\
         layout (:class:`torch.layout`, optional): the desired layout of returned :class:`DTensor`.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -188,7 +188,7 @@ def full(
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned DTensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -233,7 +233,7 @@ def rand(
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned DTensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -277,7 +277,7 @@ def randn(
 
     Keyword args:
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned DTensor.
             Default: ``torch.strided``.
         requires_grad (bool, optional): If autograd should record operations on the
@@ -320,7 +320,7 @@ def zeros(
         requires_grad (bool, optional): If autograd should record operations on the
             returned :class:`DTensor`. Default: ``False``.
         dtype (:class:`torch.dtype`, optional): the desired data type of returned :class:`DTensor`.
-            Default: if ``None``, uses a global default (see :func:`torch.set_default_tensor_type`).
+            Default: if ``None``, uses a global default (see :func:`torch.set_default_dtype`).
         layout (:class:`torch.layout`, optional): the desired layout of returned :class:`DTensor`.
             Default: ``torch.strided``.
         device_mesh: :class:`DeviceMesh` type, contains the mesh info of ranks
diff --git a/torch/distributed/_tensor/ops/tensor_ops.py b/torch/distributed/_tensor/ops/tensor_ops.py
index 41da2f14e6..a173ef3360 100644
--- a/torch/distributed/_tensor/ops/tensor_ops.py
+++ b/torch/distributed/_tensor/ops/tensor_ops.py
@@ -34,9 +34,27 @@ from torch.distributed.device_mesh import DeviceMesh
 aten = torch.ops.aten
 
 
-@register_op_strategy(
+def default_strategy(mesh: DeviceMesh, op_schema: OpSchema) -> StrategyType:
+    # Default strategy by default just propagate the first input strategy
+    select_strategy = op_schema.args_schema[0]
+    assert isinstance(select_strategy, OpStrategy)
+    default_strategy = []
+    for strategy in select_strategy.strategies:
+        # we create new DTensorSpecs even for default strategy to assure that
+        # the tensor metas are distinct between the arguments and outputs
+        default_strategy.append(
+            PlacementStrategy(
+                output_spec=DTensorSpec(
+                    mesh=strategy.output_spec.mesh,
+                    placements=strategy.output_spec.placements,
+                )
+            )
+        )
+    return OpStrategy(default_strategy)
+
+
+register_op_strategy(
     [
-        aten._to_copy.default,
         aten.clone.default,
         aten.contiguous.default,
         aten.copy_.default,
@@ -44,17 +62,11 @@ aten = torch.ops.aten
         aten.fill_.Scalar,
         aten.zero_.default,
     ]
-)
-def default_strategy(mesh: DeviceMesh, op_schema: OpSchema) -> StrategyType:
-    # Default strategy by default just propagate the first input strategy
-    select_strategy = op_schema.args_schema[0]
-    assert isinstance(select_strategy, OpStrategy)
-    return OpStrategy(
-        [
-            PlacementStrategy(arg_strategy.output_spec)
-            for arg_strategy in select_strategy.strategies
-        ]
-    )
+)(default_strategy)
+
+register_op_strategy(
+    aten._to_copy.default, schema_info=RuntimeSchemaInfo(static_kwargkey=["dtype"])
+)(default_strategy)
 
 
 @register_op_strategy(
diff --git a/torch/distributed/checkpoint/_state_dict_utils.py b/torch/distributed/checkpoint/_state_dict_utils.py
index 9b1fa7816e..1dc23d2f45 100644
--- a/torch/distributed/checkpoint/_state_dict_utils.py
+++ b/torch/distributed/checkpoint/_state_dict_utils.py
@@ -1,12 +1,15 @@
 import math
-from typing import Any, Callable, Dict, Optional, Tuple
+from typing import Any, Callable, Dict, Optional, Tuple, TYPE_CHECKING
 
 import torch
 import torch.distributed as dist
 import torch.nn.functional as F
-from torch.distributed import distributed_c10d
-from torch.distributed._shard.sharded_tensor import ShardedTensor
-from torch.distributed._tensor import DTensor, Replicate
+from torch.distributed._functional_collectives import AsyncCollectiveTensor
+
+if dist.is_available() or TYPE_CHECKING:
+    from torch.distributed import distributed_c10d
+    from torch.distributed._shard.sharded_tensor import ShardedTensor
+    from torch.distributed._tensor import DTensor, Replicate
 
 
 def _all_gather_sharded_tensor(
@@ -170,7 +173,12 @@ def _gather_state_dict(
             device_mesh=value.device_mesh,
             placements=placements,
         )
+        # Call `wait()` to force the tensor is synchronous with respect
+        # to the main stream.
+        # See the discussion in https://github.com/pytorch/pytorch/pull/117799.
         value = value.to_local()
+        if isinstance(value, AsyncCollectiveTensor):
+            value = value.wait()
         return value
 
     return _iterate_state_dict(
diff --git a/torch/distributed/checkpoint/state_dict.py b/torch/distributed/checkpoint/state_dict.py
index 79c66f3fc6..632bd2112a 100644
--- a/torch/distributed/checkpoint/state_dict.py
+++ b/torch/distributed/checkpoint/state_dict.py
@@ -157,7 +157,7 @@ def _get_fqns(model: nn.Module, name: str, skip_ddp_prefix: bool = True) -> FQNS
             if not skip_ddp_prefix:
                 fqn_obj_names.append(curr_obj_name)
         elif isinstance(curr_obj, FSDP):
-            if obj_names[i + 1] == FLAT_PARAM:
+            if i < len(obj_names) - 1 and obj_names[i + 1] == FLAT_PARAM:
                 prefix = ".".join(fqn_obj_names)
                 flat_param = getattr(curr_obj, FLAT_PARAM)
                 if prefix:
@@ -196,7 +196,7 @@ def _verify_options(
         Union[str, torch.Tensor], Union[Set[str], torch.Tensor]
     ] = {}
     all_fqns = set()
-    for name, param in model.named_parameters():
+    for name, param in chain(model.named_parameters(), model.named_buffers()):
         fqns = _get_fqns(model, name)
         fqn_param_mapping[param] = fqns
         for fqn in fqns:
@@ -395,7 +395,7 @@ def _load_model_state_dict(
     if not info.handle_model or not state_dict:
         return _IncompatibleKeys({}, {})
 
-    for key, _ in model.named_parameters():
+    for key, _ in chain(model.named_parameters(), model.named_buffers()):
         fqns = _get_fqns(model, key)
         fqns_with_ddp_prefix = _get_fqns(model, key, skip_ddp_prefix=False)
         for fqn, fqn_with_ddp_prefix in zip(fqns, fqns_with_ddp_prefix):
@@ -678,25 +678,25 @@ def get_state_dict(
     optimizer parameter IDs to the canonical FQNs.
 
     Example:
+        >>> # xdoctest: +SKIP
+        >>> import torch
+        >>> from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
+        >>> from torch.nn.parallel import DistributedDataParallel as DDP
+        >>> from torch.distributed.checkpoint.state_dict import get_state_dict
 
-        import torch
-        from torch.distributed.fsdp import FullyShardedDataParallel as FSDP
-        from torch.nn.parallel import DistributedDataParallel as DDP
-        from torch.distributed.checkpoint.state_dict import get_state_dict
-
-        fsdp_model = FSDP(copy.deepcopy(model))
-        fsdp_optim = torch.optim.Adam(model.parameters(), lr=1e-3)
-        ddp_model = DDP(copy.deepcopy(model))
-        ddp_optim = torch.optim.Adam(model.parameters(), lr=1e-3)
+        >>> fsdp_model = FSDP(copy.deepcopy(model))
+        >>> fsdp_optim = torch.optim.Adam(model.parameters(), lr=1e-3)
+        >>> ddp_model = DDP(copy.deepcopy(model))
+        >>> ddp_optim = torch.optim.Adam(model.parameters(), lr=1e-3)
 
 
-        ddp_state_dict, ddp_optim_state_dict = get_state_dict(ddp_model, ddp_optim)
-        fsdp_state_dict, fsdp_optim_state_dict = get_state_dict(fsdp_model, fsdp_optim)
+        >>> ddp_state_dict, ddp_optim_state_dict = get_state_dict(ddp_model, ddp_optim)
+        >>> fsdp_state_dict, fsdp_optim_state_dict = get_state_dict(fsdp_model, fsdp_optim)
 
-        # if we simply call ddp_model.state_dict() and fsdp_model.state_dict(),
-        # the asserts will fail.
-        assert ddp_state_dict == fsdp_state_dict
-        assert ddp_optim_state == fsdp_optim_state_dict
+        >>> # if we simply call ddp_model.state_dict() and fsdp_model.state_dict(),
+        >>> # the asserts will fail.
+        >>> assert ddp_state_dict == fsdp_state_dict
+        >>> assert ddp_optim_state == fsdp_optim_state_dict
 
 
     Args:
@@ -711,6 +711,8 @@ def get_state_dict(
 
     Returns:
         ``Tuple`` that contain model state_dict and optimizer state_dict.
+
+    :rtype: typing.Tuple[typing.Dict[str, ValueType], OptimizerStateType]
     """
 
     with gc_context():
diff --git a/torch/distributed/fsdp/_flat_param.py b/torch/distributed/fsdp/_flat_param.py
index 5c7b7396a5..04eadd783e 100644
--- a/torch/distributed/fsdp/_flat_param.py
+++ b/torch/distributed/fsdp/_flat_param.py
@@ -1860,6 +1860,7 @@ class FlatParamHandle:
         return views
 
     @no_type_check
+    @torch.enable_grad()
     def _use_unsharded_views(self, as_params: bool) -> None:
         """
         Unflatten the unsharded flat parameter by setting the original parameter variables to be views into it.
@@ -1870,6 +1871,12 @@ class FlatParamHandle:
                 the original parameters only as ``Tensor`` s. ``False`` should
                 be used during forward/backward computation and when hiding the
                 original parameters from :meth:`nn.Module.named_parameters`.
+                
+        Note:
+            when prefetching for next forward, current forward may be
+            annotated with `@torch.no_grad()`
+            `@torch.enable_grad()` ensures non-empty `view.grad_fn`
+            otherwise `_post_backward_hook` will not get called
         """
         flat_param = self.flat_param
         self._check_unsharded(flat_param)
diff --git a/torch/distributed/fsdp/_init_utils.py b/torch/distributed/fsdp/_init_utils.py
index b893f76bf2..10ee499bbe 100644
--- a/torch/distributed/fsdp/_init_utils.py
+++ b/torch/distributed/fsdp/_init_utils.py
@@ -56,6 +56,8 @@ from torch.distributed.fsdp.api import (
 from torch.distributed.fsdp.wrap import _Policy
 from torch.distributed.tensor.parallel.fsdp import DTensorExtensions
 from torch.distributed.utils import _sync_params_and_buffers
+
+from torch.utils._python_dispatch import is_traceable_wrapper_subclass
 from torch.utils.hooks import RemovableHandle
 
 _TORCHDISTX_AVAIL = True
@@ -202,12 +204,6 @@ def _is_valid_hybrid_shard_pg_type(process_group: Any) -> bool:
 
 @no_type_check
 def _is_valid_hybrid_shard_device_mesh(device_mesh: DeviceMesh) -> bool:
-    parent_mesh = _mesh_resources.get_parent_mesh(device_mesh)
-    if parent_mesh is not None:
-        raise RuntimeError(
-            f"Found device_mesh {device_mesh} passed in has a parent device_mesh {parent_mesh}.",
-            "Hybrid sharding + TP is not supported yet.",
-        )
     return isinstance(device_mesh, DeviceMesh) and device_mesh.ndim == 2
 
 
@@ -513,7 +509,7 @@ def _init_extension(state: _FSDPState, device_mesh: DeviceMesh = None) -> _FSDPS
     # TODO: we need to add additional check once we support FSDP + PiPPy.
     # This check is currently sufficient, since we only support FSDP + TP.
     if device_mesh and _mesh_resources.get_parent_mesh(state._device_mesh) is not None:
-        state._fsdp_extension = DTensorExtensions()
+        state._fsdp_extension = DTensorExtensions(state._device_handle)
     else:
         # We need to explicilty set _fsdp_extension to None.
         # Otherwise, we will run into an infinite recursion when getting the attribute.
@@ -1062,8 +1058,25 @@ def _sync_module_params_and_buffers(
         # Avoid re-synchronizing buffers in case of nested wrapping
         if not getattr(buffer, FSDP_SYNCED, False):
             setattr(buffer, FSDP_SYNCED, True)
-            module_states.append(buffer.detach())
-    module_states.extend(param.detach() for param in params)
+            detached_buffer = buffer.detach()
+            if is_traceable_wrapper_subclass(detached_buffer):
+                # NOTE: Here we assume no nested subclasses, at most one level of subclass
+                # in both model's buffers and params
+                attrs, _ = detached_buffer.__tensor_flatten__()  # type: ignore[attr-defined]
+                inner_buffers = [getattr(detached_buffer, attr) for attr in attrs]
+                module_states.extend(inner_buffers)
+            else:
+                module_states.append(detached_buffer)
+
+    for param in params:
+        detached_param = param.detach()
+        if is_traceable_wrapper_subclass(detached_param):
+            attrs, _ = detached_param.__tensor_flatten__()  # type: ignore[attr-defined]
+            inner_params = [getattr(detached_param, attr) for attr in attrs]
+            module_states.extend(inner_params)
+        else:
+            module_states.append(detached_param)
+
     _check_module_states_for_sync_module_states(module_states)
     _sync_params_and_buffers(
         process_group,
diff --git a/torch/distributed/fsdp/_runtime_utils.py b/torch/distributed/fsdp/_runtime_utils.py
index c00c6302d2..d0c363a4f6 100644
--- a/torch/distributed/fsdp/_runtime_utils.py
+++ b/torch/distributed/fsdp/_runtime_utils.py
@@ -104,38 +104,6 @@ def _is_fsdp_root(state: _FSDPState, module: nn.Module) -> bool:
     return state._is_root
 
 
-@no_type_check
-def _validate_and_get_hybrid_shard_state(root_module: nn.Module) -> None:
-    """
-    Precondition: ``root_module`` is a ``FullyShardedDataParallel`` instance.
-
-    This checks that all instances using a hybrid sharding strategy have the
-    same intra- and inter-node process groups.
-    """
-    intra_node_pgs: Set[dist.ProcessGroup] = set()
-    inter_node_pgs: Set[dist.ProcessGroup] = set()
-    for fsdp_state in traversal_utils._get_fsdp_states(root_module):
-        # TODO: Change this to handle's sharding strategy if we deprecate
-        # `ShardingStrategy` internally.
-        # https://github.com/pytorch/pytorch/issues/90857
-        if fsdp_state.sharding_strategy in HYBRID_SHARDING_STRATEGIES:
-            intra_node_pgs.add(fsdp_state.process_group)
-            inter_node_pgs.add(fsdp_state._inter_node_pg)
-    if len(intra_node_pgs) == 0 and len(inter_node_pgs) == 0:
-        # No instances use a hybrid sharding strategy
-        return
-    error_prefix = "At least one instance uses a hybrid sharding strategy but has no "
-    if len(intra_node_pgs) > 0 and len(inter_node_pgs) == 0:
-        raise AssertionError(error_prefix + "inter-node process group set")
-    if len(intra_node_pgs) == 0 and len(inter_node_pgs) > 0:
-        raise AssertionError(error_prefix + "intra-node process group set")
-    error_prefix = "Some instances use a hybrid sharding strategy, but "
-    if len(intra_node_pgs) != 1:
-        raise ValueError(error_prefix + "intra-node process groups do not match")
-    if len(inter_node_pgs) != 1:
-        raise ValueError(error_prefix + "inter-node process groups do not match")
-
-
 @no_type_check
 def _lazy_init(
     state: _FSDPState,
@@ -208,7 +176,6 @@ def _share_state_and_init_handle_attrs(
     handle = root_state._handle
     if handle:
         handle.init_flat_param_attributes()
-    _validate_and_get_hybrid_shard_state(root_module)
     attr_name_to_values: Dict[str, Set[Any]] = {}
     for attr_name in HOMOGENEOUS_ATTR_NAMES:
         attr_name_to_values[attr_name] = set()
@@ -250,6 +217,8 @@ def _share_state_and_init_handle_attrs(
         fsdp_state._default_stream = root_state._default_stream
         fsdp_state._exec_order_data = root_state._exec_order_data
         fsdp_state._free_event_queue = root_state._free_event_queue
+        if fsdp_state._fsdp_extension is not None:
+            fsdp_state._fsdp_extension.compute_stream = root_state._default_stream
         handle = fsdp_state._handle
         if handle:
             handle.init_flat_param_attributes()
@@ -279,6 +248,10 @@ def _init_streams(
     high_priority = -1 if state.limit_all_gathers and uses_hybrid_sharding else 0
     # Default stream for computation
     state._default_stream = state._device_handle.current_stream()
+    if state._fsdp_extension is not None:
+        # set the compute stream to the FSDP extension
+        state._fsdp_extension.compute_stream = state._default_stream
+
     # Stream for unshard logic, including allocating the all-gather destination
     # tensors and the all-gathers themselves
     state._unshard_stream = state._device_handle.Stream(priority=high_priority)
diff --git a/torch/distributed/fsdp/fully_sharded_data_parallel.py b/torch/distributed/fsdp/fully_sharded_data_parallel.py
index 62a8a51272..624449835b 100644
--- a/torch/distributed/fsdp/fully_sharded_data_parallel.py
+++ b/torch/distributed/fsdp/fully_sharded_data_parallel.py
@@ -468,7 +468,7 @@ class FullyShardedDataParallel(nn.Module, _FSDPState):
                 "ignored_states": self._ignored_params,
                 "device_mesh": device_mesh,
             }
-            if sharding_strategy in HYBRID_SHARDING_STRATEGIES:
+            if sharding_strategy in HYBRID_SHARDING_STRATEGIES and device_mesh is None:
                 # Share root process groups with children to maintain
                 # the invariant that all FSDP modules will have the same
                 # process groups.
diff --git a/torch/distributed/tensor/parallel/_data_parallel_utils.py b/torch/distributed/tensor/parallel/_data_parallel_utils.py
index d19258d93e..b56536d121 100644
--- a/torch/distributed/tensor/parallel/_data_parallel_utils.py
+++ b/torch/distributed/tensor/parallel/_data_parallel_utils.py
@@ -1,24 +1,49 @@
-from typing import Optional, Tuple
+from functools import partial
+from typing import no_type_check, Optional, Tuple
 
 import torch
-from torch.distributed._tensor import DTensor as DistributedTensor
+from torch.distributed._functional_collectives import AsyncCollectiveTensor
+from torch.distributed._tensor import DTensor
 from torch.distributed._tensor.placement_types import DTensorSpec
 
 
+@no_type_check
+def sync_grad_hook(grad, *, device_handle=None, compute_stream=None):
+    if isinstance(grad, AsyncCollectiveTensor):
+        if compute_stream is not None:
+            with device_handle.stream(compute_stream):
+                grad = grad.wait()
+        else:
+            grad = grad.wait()
+
+    return grad
+
+
 def _flatten_tensor(
     tensor: torch.Tensor,
 ) -> Tuple[torch.Tensor, Optional[DTensorSpec]]:
-    if isinstance(tensor, DistributedTensor):
+    if isinstance(tensor, DTensor):
         tensor._local_tensor.requires_grad_()
         return tensor._local_tensor, tensor._spec
     return tensor, None
 
 
-def _unflatten_tensor(tensor: torch.Tensor, spec: DTensorSpec) -> torch.Tensor:
-    result = DistributedTensor.from_local(
+@no_type_check
+def _unflatten_tensor(tensor, spec, *, device_handle=None, compute_stream=None):
+    # unflatten would mainly be called everytime FSDP allgather parameters.
+    result = DTensor.from_local(
         tensor,
         spec.mesh,
         spec.placements,
         run_check=False,
     )
+    if tensor.requires_grad:
+        # only register the hook if the tensor requires grad
+        tensor.register_hook(
+            partial(
+                sync_grad_hook,
+                device_handle=device_handle,
+                compute_stream=compute_stream,
+            )
+        )
     return result
diff --git a/torch/distributed/tensor/parallel/fsdp.py b/torch/distributed/tensor/parallel/fsdp.py
index 8272f07f67..07621f37a1 100644
--- a/torch/distributed/tensor/parallel/fsdp.py
+++ b/torch/distributed/tensor/parallel/fsdp.py
@@ -233,10 +233,10 @@ def _chunk_dtensor(
     parent_mesh = _mesh_resources.get_parent_mesh(device_mesh)
     if parent_mesh is None:
         raise RuntimeError("No parent device_mesh is found for FSDP device_mesh.")
-    if parent_mesh.ndim != 2:
+    if parent_mesh.ndim < 2:
         raise RuntimeError(
             f"Found parent device_mesh of ndim={parent_mesh.ndim},",
-            "but only 2D meshes are currently supported.",
+            "but meshes must be at least 2D.",
         )
 
     # We need to explicitly call .detach() to return a new tensor detached from the current graph.
@@ -270,9 +270,12 @@ def _chunk_dtensor(
         # For DTensors, it is sharded across tp dimension first and then sharded across FSDP dimension.
         # TP is the inner dimension and FSDP is the outer dimension.
         # Therefore, shard placements for tensor is (Shard(0), tp_placement).
+        # For higher dimensional meshes, it is replicated across other dimensions. For example, with
+        # HSDP the shard placements for tensor is (Replicate, Shard(0), tp_placement).
         replicate_placements = [Replicate() for _ in range(parent_mesh.ndim)]
         replicate_placements[-1] = tp_placement  # type: ignore[call-overload]
-        shard_placements = [DShard(0) for _ in range(parent_mesh.ndim)]  # type: ignore[misc]
+        shard_placements = [Replicate() for i in range(parent_mesh.ndim)]  # type: ignore[misc]
+        shard_placements[-2] = DShard(0)  # type: ignore[call-overload]
         shard_placements[-1] = tp_placement  # type: ignore[call-overload]
 
         return DTensor.from_local(
@@ -304,7 +307,9 @@ def _all_gather_dtensor(
 
     placements = list(copy.deepcopy(tensor.placements))
     # FSDP + TP: [Shard(0), tp_placement] -> [Replicate(), tp_placement]
-    placements[0] = Replicate()
+    # HSDP + TP: [Replicate(), Shard(0), tp_placement] -> [Replicate(), Replicate(), tp_placement]
+    for i in range(0, len(placements) - 1):
+        placements[i] = Replicate()
     tensor = tensor.redistribute(
         device_mesh=tensor.device_mesh,
         placements=placements,
@@ -320,7 +325,14 @@ class DTensorExtensions(FSDPExtensions):
     This is the implementation for FSDPExtensions defined in
     https://github.com/pytorch/pytorch/blob/main/torch/distributed/fsdp/_fsdp_extensions.py
     """
-
+    def __init__(self, device_handle) -> None:
+        super().__init__()
+        self.compute_stream = None
+        self.device_handle = device_handle
+        # we have to use the dynamo disable this way to disable dynamo as the decorater way would
+        # trigger build failure with torch deploy...
+        self.post_unflatten_transform = torch._dynamo.disable(self.post_unflatten_transform)  # type: ignore[method-assign]
+        
     def pre_flatten_transform(
         self,
         tensor: torch.Tensor,
@@ -330,9 +342,21 @@ class DTensorExtensions(FSDPExtensions):
     def post_unflatten_transform(
         self, tensor: torch.Tensor, param_extension: Any
     ) -> torch.Tensor:
-        result = _unflatten_tensor(tensor, param_extension)
-        _set_fsdp_flattened(result)
-        return result
+        stream = self.compute_stream or self.device_handle.current_stream()
+        with self.device_handle.stream(stream):
+            # runtime we put the unflattened tensor call on the compute stream since
+            # the unflattened tensor might contain computations in fwd/bwd where we
+            # need to sync properly.
+            # TODO: this is a short term fix and we should make the get_unflat_views
+            # directly happen in the compute stream.
+            result = _unflatten_tensor(
+                tensor,
+                param_extension,
+                device_handle=self.device_handle,
+                compute_stream=self.compute_stream
+            )
+            _set_fsdp_flattened(result)
+            return result
 
     def chunk_tensor(
         self,
diff --git a/torch/distributed/tensor/parallel/style.py b/torch/distributed/tensor/parallel/style.py
index aeb209b1db..024d0d3a1a 100644
--- a/torch/distributed/tensor/parallel/style.py
+++ b/torch/distributed/tensor/parallel/style.py
@@ -31,7 +31,7 @@ class ParallelStyle(ABC):
 
 class ColwiseParallel(ParallelStyle):
     """
-    Partition a compatible nn.Module in a row-wise fashion. Currently supports nn.Linear and nn.Embedding.
+    Partition a compatible nn.Module in a column-wise fashion. Currently supports nn.Linear and nn.Embedding.
     Users can compose it together with RowwiseParallel to achieve the sharding of more complicated modules.
     (i.e. MLP, Attention)
 
diff --git a/torch/fx/passes/split_module.py b/torch/fx/passes/split_module.py
index d175d6d1de..f48f5477ad 100644
--- a/torch/fx/passes/split_module.py
+++ b/torch/fx/passes/split_module.py
@@ -1,5 +1,5 @@
 import inspect
-from typing import Any, Callable, Dict, List, Optional, Set
+from typing import Any, Callable, Dict, List, Optional, Set, TYPE_CHECKING
 from collections import OrderedDict
 import logging
 
@@ -8,6 +8,9 @@ from torch.fx._compatibility import compatibility
 from torch.fx.graph_module import GraphModule
 from torch.fx.node import Node
 
+if TYPE_CHECKING:
+    import sympy  # noqa: F401
+    
 __all__ = ["Partition", "split_module"]
 _LOGGER = logging.getLogger(__name__)
 
@@ -166,10 +169,13 @@ def split_module(
 
     partitions: Dict[str, Partition] = {}
     orig_nodes: Dict[str, Node] = {}
+    symbol_to_node: Dict["sympy.Symbol", Node] = {}
 
     def record_cross_partition_use(
         def_node: Node, use_node: Optional[Node]
     ):  # noqa: B950
+        from torch.fx.experimental.symbolic_shapes import free_symbols
+        
         defined = getattr(def_node, "_fx_partition", None)
         used = getattr(use_node, "_fx_partition", None)
         if defined != used:
@@ -182,6 +188,9 @@ def split_module(
             if used is not None:
                 use_partition = partitions[used]
                 use_partition.inputs.setdefault(def_node.name)
+                if (def_val := def_node.meta.get("example_value")) is not None:
+                    for s in sorted(free_symbols(def_val)):
+                        use_partition.inputs.setdefault(symbol_to_node[s].name)
                 if defined is not None:
                     use_partition.dependencies.setdefault(defined)
 
@@ -222,9 +231,18 @@ def split_module(
 
     active_grad = None
     active_autocasts = set()
+    
+    import sympy  # noqa: F811
 
     for node in m.graph.nodes:
         if node.op in ["placeholder", "get_attr", "output"]:
+            if (
+                node.op == "placeholder" and
+                (val := node.meta.get("example_value")) is not None and
+                isinstance(val, torch.SymInt) and
+                isinstance(val.node.expr, sympy.Symbol)
+            ):
+                symbol_to_node[val.node.expr] = node
             continue
 
         instantiate_node_partition_mapping(node)
diff --git a/torch/testing/_internal/common_dist_composable.py b/torch/testing/_internal/common_dist_composable.py
index 9ec92c6e71..938de12e11 100644
--- a/torch/testing/_internal/common_dist_composable.py
+++ b/torch/testing/_internal/common_dist_composable.py
@@ -55,6 +55,9 @@ class CompositeParamModel(nn.Module):
         self.u1 = UnitModule(device)
         self.u2 = UnitModule(device)
         self.p = nn.Parameter(torch.randn((100, 100), device=device))
+        self.register_buffer(
+            "buffer", torch.randn((100, 100), device=device), persistent=True
+        )
 
     def forward(self, x):
         a = self.u2(self.u1(self.l(x)))
-- 
2.17.2 (Apple Git-113)

